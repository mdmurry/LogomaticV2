   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.cfi_sections	.debug_frame
   5              		.align	2
   7              	UART0ISR:
   8              	.LFB3:
   9              		.file 1 "main.c"
   1:main.c        **** /*********************************************************************************
   2:main.c        ****  * Logomatic V2 Firmware
   3:main.c        ****  * Sparkfun Electronics 2008
   4:main.c        ****  * ******************************************************************************/
   5:main.c        **** 
   6:main.c        **** /*******************************************************
   7:main.c        ****  * 		     Header Files
   8:main.c        ****  ******************************************************/
   9:main.c        **** #include <stdio.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include "LPC21xx.h"
  12:main.c        **** 
  13:main.c        **** //UART0 Debugging
  14:main.c        **** #include "serial.h"
  15:main.c        **** #include "rprintf.h"
  16:main.c        **** 
  17:main.c        **** //Needed for main function calls
  18:main.c        **** #include "main_msc.h"
  19:main.c        **** #include "fat.h"
  20:main.c        **** #include "armVIC.h"
  21:main.c        **** #include "itoa.h"
  22:main.c        **** #include "rootdir.h"
  23:main.c        **** #include "sd_raw.h"
  24:main.c        **** 
  25:main.c        **** /*********************************************************
  26:main.c        **** *               Program Change Ideas
  27:main.c        **** *  Need to log both GPS and ADC
  28:main.c        **** *  ADC1 = TMP36 (temperature)
  29:main.c        **** *  ADC2 = ADXL326-Xout
  30:main.c        **** *  ADC3 = ADXL326-Yout
  31:main.c        **** *  ADC4 = ADXL326-Zout
  32:main.c        **** *  UART0 (RX1 & TX1?) GPS @ 9600 TTL
  33:main.c        **** 
  34:main.c        **** *  Use UART0 character in Interrupt
  35:main.c        **** *  See if character is ASCII 10 or 13 (only test for one)
  36:main.c        **** *  which is the end of a NMEA sentence
  37:main.c        **** *  If so, trigger an ADC read?? Means an ADC read with 
  38:main.c        **** *  EVERY NMEA sentence (way too often) but otherwise need
  39:main.c        **** *  to scan buffer for NMEA sentence type and trigger off
  40:main.c        **** *  one known to only happen 1/sec (1hz)??
  41:main.c        **** 
  42:main.c        ****   - consider stripping date/time from GPS NMEA sentence
  43:main.c        ****   - and adding to beginning of each ADC logging?
  44:main.c        **** 
  45:main.c        **** *  Version 1 - scan/log ADC with each GPS NMEA sentence
  46:main.c        **** *  Version 2 - parse NMEA and only trigger ADC on one type
  47:main.c        **** **********************************************************/
  48:main.c        **** 
  49:main.c        **** 
  50:main.c        **** /*******************************************************
  51:main.c        ****  * 		     Global Variables
  52:main.c        ****  ******************************************************/
  53:main.c        **** 
  54:main.c        **** #define ON	1
  55:main.c        **** #define OFF	0
  56:main.c        **** #define TRUE 1
  57:main.c        **** #define FALSE 0
  58:main.c        **** #define ADC_1 1
  59:main.c        **** #define ADC_2 2
  60:main.c        **** #define ADC_3 3
  61:main.c        **** #define ADC_4 4
  62:main.c        **** #define ADC_5 5
  63:main.c        **** #define ADC_6 6
  64:main.c        **** #define ADC_7 7
  65:main.c        **** #define ADC_8 8
  66:main.c        **** 
  67:main.c        **** char RX_array1[512];
  68:main.c        **** char RX_array2[512];
  69:main.c        **** char ADC_array[512];
  70:main.c        **** char log_array1 = 0;
  71:main.c        **** char log_array2 = 0;
  72:main.c        **** short RX_in = 0;
  73:main.c        **** short ADC_in = 0;
  74:main.c        **** char log_adc = 0;
  75:main.c        **** char get_frame = 0;
  76:main.c        **** 
  77:main.c        **** signed int stringSize;
  78:main.c        **** signed int ADCStringSize;
  79:main.c        **** struct fat_file_struct* handle;
  80:main.c        **** struct fat_file_struct * fd;
  81:main.c        **** char stringBuf[256];
  82:main.c        **** unsigned int gps_valid = FALSE;
  83:main.c        **** unsigned int log_gps = FALSE;
  84:main.c        **** unsigned int use_adc = FALSE;
  85:main.c        **** 
  86:main.c        **** // RTC testing
  87:main.c        **** unsigned int hours, minutes, seconds;
  88:main.c        **** void InitializeTime(void);
  89:main.c        **** void GetTime(void);
  90:main.c        **** char time_buffer[8]; // HH:MM:SS
  91:main.c        **** 
  92:main.c        **** // Default Settings
  93:main.c        **** static char mode = 0;
  94:main.c        **** static char asc = 'N';
  95:main.c        **** static int baud = 9600;
  96:main.c        **** static int freq = 100;
  97:main.c        **** static char trig = '$';
  98:main.c        **** static short frame = 100;
  99:main.c        **** static char ad1_7 = 'N';	// ADC 5
 100:main.c        **** static char ad1_6 = 'N';	// ADC 6
 101:main.c        **** static char ad1_3 = 'N';	// ADC 8
 102:main.c        **** static char ad1_2 = 'N';	// ADC 7
 103:main.c        **** static char ad0_4 = 'N';	// ADC 4
 104:main.c        **** static char ad0_3 = 'N';	// ADC 1
 105:main.c        **** static char ad0_2 = 'N';	// ADC 2
 106:main.c        **** static char ad0_1 = 'N';	// ADC 3
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** /*******************************************************
 110:main.c        ****  * 		 Function Declarations
 111:main.c        ****  ******************************************************/
 112:main.c        **** 
 113:main.c        **** void Initialize(void);
 114:main.c        **** 
 115:main.c        **** void setup_uart0(int newbaud, char want_ints);
 116:main.c        **** 
 117:main.c        **** void mode_0(void);
 118:main.c        **** void mode_1(void);
 119:main.c        **** void mode_2(void);
 120:main.c        **** void mode_3(void);
 121:main.c        **** void mode_action(void);
 122:main.c        **** 
 123:main.c        **** void Log_init(void);
 124:main.c        **** void test(void);
 125:main.c        **** void stat(int statnum, int onoff);
 126:main.c        **** void AD_conversion(int regbank);
 127:main.c        **** 
 128:main.c        **** void feed(void);
 129:main.c        **** 
 130:main.c        **** static void IRQ_Routine(void) __attribute__ ((interrupt("IRQ")));
 131:main.c        **** static void UART0ISR(void); //__attribute__ ((interrupt("IRQ")));
 132:main.c        **** static void UART0ISR_2(void); //__attribute__ ((interrupt("IRQ")));
 133:main.c        **** static void MODE2ISR(void); //__attribute__ ((interrupt("IRQ")));
 134:main.c        **** 
 135:main.c        **** void FIQ_Routine(void) __attribute__ ((interrupt("FIQ")));
 136:main.c        **** void SWI_Routine(void) __attribute__ ((interrupt("SWI")));
 137:main.c        **** void UNDEF_Routine(void) __attribute__ ((interrupt("UNDEF")));
 138:main.c        **** 
 139:main.c        **** void LogADC(void);
 140:main.c        **** void GetADCValue(int adc);
 141:main.c        **** 
 142:main.c        **** void fat_initialize(void);
 143:main.c        **** 
 144:main.c        **** void delay_ms(int count);
 145:main.c        **** 
 146:main.c        **** void GetGPSDateTime(void);
 147:main.c        **** 
 148:main.c        **** 
 149:main.c        **** /*******************************************************
 150:main.c        ****  * 		     	MAIN
 151:main.c        ****  ******************************************************/
 152:main.c        **** 
 153:main.c        **** int main (void)
 154:main.c        **** {
 155:main.c        **** 	int i;
 156:main.c        **** 	char name[32];
 157:main.c        **** 	int count = 0;
 158:main.c        **** 	
 159:main.c        **** 	enableFIQ();
 160:main.c        **** 	
 161:main.c        **** 	Initialize();
 162:main.c        **** 	
 163:main.c        **** 	InitializeTime();
 164:main.c        **** 	
 165:main.c        **** 	setup_uart0(9600, 0);
 166:main.c        **** 
 167:main.c        **** 	fat_initialize();		
 168:main.c        **** 
 169:main.c        **** 
 170:main.c        **** 	// Flash Status Lights
 171:main.c        **** 	for(i = 0; i < 5; i++)
 172:main.c        **** 	{
 173:main.c        **** 		stat(0,ON);
 174:main.c        **** 		delay_ms(50);
 175:main.c        **** 		stat(0,OFF);
 176:main.c        **** 		stat(1,ON);
 177:main.c        **** 		delay_ms(50);
 178:main.c        **** 		stat(1,OFF);
 179:main.c        **** 	}
 180:main.c        **** 	
 181:main.c        **** 	Log_init();
 182:main.c        **** 
 183:main.c        **** 	count++;
 184:main.c        **** 	string_printf(name,"LOG%02d.txt",count);
 185:main.c        **** 	while(root_file_exists(name))
 186:main.c        **** 	{
 187:main.c        **** 		count++;
 188:main.c        **** 		if(count == 250) 
 189:main.c        **** 		{
 190:main.c        **** 			rprintf("Too Many Logs!\n\r");
 191:main.c        **** 			while(1)
 192:main.c        **** 			{
 193:main.c        **** 				stat(0,ON);
 194:main.c        **** 				stat(1,ON);
 195:main.c        **** 				delay_ms(1000);
 196:main.c        **** 				stat(0,OFF);
 197:main.c        **** 				stat(1,OFF);
 198:main.c        **** 				delay_ms(1000);
 199:main.c        **** 			}
 200:main.c        **** 
 201:main.c        **** 		}
 202:main.c        **** 		string_printf(name,"LOG%02d.txt",count);
 203:main.c        **** 	}
 204:main.c        **** 	
 205:main.c        **** 	handle = root_open_new(name);
 206:main.c        **** 		
 207:main.c        **** 
 208:main.c        **** 	sd_raw_sync();	
 209:main.c        **** 		
 210:main.c        **** 	// if mode = 2 or 3 (ADC used) then write out the ADC pins in use
 211:main.c        **** 	if(mode == 2 || mode == 3)
 212:main.c        **** 	{
 213:main.c        **** 		char mybuf[10];	// eight pins + CR/LF
 214:main.c        **** 		mybuf[0] = ad0_3;
 215:main.c        **** 		mybuf[1] = ad0_2;
 216:main.c        **** 		mybuf[2] = ad0_1;
 217:main.c        **** 		mybuf[3] = ad0_4;
 218:main.c        **** 		mybuf[4] = ad1_7;
 219:main.c        **** 		mybuf[5] = ad1_6;
 220:main.c        **** 		mybuf[6] = ad1_2;
 221:main.c        **** 		mybuf[7] = ad1_3;
 222:main.c        **** 		mybuf[8] = 13;
 223:main.c        **** 		mybuf[9] = 10;	
 224:main.c        **** 	
 225:main.c        **** 		stat(0,ON);
 226:main.c        **** 				
 227:main.c        **** 		if(fat_write_file(handle,(unsigned char *)mybuf, 10) < 0)
 228:main.c        **** 		{
 229:main.c        **** 			while(1)
 230:main.c        **** 			{
 231:main.c        **** 				stat(0,ON);
 232:main.c        **** 				for(int j = 0; j < 500000; j++)
 233:main.c        **** 				stat(0,OFF);
 234:main.c        **** 				stat(1,ON);
 235:main.c        **** 				for(int j = 0; j < 500000; j++)
 236:main.c        **** 				stat(1,OFF);
 237:main.c        **** 			}
 238:main.c        **** 		}
 239:main.c        **** 			
 240:main.c        **** 		sd_raw_sync();
 241:main.c        **** 		stat(0,OFF);
 242:main.c        **** 	}	
 243:main.c        **** 	
 244:main.c        **** 	
 245:main.c        **** 	
 246:main.c        **** 	switch(mode)
 247:main.c        **** 	{
 248:main.c        **** 		case 0:
 249:main.c        **** 			mode_0();
 250:main.c        **** 		break;
 251:main.c        **** 		
 252:main.c        **** 		case 1:
 253:main.c        **** 			mode_1();
 254:main.c        **** 		break;
 255:main.c        **** 		
 256:main.c        **** 		case 2:
 257:main.c        **** 			mode_2();
 258:main.c        **** 		break;
 259:main.c        **** 		
 260:main.c        **** 		case 3:
 261:main.c        **** 			mode_3();
 262:main.c        **** 		break;
 263:main.c        **** 		
 264:main.c        **** 		default:
 265:main.c        **** 			rprintf("Mode %d not valid.\n\r",mode);
 266:main.c        **** 		break;
 267:main.c        **** 	}
 268:main.c        **** 	
 269:main.c        **** 	while(1)
 270:main.c        **** 	{
 271:main.c        **** 		stat(0,ON);
 272:main.c        **** 		stat(1,ON);
 273:main.c        **** 		delay_ms(1000);
 274:main.c        **** 		stat(0,OFF);
 275:main.c        **** 		stat(1,OFF);
 276:main.c        **** 		delay_ms(1000);
 277:main.c        **** 	}
 278:main.c        ****    	return 0;
 279:main.c        **** }
 280:main.c        **** 
 281:main.c        **** 
 282:main.c        **** /*******************************************************
 283:main.c        ****  * 		     Initialize
 284:main.c        ****  ******************************************************/
 285:main.c        **** 
 286:main.c        **** #define PLOCK 0x400
 287:main.c        **** 
 288:main.c        **** void Initialize(void)
 289:main.c        **** {
 290:main.c        **** 	rprintf_devopen(putc_serial0);
 291:main.c        **** 	
 292:main.c        **** 	PINSEL0 = 0xCF351505;
 293:main.c        **** 	PINSEL1 = 0x15441801;
 294:main.c        **** 	IODIR0 |= 0x00000884;
 295:main.c        **** 	IOSET0 = 0x00000080;
 296:main.c        **** 
 297:main.c        **** 	S0SPCR = 0x08;  // SPI clk to be pclk/8
 298:main.c        **** 	S0SPCR = 0x30;  // master, msb, first clk edge, active high, no ints
 299:main.c        **** 
 300:main.c        **** }
 301:main.c        **** 
 302:main.c        **** void feed(void)
 303:main.c        **** {
 304:main.c        **** 	PLLFEED=0xAA;
 305:main.c        **** 	PLLFEED=0x55;
 306:main.c        **** }
 307:main.c        **** 
 308:main.c        **** /*******************************************
 309:main.c        **** * UART interrupt calls this function which
 310:main.c        **** * retrieves the arriving character that triggered
 311:main.c        **** * the interrupt and saves the character to the
 312:main.c        **** * buffer which is written to the microSD when
 313:main.c        **** * the buffer is full
 314:main.c        **** *******************************************/
 315:main.c        **** static void UART0ISR(void)
 316:main.c        **** {
  10              		.loc 1 316 0
  11              		.cfi_startproc
  12              		@ Function supports interworking.
  13              		@ args = 0, pretend = 0, frame = 0
  14              		@ frame_needed = 0, uses_anonymous_args = 0
  15              		@ link register save eliminated.
 317:main.c        **** 	char temp;
 318:main.c        **** 
 319:main.c        **** 
 320:main.c        **** 	if(RX_in < 512)
  16              		.loc 1 320 0
  17 0000 88309FE5 		ldr	r3, .L6
  18 0004 B020D3E1 		ldrh	r2, [r3, #0]
  19 0008 02C8A0E1 		mov	ip, r2, asl #16
  20 000c 4C18A0E1 		mov	r1, ip, asr #16
  21 0010 7C009FE5 		ldr	r0, .L6+4
  22 0014 020C51E3 		cmp	r1, #512
 321:main.c        **** 	{
 322:main.c        **** 		RX_array1[RX_in] = U0RBR;
  23              		.loc 1 322 0
  24 0018 0000D0E5 		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 320:main.c        **** 	{
  25              		.loc 1 320 0
  26 001c 090000AA 		bge	.L2
 323:main.c        **** 	
 324:main.c        **** 		RX_in++;
  27              		.loc 1 324 0
  28 0020 012082E2 		add	r2, r2, #1
  29 0024 0228A0E1 		mov	r2, r2, asl #16
  30 0028 2228A0E1 		mov	r2, r2, lsr #16
 325:main.c        **** 
 326:main.c        **** 		if(RX_in == 512) log_array1 = 1;
  31              		.loc 1 326 0
  32 002c 020C52E3 		cmp	r2, #512
 322:main.c        **** 	
  33              		.loc 1 322 0
  34 0030 60109FE5 		ldr	r1, .L6+8
 324:main.c        **** 
  35              		.loc 1 324 0
  36 0034 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  37              		.loc 1 326 0
  38 0038 0120A003 		moveq	r2, #1
 322:main.c        **** 	
  39              		.loc 1 322 0
  40 003c 4C08C1E7 		strb	r0, [r1, ip, asr #16]
  41              		.loc 1 326 0
  42 0040 0220C305 		streqb	r2, [r3, #2]
  43 0044 0B0000EA 		b	.L4
  44              	.L2:
 327:main.c        **** 	}
 328:main.c        **** 	else if(RX_in >= 512)
 329:main.c        **** 	{
 330:main.c        **** 		RX_array2[RX_in-512] = U0RBR;
 331:main.c        **** 		RX_in++;
  45              		.loc 1 331 0
  46 0048 012082E2 		add	r2, r2, #1
  47 004c 0228A0E1 		mov	r2, r2, asl #16
  48 0050 2228A0E1 		mov	r2, r2, lsr #16
 332:main.c        **** 
 333:main.c        **** 		if(RX_in == 1024)
  49              		.loc 1 333 0
  50 0054 010B52E3 		cmp	r2, #1024
 330:main.c        **** 		RX_in++;
  51              		.loc 1 330 0
  52 0058 3CC09FE5 		ldr	ip, .L6+12
 331:main.c        **** 
  53              		.loc 1 331 0
  54 005c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 334:main.c        **** 		{
 335:main.c        **** 			log_array2 = 1;
  55              		.loc 1 335 0
  56 0060 0120A003 		moveq	r2, #1
 330:main.c        **** 		RX_in++;
  57              		.loc 1 330 0
  58 0064 01108CE0 		add	r1, ip, r1
  59              		.loc 1 335 0
  60 0068 0320C305 		streqb	r2, [r3, #3]
 336:main.c        **** 			RX_in = 0;
  61              		.loc 1 336 0
  62 006c 0020A003 		moveq	r2, #0
 330:main.c        **** 		RX_in++;
  63              		.loc 1 330 0
  64 0070 000241E5 		strb	r0, [r1, #-512]
  65              		.loc 1 336 0
  66 0074 B020C301 		streqh	r2, [r3, #0]	@ movhi
  67              	.L4:
 337:main.c        **** 		}
 338:main.c        **** 	}
 339:main.c        **** 
 340:main.c        **** 
 341:main.c        **** 	temp = U0IIR; // Have to read this to clear the interrupt 
  68              		.loc 1 341 0
  69 0078 14309FE5 		ldr	r3, .L6+4
 342:main.c        **** 
 343:main.c        **** 	VICVectAddr = 0;
  70              		.loc 1 343 0
  71 007c 0020A0E3 		mov	r2, #0
 341:main.c        **** 
  72              		.loc 1 341 0
  73 0080 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
  74              	.LVL0:
  75              		.loc 1 343 0
  76 0084 0030E0E3 		mvn	r3, #0
  77 0088 CF2F03E5 		str	r2, [r3, #-4047]
  78 008c 1EFF2FE1 		bx	lr
  79              	.L7:
  80              		.align	2
  81              	.L6:
  82 0090 00000000 		.word	.LANCHOR0
  83 0094 00C000E0 		.word	-536821760
  84 0098 00000000 		.word	RX_array1
  85 009c 00000000 		.word	RX_array2
  86              		.cfi_endproc
  87              	.LFE3:
  89              		.align	2
  91              	UART0ISR_2:
  92              	.LFB4:
 344:main.c        **** 	
 345:main.c        **** }
 346:main.c        **** 
 347:main.c        **** static void UART0ISR_2(void)
 348:main.c        **** {
  93              		.loc 1 348 0
  94              		.cfi_startproc
  95              		@ Function supports interworking.
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98              		@ link register save eliminated.
  99 00a0 30002DE9 		stmfd	sp!, {r4, r5}
 100              	.LCFI0:
 101              		.cfi_def_cfa_offset 8
 102              		.cfi_offset 4, -8
 103              		.cfi_offset 5, -4
 349:main.c        **** 	char temp;
 350:main.c        **** 	temp = U0RBR;
 104              		.loc 1 350 0
 105 00a4 0C319FE5 		ldr	r3, .L14
 106 00a8 00C0D3E5 		ldrb	ip, [r3, #0]	@ zero_extendqisi2
 351:main.c        **** 
 352:main.c        **** 	if(temp == trig){ get_frame = 1; }
 107              		.loc 1 352 0
 108 00ac 08319FE5 		ldr	r3, .L14+4
 109 00b0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 350:main.c        **** 
 110              		.loc 1 350 0
 111 00b4 FFC00CE2 		and	ip, ip, #255
 112              	.LVL1:
 113              		.loc 1 352 0
 114 00b8 0C0053E1 		cmp	r3, ip
 115 00bc FC209FE5 		ldr	r2, .L14+8
 116 00c0 0130A003 		moveq	r3, #1
 117 00c4 0430C205 		streqb	r3, [r2, #4]
 353:main.c        **** 	
 354:main.c        **** 	if(get_frame)
 118              		.loc 1 354 0
 119 00c8 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 120 00cc 000052E3 		cmp	r2, #0
 121 00d0 E8309FE5 		ldr	r3, .L14+8
 122 00d4 3000000A 		beq	.L11
 355:main.c        **** 	{
 356:main.c        **** 		if(RX_in < frame)
 123              		.loc 1 356 0
 124 00d8 B000D3E1 		ldrh	r0, [r3, #0]
 125 00dc D8209FE5 		ldr	r2, .L14+4
 126 00e0 0058A0E1 		mov	r5, r0, asl #16
 127 00e4 F220D2E1 		ldrsh	r2, [r2, #2]
 128 00e8 4548A0E1 		mov	r4, r5, asr #16
 129 00ec 020054E1 		cmp	r4, r2
 130 00f0 010080E2 		add	r0, r0, #1
 131 00f4 120000AA 		bge	.L12
 357:main.c        **** 		{
 358:main.c        **** 			RX_array1[RX_in] = temp;
 359:main.c        **** 			RX_in++;
 132              		.loc 1 359 0
 133 00f8 0008A0E1 		mov	r0, r0, asl #16
 134 00fc 2008A0E1 		mov	r0, r0, lsr #16
 358:main.c        **** 			RX_in++;
 135              		.loc 1 358 0
 136 0100 BC109FE5 		ldr	r1, .L14+12
 137              		.loc 1 359 0
 138 0104 B000C3E1 		strh	r0, [r3, #0]	@ movhi
 360:main.c        **** 
 361:main.c        **** 			if(RX_in == frame)
 139              		.loc 1 361 0
 140 0108 0008A0E1 		mov	r0, r0, asl #16
 358:main.c        **** 			RX_in++;
 141              		.loc 1 358 0
 142 010c 45C8C1E7 		strb	ip, [r1, r5, asr #16]
 143              		.loc 1 361 0
 144 0110 40C8A0E1 		mov	ip, r0, asr #16
 145              	.LVL2:
 146 0114 02005CE1 		cmp	ip, r2
 147 0118 1F00001A 		bne	.L11
 362:main.c        **** 			{
 363:main.c        **** 				RX_array1[RX_in] = 10; // delimiters
 148              		.loc 1 363 0
 149 011c 0A20A0E3 		mov	r2, #10
 150 0120 4028C1E7 		strb	r2, [r1, r0, asr #16]
 364:main.c        **** 				RX_array1[RX_in + 1] = 13;
 151              		.loc 1 364 0
 152 0124 0D20A0E3 		mov	r2, #13
 153 0128 0C1081E0 		add	r1, r1, ip
 154 012c 0120C1E5 		strb	r2, [r1, #1]
 365:main.c        **** 				log_array1 = 1;
 155              		.loc 1 365 0
 156 0130 0120A0E3 		mov	r2, #1
 157 0134 0220C3E5 		strb	r2, [r3, #2]
 366:main.c        **** 				get_frame = 0;
 158              		.loc 1 366 0
 159 0138 0020A0E3 		mov	r2, #0
 160 013c 0420C3E5 		strb	r2, [r3, #4]
 161 0140 150000EA 		b	.L11
 162              	.LVL3:
 163              	.L12:
 367:main.c        **** 			}
 368:main.c        **** 		}
 369:main.c        **** 		else if(RX_in >= frame)
 370:main.c        **** 		{
 371:main.c        **** 			RX_array2[RX_in - frame] = temp;
 372:main.c        **** 			RX_in++;
 164              		.loc 1 372 0
 165 0144 0008A0E1 		mov	r0, r0, asl #16
 166 0148 2008A0E1 		mov	r0, r0, lsr #16
 167 014c B000C3E1 		strh	r0, [r3, #0]	@ movhi
 373:main.c        **** 
 374:main.c        **** 			if(RX_in == 2*frame)
 168              		.loc 1 374 0
 169 0150 0008A0E1 		mov	r0, r0, asl #16
 371:main.c        **** 			RX_in++;
 170              		.loc 1 371 0
 171 0154 6C109FE5 		ldr	r1, .L14+16
 172              		.loc 1 374 0
 173 0158 4008A0E1 		mov	r0, r0, asr #16
 371:main.c        **** 			RX_in++;
 174              		.loc 1 371 0
 175 015c 044062E0 		rsb	r4, r2, r4
 176              		.loc 1 374 0
 177 0160 820050E1 		cmp	r0, r2, asl #1
 371:main.c        **** 			RX_in++;
 178              		.loc 1 371 0
 179 0164 04C0C1E7 		strb	ip, [r1, r4]
 180              		.loc 1 374 0
 181 0168 0B00001A 		bne	.L11
 375:main.c        **** 			{
 376:main.c        **** 				RX_array2[RX_in - frame] = 10; // delimiters
 182              		.loc 1 376 0
 183 016c 00C062E0 		rsb	ip, r2, r0
 184              	.LVL4:
 377:main.c        **** 				RX_array2[RX_in + 1 - frame] = 13;
 185              		.loc 1 377 0
 186 0170 010080E2 		add	r0, r0, #1
 187 0174 002062E0 		rsb	r2, r2, r0
 376:main.c        **** 				RX_array2[RX_in + 1 - frame] = 13;
 188              		.loc 1 376 0
 189 0178 0A40A0E3 		mov	r4, #10
 190              		.loc 1 377 0
 191 017c 0D00A0E3 		mov	r0, #13
 376:main.c        **** 				RX_array2[RX_in + 1 - frame] = 13;
 192              		.loc 1 376 0
 193 0180 0C40C1E7 		strb	r4, [r1, ip]
 194              		.loc 1 377 0
 195 0184 0200C1E7 		strb	r0, [r1, r2]
 378:main.c        **** 				log_array2 = 1;
 196              		.loc 1 378 0
 197 0188 0120A0E3 		mov	r2, #1
 198 018c 0320C3E5 		strb	r2, [r3, #3]
 379:main.c        **** 				get_frame = 0;
 199              		.loc 1 379 0
 200 0190 0020A0E3 		mov	r2, #0
 201 0194 0420C3E5 		strb	r2, [r3, #4]
 380:main.c        **** 				RX_in = 0;
 202              		.loc 1 380 0
 203 0198 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 204              	.L11:
 381:main.c        **** 			}
 382:main.c        **** 		}
 383:main.c        **** 	}
 384:main.c        **** 
 385:main.c        **** 	temp = U0IIR; // have to read this to clear the interrupt
 205              		.loc 1 385 0
 206 019c 14309FE5 		ldr	r3, .L14
 386:main.c        **** 
 387:main.c        **** 	VICVectAddr = 0;
 207              		.loc 1 387 0
 208 01a0 0020A0E3 		mov	r2, #0
 385:main.c        **** 
 209              		.loc 1 385 0
 210 01a4 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 211              		.loc 1 387 0
 212 01a8 0030E0E3 		mvn	r3, #0
 213 01ac CF2F03E5 		str	r2, [r3, #-4047]
 388:main.c        **** }
 214              		.loc 1 388 0
 215 01b0 3000BDE8 		ldmfd	sp!, {r4, r5}
 216 01b4 1EFF2FE1 		bx	lr
 217              	.L15:
 218              		.align	2
 219              	.L14:
 220 01b8 00C000E0 		.word	-536821760
 221 01bc 00000000 		.word	.LANCHOR1
 222 01c0 00000000 		.word	.LANCHOR0
 223 01c4 00000000 		.word	RX_array1
 224 01c8 00000000 		.word	RX_array2
 225              		.cfi_endproc
 226              	.LFE4:
 228              		.align	2
 230              	MODE2ISR:
 231              	.LFB5:
 389:main.c        **** 		
 390:main.c        **** static void MODE2ISR(void)
 391:main.c        **** {
 232              		.loc 1 391 0
 233              		.cfi_startproc
 234              		@ Function supports interworking.
 235              		@ args = 0, pretend = 0, frame = 56
 236              		@ frame_needed = 0, uses_anonymous_args = 0
 237              	.LVL5:
 238 01cc F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 239              	.LCFI1:
 240              		.cfi_def_cfa_offset 32
 241              		.cfi_offset 4, -32
 242              		.cfi_offset 5, -28
 243              		.cfi_offset 6, -24
 244              		.cfi_offset 7, -20
 245              		.cfi_offset 8, -16
 246              		.cfi_offset 9, -12
 247              		.cfi_offset 10, -8
 248              		.cfi_offset 14, -4
 392:main.c        **** 	int temp = 0, temp2 = 0, ind = 0;
 393:main.c        **** 	int j;
 394:main.c        **** 	short a;
 395:main.c        **** 	char q[50], temp_buff[4];
 396:main.c        **** 
 397:main.c        **** 
 398:main.c        **** 	T0IR = 1; // reset TMR0 interrupt
 249              		.loc 1 398 0
 250 01d0 FC3B9FE5 		ldr	r3, .L152
 251 01d4 0120A0E3 		mov	r2, #1
 252 01d8 002083E5 		str	r2, [r3, #0]
 253              	.LVL6:
 399:main.c        **** 	
 400:main.c        **** 	for(j = 0; j < 50; j++)
 254              		.loc 1 400 0
 255 01dc 0030A0E3 		mov	r3, #0
 391:main.c        **** 	int temp = 0, temp2 = 0, ind = 0;
 256              		.loc 1 391 0
 257 01e0 38D04DE2 		sub	sp, sp, #56
 258              	.LCFI2:
 259              		.cfi_def_cfa_offset 88
 401:main.c        **** 	{
 402:main.c        **** 		q[j] = 0;
 260              		.loc 1 402 0
 261 01e4 0310A0E1 		mov	r1, r3
 262              	.LVL7:
 263              	.L17:
 264              		.loc 1 402 0 is_stmt 0 discriminator 2
 265 01e8 04208DE2 		add	r2, sp, #4
 266 01ec 0210C3E7 		strb	r1, [r3, r2]
 400:main.c        **** 	{
 267              		.loc 1 400 0 is_stmt 1 discriminator 2
 268 01f0 013083E2 		add	r3, r3, #1
 269              	.LVL8:
 270 01f4 320053E3 		cmp	r3, #50
 271 01f8 FAFFFF1A 		bne	.L17
 403:main.c        **** 	}
 404:main.c        **** 
 405:main.c        **** 	// ADC_1
 406:main.c        **** 	// Get AD0.3
 407:main.c        **** 	if(ad0_3 == 'Y')
 272              		.loc 1 407 0
 273 01fc D43B9FE5 		ldr	r3, .L152+4
 274              	.LVL9:
 275 0200 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 276 0204 590053E3 		cmp	r3, #89
 277 0208 0100000A 		beq	.L18
 278              	.LVL10:
 279              	.L28:
 392:main.c        **** 	int j;
 280              		.loc 1 392 0
 281 020c 0040A0E3 		mov	r4, #0
 282 0210 440000EA 		b	.L19
 283              	.LVL11:
 284              	.L18:
 408:main.c        **** 	{
 409:main.c        **** 		AD0CR = 0x00020FF08; // AD0.3
 285              		.loc 1 409 0
 286 0214 C03B9FE5 		ldr	r3, .L152+8
 287 0218 C02B9FE5 		ldr	r2, .L152+12
 288 021c 002083E5 		str	r2, [r3, #0]
 410:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 289              		.loc 1 410 0
 290 0220 002093E5 		ldr	r2, [r3, #0]
 291 0224 012482E3 		orr	r2, r2, #16777216
 292 0228 002083E5 		str	r2, [r3, #0]
 293              	.LVL12:
 294              	.L20:
 411:main.c        **** 		while((temp & 0x80000000) == 0)
 412:main.c        **** 		{
 413:main.c        **** 			temp = AD0DR;
 295              		.loc 1 413 0
 296 022c 042093E5 		ldr	r2, [r3, #4]
 297              	.LVL13:
 411:main.c        **** 		while((temp & 0x80000000) == 0)
 298              		.loc 1 411 0
 299 0230 000052E3 		cmp	r2, #0
 300 0234 FCFFFFAA 		bge	.L20
 301              	.LVL14:
 414:main.c        **** 		}
 415:main.c        **** 		temp &= 0x0000FFC0;
 416:main.c        **** 		temp2 = temp / 0x00000040;
 417:main.c        **** 
 418:main.c        **** 		AD0CR = 0x00000000;
 302              		.loc 1 418 0
 303 0238 9C3B9FE5 		ldr	r3, .L152+8
 304 023c 0040A0E3 		mov	r4, #0
 305 0240 004083E5 		str	r4, [r3, #0]
 419:main.c        **** 
 420:main.c        **** 		if(asc == 'Y' || asc ==',')
 306              		.loc 1 420 0
 307 0244 8C3B9FE5 		ldr	r3, .L152+4
 415:main.c        **** 		temp2 = temp / 0x00000040;
 308              		.loc 1 415 0
 309 0248 940B9FE5 		ldr	r0, .L152+16
 310              		.loc 1 420 0
 311 024c 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 415:main.c        **** 		temp2 = temp / 0x00000040;
 312              		.loc 1 415 0
 313 0250 000002E0 		and	r0, r2, r0
 314              	.LVL15:
 315              		.loc 1 420 0
 316 0254 590053E3 		cmp	r3, #89
 317 0258 2C005313 		cmpne	r3, #44
 416:main.c        **** 
 318              		.loc 1 416 0
 319 025c 4003A0E1 		mov	r0, r0, asr #6
 320              	.LVL16:
 321              		.loc 1 420 0
 322 0260 2A00001A 		bne	.L21
 421:main.c        **** 		{
 422:main.c        **** 			itoa(temp2, 10, temp_buff);
 323              		.loc 1 422 0
 324 0264 0A10A0E3 		mov	r1, #10
 325 0268 0D20A0E1 		mov	r2, sp
 326              	.LVL17:
 327 026c FEFFFFEB 		bl	itoa
 328              	.LVL18:
 423:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 329              		.loc 1 423 0
 330 0270 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 331 0274 302043E2 		sub	r2, r3, #48
 332 0278 090052E3 		cmp	r2, #9
 424:main.c        **** 			{
 425:main.c        **** 				q[ind] = temp_buff[0];
 333              		.loc 1 425 0
 334 027c 0430CD95 		strlsb	r3, [sp, #4]
 335              	.LVL19:
 426:main.c        **** 				ind++;
 427:main.c        **** 			}
 428:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 336              		.loc 1 428 0
 337 0280 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 338 0284 302043E2 		sub	r2, r3, #48
 426:main.c        **** 				ind++;
 339              		.loc 1 426 0
 340 0288 0140A093 		movls	r4, #1
 341              	.LVL20:
 342              		.loc 1 428 0
 343 028c 090052E3 		cmp	r2, #9
 429:main.c        **** 			{
 430:main.c        **** 				q[ind] = temp_buff[1];
 344              		.loc 1 430 0
 345 0290 38108D92 		addls	r1, sp, #56
 346 0294 04208190 		addls	r2, r1, r4
 347 0298 34304295 		strlsb	r3, [r2, #-52]
 431:main.c        **** 				ind++;
 432:main.c        **** 			}
 433:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 348              		.loc 1 433 0
 349 029c 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 350 02a0 302043E2 		sub	r2, r3, #48
 431:main.c        **** 				ind++;
 351              		.loc 1 431 0
 352 02a4 01408492 		addls	r4, r4, #1
 353              	.LVL21:
 354              		.loc 1 433 0
 355 02a8 090052E3 		cmp	r2, #9
 434:main.c        **** 			{
 435:main.c        **** 				q[ind] = temp_buff[2];
 356              		.loc 1 435 0
 357 02ac 38108D92 		addls	r1, sp, #56
 358 02b0 04208190 		addls	r2, r1, r4
 359 02b4 34304295 		strlsb	r3, [r2, #-52]
 436:main.c        **** 				ind++;
 437:main.c        **** 			}
 438:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 360              		.loc 1 438 0
 361 02b8 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 362 02bc 302043E2 		sub	r2, r3, #48
 436:main.c        **** 				ind++;
 363              		.loc 1 436 0
 364 02c0 01408492 		addls	r4, r4, #1
 365              	.LVL22:
 366              		.loc 1 438 0
 367 02c4 090052E3 		cmp	r2, #9
 439:main.c        **** 			{
 440:main.c        **** 				q[ind] = temp_buff[3];
 368              		.loc 1 440 0
 369 02c8 38108D92 		addls	r1, sp, #56
 370 02cc 04208190 		addls	r2, r1, r4
 371 02d0 34304295 		strlsb	r3, [r2, #-52]
 441:main.c        **** 				ind++;
 442:main.c        **** 			}
 443:main.c        **** 
 444:main.c        **** 			if(asc == ',')
 372              		.loc 1 444 0
 373 02d4 FC3A9FE5 		ldr	r3, .L152+4
 374 02d8 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 441:main.c        **** 				ind++;
 375              		.loc 1 441 0
 376 02dc 01408492 		addls	r4, r4, #1
 377              	.LVL23:
 378 02e0 38108DE2 		add	r1, sp, #56
 379              		.loc 1 444 0
 380 02e4 2C0052E3 		cmp	r2, #44
 381 02e8 043081E0 		add	r3, r1, r4
 445:main.c        **** 			{
 446:main.c        **** 				q[ind] = ',';
 447:main.c        **** 			}
 448:main.c        **** 			else
 449:main.c        **** 			{
 450:main.c        **** 				q[ind] = 0;
 382              		.loc 1 450 0
 383 02ec 0020A013 		movne	r2, #0
 384 02f0 342043E5 		strb	r2, [r3, #-52]
 451:main.c        **** 			}
 452:main.c        **** 			ind++;
 453:main.c        **** 			temp = 0; 
 454:main.c        **** 			temp2 = 0;
 455:main.c        **** 			temp_buff[0] = 0;
 385              		.loc 1 455 0
 386 02f4 0030A0E3 		mov	r3, #0
 452:main.c        **** 			temp = 0; 
 387              		.loc 1 452 0
 388 02f8 014084E2 		add	r4, r4, #1
 389              	.LVL24:
 390              		.loc 1 455 0
 391 02fc 0030CDE5 		strb	r3, [sp, #0]
 456:main.c        **** 			temp_buff[1] = 0;
 392              		.loc 1 456 0
 393 0300 0130CDE5 		strb	r3, [sp, #1]
 457:main.c        **** 			temp_buff[2] = 0;
 394              		.loc 1 457 0
 395 0304 0230CDE5 		strb	r3, [sp, #2]
 458:main.c        **** 			temp_buff[3] = 0;
 396              		.loc 1 458 0
 397 0308 0330CDE5 		strb	r3, [sp, #3]
 398 030c 050000EA 		b	.L19
 399              	.LVL25:
 400              	.L21:
 459:main.c        **** 
 460:main.c        **** 		}
 461:main.c        **** 
 462:main.c        **** 		else if(asc == 'N')
 401              		.loc 1 462 0
 402 0310 4E0053E3 		cmp	r3, #78
 403 0314 BCFFFF1A 		bne	.L28
 404              	.LVL26:
 463:main.c        **** 		{
 464:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 405              		.loc 1 464 0
 406 0318 2034A0E1 		mov	r3, r0, lsr #8
 465:main.c        **** 			q[ind] = (char)a;
 407              		.loc 1 465 0
 408 031c 0430CDE5 		strb	r3, [sp, #4]
 466:main.c        **** 			
 467:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 409              		.loc 1 467 0
 410 0320 0500CDE5 		strb	r0, [sp, #5]
 411              	.LVL27:
 468:main.c        **** 			ind += 2;
 412              		.loc 1 468 0
 413 0324 0240A0E3 		mov	r4, #2
 414              	.LVL28:
 415              	.L19:
 469:main.c        **** 			temp = 0;
 470:main.c        **** 		}
 471:main.c        **** 	}
 472:main.c        **** 	// ADC_2
 473:main.c        **** 	// Get AD0.2
 474:main.c        **** 	if(ad0_2 == 'Y')
 416              		.loc 1 474 0
 417 0328 A83A9FE5 		ldr	r3, .L152+4
 418 032c 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 419 0330 590053E3 		cmp	r3, #89
 420 0334 4800001A 		bne	.L29
 475:main.c        **** 	{
 476:main.c        **** 		AD0CR = 0x00020FF04; // AD1.2
 421              		.loc 1 476 0
 422 0338 9C3A9FE5 		ldr	r3, .L152+8
 423 033c A42A9FE5 		ldr	r2, .L152+20
 424 0340 002083E5 		str	r2, [r3, #0]
 477:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 425              		.loc 1 477 0
 426 0344 002093E5 		ldr	r2, [r3, #0]
 427 0348 012482E3 		orr	r2, r2, #16777216
 428 034c 002083E5 		str	r2, [r3, #0]
 429              	.L30:
 478:main.c        **** 		while((temp & 0x80000000) == 0)
 479:main.c        **** 		{
 480:main.c        **** 			temp = AD0DR;
 430              		.loc 1 480 0
 431 0350 042093E5 		ldr	r2, [r3, #4]
 432              	.LVL29:
 478:main.c        **** 		while((temp & 0x80000000) == 0)
 433              		.loc 1 478 0
 434 0354 000052E3 		cmp	r2, #0
 435 0358 FCFFFFAA 		bge	.L30
 436              	.LVL30:
 481:main.c        **** 		}
 482:main.c        **** 		temp &= 0x0000FFC0;
 437              		.loc 1 482 0
 438 035c 800A9FE5 		ldr	r0, .L152+16
 483:main.c        **** 		temp2 = temp / 0x00000040;
 484:main.c        **** 
 485:main.c        **** 		AD0CR = 0x00000000;
 439              		.loc 1 485 0
 440 0360 743A9FE5 		ldr	r3, .L152+8
 482:main.c        **** 		temp2 = temp / 0x00000040;
 441              		.loc 1 482 0
 442 0364 000002E0 		and	r0, r2, r0
 443              	.LVL31:
 444              		.loc 1 485 0
 445 0368 0020A0E3 		mov	r2, #0
 446 036c 002083E5 		str	r2, [r3, #0]
 486:main.c        **** 
 487:main.c        **** 		if(asc == 'Y' || asc == ',')
 447              		.loc 1 487 0
 448 0370 603A9FE5 		ldr	r3, .L152+4
 449 0374 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 450 0378 590053E3 		cmp	r3, #89
 451 037c 2C005313 		cmpne	r3, #44
 483:main.c        **** 
 452              		.loc 1 483 0
 453 0380 4003A0E1 		mov	r0, r0, asr #6
 454              	.LVL32:
 455              		.loc 1 487 0
 456 0384 2C00001A 		bne	.L31
 488:main.c        **** 		{
 489:main.c        **** 			itoa(temp2, 10, temp_buff);
 457              		.loc 1 489 0
 458 0388 0A10A0E3 		mov	r1, #10
 459 038c 0D20A0E1 		mov	r2, sp
 460 0390 FEFFFFEB 		bl	itoa
 461              	.LVL33:
 490:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 462              		.loc 1 490 0
 463 0394 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 464 0398 302043E2 		sub	r2, r3, #48
 465 039c 090052E3 		cmp	r2, #9
 491:main.c        **** 			{
 492:main.c        **** 				q[ind] = temp_buff[0];
 466              		.loc 1 492 0
 467 03a0 38108D92 		addls	r1, sp, #56
 468 03a4 04208190 		addls	r2, r1, r4
 469 03a8 34304295 		strlsb	r3, [r2, #-52]
 493:main.c        **** 				ind++;
 494:main.c        **** 			}
 495:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 470              		.loc 1 495 0
 471 03ac 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 472 03b0 302043E2 		sub	r2, r3, #48
 493:main.c        **** 				ind++;
 473              		.loc 1 493 0
 474 03b4 01408492 		addls	r4, r4, #1
 475              	.LVL34:
 476              		.loc 1 495 0
 477 03b8 090052E3 		cmp	r2, #9
 496:main.c        **** 			{
 497:main.c        **** 				q[ind] = temp_buff[1];
 478              		.loc 1 497 0
 479 03bc 38108D92 		addls	r1, sp, #56
 480 03c0 04208190 		addls	r2, r1, r4
 481 03c4 34304295 		strlsb	r3, [r2, #-52]
 498:main.c        **** 				ind++;
 499:main.c        **** 			}
 500:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 482              		.loc 1 500 0
 483 03c8 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 484 03cc 302043E2 		sub	r2, r3, #48
 498:main.c        **** 				ind++;
 485              		.loc 1 498 0
 486 03d0 01408492 		addls	r4, r4, #1
 487              	.LVL35:
 488              		.loc 1 500 0
 489 03d4 090052E3 		cmp	r2, #9
 501:main.c        **** 			{
 502:main.c        **** 				q[ind] = temp_buff[2];
 490              		.loc 1 502 0
 491 03d8 38108D92 		addls	r1, sp, #56
 492 03dc 04208190 		addls	r2, r1, r4
 493 03e0 34304295 		strlsb	r3, [r2, #-52]
 503:main.c        **** 				ind++;
 504:main.c        **** 			}
 505:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 494              		.loc 1 505 0
 495 03e4 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 496 03e8 302043E2 		sub	r2, r3, #48
 503:main.c        **** 				ind++;
 497              		.loc 1 503 0
 498 03ec 01408492 		addls	r4, r4, #1
 499              	.LVL36:
 500              		.loc 1 505 0
 501 03f0 090052E3 		cmp	r2, #9
 506:main.c        **** 			{
 507:main.c        **** 				q[ind] = temp_buff[3];
 502              		.loc 1 507 0
 503 03f4 38108D92 		addls	r1, sp, #56
 504 03f8 04208190 		addls	r2, r1, r4
 505 03fc 34304295 		strlsb	r3, [r2, #-52]
 508:main.c        **** 				ind++;
 509:main.c        **** 			}
 510:main.c        **** 
 511:main.c        **** 			if(asc == ',')
 506              		.loc 1 511 0
 507 0400 D0399FE5 		ldr	r3, .L152+4
 508 0404 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 508:main.c        **** 				ind++;
 509              		.loc 1 508 0
 510 0408 01408492 		addls	r4, r4, #1
 511              	.LVL37:
 512 040c 38108DE2 		add	r1, sp, #56
 513              		.loc 1 511 0
 514 0410 2C0052E3 		cmp	r2, #44
 515 0414 043081E0 		add	r3, r1, r4
 512:main.c        **** 			{
 513:main.c        **** 				q[ind] = ',';
 514:main.c        **** 			}
 515:main.c        **** 			else
 516:main.c        **** 			{
 517:main.c        **** 				q[ind] = 0;
 516              		.loc 1 517 0
 517 0418 0020A013 		movne	r2, #0
 518 041c 342043E5 		strb	r2, [r3, #-52]
 518:main.c        **** 			}
 519:main.c        **** 			ind++;
 520:main.c        **** 			temp = 0; 
 521:main.c        **** 			temp2 = 0;
 522:main.c        **** 			temp_buff[0] = 0;
 519              		.loc 1 522 0
 520 0420 0030A0E3 		mov	r3, #0
 519:main.c        **** 			temp = 0; 
 521              		.loc 1 519 0
 522 0424 014084E2 		add	r4, r4, #1
 523              	.LVL38:
 524              		.loc 1 522 0
 525 0428 0030CDE5 		strb	r3, [sp, #0]
 523:main.c        **** 			temp_buff[1] = 0;
 526              		.loc 1 523 0
 527 042c 0130CDE5 		strb	r3, [sp, #1]
 524:main.c        **** 			temp_buff[2] = 0;
 528              		.loc 1 524 0
 529 0430 0230CDE5 		strb	r3, [sp, #2]
 525:main.c        **** 			temp_buff[3] = 0;
 530              		.loc 1 525 0
 531 0434 0330CDE5 		strb	r3, [sp, #3]
 532 0438 070000EA 		b	.L29
 533              	.LVL39:
 534              	.L31:
 526:main.c        **** 
 527:main.c        **** 		}
 528:main.c        **** 
 529:main.c        **** 		else if(asc == 'N')
 535              		.loc 1 529 0
 536 043c 4E0053E3 		cmp	r3, #78
 537 0440 0500001A 		bne	.L29
 538              	.LVL40:
 530:main.c        **** 		{
 531:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 532:main.c        **** 			q[ind] = (char)a;
 539              		.loc 1 532 0
 540 0444 38208DE2 		add	r2, sp, #56
 541 0448 043082E0 		add	r3, r2, r4
 531:main.c        **** 			q[ind] = (char)a;
 542              		.loc 1 531 0
 543 044c 2024A0E1 		mov	r2, r0, lsr #8
 544              		.loc 1 532 0
 545 0450 342043E5 		strb	r2, [r3, #-52]
 533:main.c        **** 			
 534:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 546              		.loc 1 534 0
 547 0454 330043E5 		strb	r0, [r3, #-51]
 535:main.c        **** 			ind += 2;
 548              		.loc 1 535 0
 549 0458 024084E2 		add	r4, r4, #2
 550              	.LVL41:
 551              	.L29:
 536:main.c        **** 			temp = 0;
 537:main.c        **** 		}
 538:main.c        **** 	}
 539:main.c        **** 	// ADC_3
 540:main.c        **** 	// Get AD0.1
 541:main.c        **** 	if(ad0_1 == 'Y')
 552              		.loc 1 541 0
 553 045c 74399FE5 		ldr	r3, .L152+4
 554 0460 0730D3E5 		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 555 0464 590053E3 		cmp	r3, #89
 556 0468 4800001A 		bne	.L38
 542:main.c        **** 	{
 543:main.c        **** 		AD0CR = 0x00020FF02; // AD0.1
 557              		.loc 1 543 0
 558 046c 68399FE5 		ldr	r3, .L152+8
 559 0470 74299FE5 		ldr	r2, .L152+24
 560 0474 002083E5 		str	r2, [r3, #0]
 544:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 561              		.loc 1 544 0
 562 0478 002093E5 		ldr	r2, [r3, #0]
 563 047c 012482E3 		orr	r2, r2, #16777216
 564 0480 002083E5 		str	r2, [r3, #0]
 565              	.L39:
 545:main.c        **** 		while((temp & 0x80000000) == 0)
 546:main.c        **** 		{
 547:main.c        **** 			temp = AD0DR;
 566              		.loc 1 547 0
 567 0484 042093E5 		ldr	r2, [r3, #4]
 568              	.LVL42:
 545:main.c        **** 		while((temp & 0x80000000) == 0)
 569              		.loc 1 545 0
 570 0488 000052E3 		cmp	r2, #0
 571 048c FCFFFFAA 		bge	.L39
 572              	.LVL43:
 548:main.c        **** 		}
 549:main.c        **** 		temp &= 0x0000FFC0;
 573              		.loc 1 549 0
 574 0490 4C099FE5 		ldr	r0, .L152+16
 550:main.c        **** 		temp2 = temp / 0x00000040;
 551:main.c        **** 
 552:main.c        **** 		AD0CR = 0x00000000;
 575              		.loc 1 552 0
 576 0494 40399FE5 		ldr	r3, .L152+8
 549:main.c        **** 		temp2 = temp / 0x00000040;
 577              		.loc 1 549 0
 578 0498 000002E0 		and	r0, r2, r0
 579              	.LVL44:
 580              		.loc 1 552 0
 581 049c 0020A0E3 		mov	r2, #0
 582 04a0 002083E5 		str	r2, [r3, #0]
 553:main.c        **** 
 554:main.c        **** 		if(asc == 'Y' || asc == ',')
 583              		.loc 1 554 0
 584 04a4 2C399FE5 		ldr	r3, .L152+4
 585 04a8 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 586 04ac 590053E3 		cmp	r3, #89
 587 04b0 2C005313 		cmpne	r3, #44
 550:main.c        **** 
 588              		.loc 1 550 0
 589 04b4 4003A0E1 		mov	r0, r0, asr #6
 590              	.LVL45:
 591              		.loc 1 554 0
 592 04b8 2C00001A 		bne	.L40
 555:main.c        **** 		{
 556:main.c        **** 			itoa(temp2, 10, temp_buff);
 593              		.loc 1 556 0
 594 04bc 0A10A0E3 		mov	r1, #10
 595 04c0 0D20A0E1 		mov	r2, sp
 596 04c4 FEFFFFEB 		bl	itoa
 597              	.LVL46:
 557:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 598              		.loc 1 557 0
 599 04c8 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 600 04cc 302043E2 		sub	r2, r3, #48
 601 04d0 090052E3 		cmp	r2, #9
 558:main.c        **** 			{
 559:main.c        **** 				q[ind] = temp_buff[0];
 602              		.loc 1 559 0
 603 04d4 38108D92 		addls	r1, sp, #56
 604 04d8 04208190 		addls	r2, r1, r4
 605 04dc 34304295 		strlsb	r3, [r2, #-52]
 560:main.c        **** 				ind++;
 561:main.c        **** 			}
 562:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 606              		.loc 1 562 0
 607 04e0 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 608 04e4 302043E2 		sub	r2, r3, #48
 560:main.c        **** 				ind++;
 609              		.loc 1 560 0
 610 04e8 01408492 		addls	r4, r4, #1
 611              	.LVL47:
 612              		.loc 1 562 0
 613 04ec 090052E3 		cmp	r2, #9
 563:main.c        **** 			{
 564:main.c        **** 				q[ind] = temp_buff[1];
 614              		.loc 1 564 0
 615 04f0 38108D92 		addls	r1, sp, #56
 616 04f4 04208190 		addls	r2, r1, r4
 617 04f8 34304295 		strlsb	r3, [r2, #-52]
 565:main.c        **** 				ind++;
 566:main.c        **** 			}
 567:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 618              		.loc 1 567 0
 619 04fc 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 620 0500 302043E2 		sub	r2, r3, #48
 565:main.c        **** 				ind++;
 621              		.loc 1 565 0
 622 0504 01408492 		addls	r4, r4, #1
 623              	.LVL48:
 624              		.loc 1 567 0
 625 0508 090052E3 		cmp	r2, #9
 568:main.c        **** 			{
 569:main.c        **** 				q[ind] = temp_buff[2];
 626              		.loc 1 569 0
 627 050c 38108D92 		addls	r1, sp, #56
 628 0510 04208190 		addls	r2, r1, r4
 629 0514 34304295 		strlsb	r3, [r2, #-52]
 570:main.c        **** 				ind++;
 571:main.c        **** 			}
 572:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 630              		.loc 1 572 0
 631 0518 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 632 051c 302043E2 		sub	r2, r3, #48
 570:main.c        **** 				ind++;
 633              		.loc 1 570 0
 634 0520 01408492 		addls	r4, r4, #1
 635              	.LVL49:
 636              		.loc 1 572 0
 637 0524 090052E3 		cmp	r2, #9
 573:main.c        **** 			{
 574:main.c        **** 				q[ind] = temp_buff[3];
 638              		.loc 1 574 0
 639 0528 38108D92 		addls	r1, sp, #56
 640 052c 04208190 		addls	r2, r1, r4
 641 0530 34304295 		strlsb	r3, [r2, #-52]
 575:main.c        **** 				ind++;
 576:main.c        **** 			}
 577:main.c        **** 
 578:main.c        **** 			if(asc == ',')
 642              		.loc 1 578 0
 643 0534 9C389FE5 		ldr	r3, .L152+4
 644 0538 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 575:main.c        **** 				ind++;
 645              		.loc 1 575 0
 646 053c 01408492 		addls	r4, r4, #1
 647              	.LVL50:
 648 0540 38108DE2 		add	r1, sp, #56
 649              		.loc 1 578 0
 650 0544 2C0052E3 		cmp	r2, #44
 651 0548 043081E0 		add	r3, r1, r4
 579:main.c        **** 			{
 580:main.c        **** 				q[ind] = ',';
 581:main.c        **** 			}
 582:main.c        **** 			else
 583:main.c        **** 			{
 584:main.c        **** 				q[ind] = 0;
 652              		.loc 1 584 0
 653 054c 0020A013 		movne	r2, #0
 654 0550 342043E5 		strb	r2, [r3, #-52]
 585:main.c        **** 			}
 586:main.c        **** 			ind++;
 587:main.c        **** 			temp = 0; 
 588:main.c        **** 			temp2 = 0;
 589:main.c        **** 			temp_buff[0] = 0;
 655              		.loc 1 589 0
 656 0554 0030A0E3 		mov	r3, #0
 586:main.c        **** 			temp = 0; 
 657              		.loc 1 586 0
 658 0558 014084E2 		add	r4, r4, #1
 659              	.LVL51:
 660              		.loc 1 589 0
 661 055c 0030CDE5 		strb	r3, [sp, #0]
 590:main.c        **** 			temp_buff[1] = 0;
 662              		.loc 1 590 0
 663 0560 0130CDE5 		strb	r3, [sp, #1]
 591:main.c        **** 			temp_buff[2] = 0;
 664              		.loc 1 591 0
 665 0564 0230CDE5 		strb	r3, [sp, #2]
 592:main.c        **** 			temp_buff[3] = 0;
 666              		.loc 1 592 0
 667 0568 0330CDE5 		strb	r3, [sp, #3]
 668 056c 070000EA 		b	.L38
 669              	.LVL52:
 670              	.L40:
 593:main.c        **** 
 594:main.c        **** 		}
 595:main.c        **** 
 596:main.c        **** 		else if(asc == 'N')
 671              		.loc 1 596 0
 672 0570 4E0053E3 		cmp	r3, #78
 673 0574 0500001A 		bne	.L38
 674              	.LVL53:
 597:main.c        **** 		{
 598:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 599:main.c        **** 			q[ind] = (char)a;
 675              		.loc 1 599 0
 676 0578 38208DE2 		add	r2, sp, #56
 677 057c 043082E0 		add	r3, r2, r4
 598:main.c        **** 			q[ind] = (char)a;
 678              		.loc 1 598 0
 679 0580 2024A0E1 		mov	r2, r0, lsr #8
 680              		.loc 1 599 0
 681 0584 342043E5 		strb	r2, [r3, #-52]
 600:main.c        **** 			
 601:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 682              		.loc 1 601 0
 683 0588 330043E5 		strb	r0, [r3, #-51]
 602:main.c        **** 			ind += 2;
 684              		.loc 1 602 0
 685 058c 024084E2 		add	r4, r4, #2
 686              	.LVL54:
 687              	.L38:
 603:main.c        **** 			temp = 0;
 604:main.c        **** 		}
 605:main.c        **** 	}
 606:main.c        **** 
 607:main.c        **** 	// ADC_4
 608:main.c        **** 	// Get AD0.4
 609:main.c        **** 	if(ad0_4 == 'Y')
 688              		.loc 1 609 0
 689 0590 40389FE5 		ldr	r3, .L152+4
 690 0594 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 691 0598 590053E3 		cmp	r3, #89
 692 059c 4800001A 		bne	.L47
 610:main.c        **** 	{
 611:main.c        **** 		AD0CR = 0x00020FF10; // AD0.4
 693              		.loc 1 611 0
 694 05a0 34389FE5 		ldr	r3, .L152+8
 695 05a4 44289FE5 		ldr	r2, .L152+28
 696 05a8 002083E5 		str	r2, [r3, #0]
 612:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 697              		.loc 1 612 0
 698 05ac 002093E5 		ldr	r2, [r3, #0]
 699 05b0 012482E3 		orr	r2, r2, #16777216
 700 05b4 002083E5 		str	r2, [r3, #0]
 701              	.L48:
 613:main.c        **** 		while((temp & 0x80000000) == 0)
 614:main.c        **** 		{
 615:main.c        **** 			temp = AD0DR;
 702              		.loc 1 615 0
 703 05b8 042093E5 		ldr	r2, [r3, #4]
 704              	.LVL55:
 613:main.c        **** 		while((temp & 0x80000000) == 0)
 705              		.loc 1 613 0
 706 05bc 000052E3 		cmp	r2, #0
 707 05c0 FCFFFFAA 		bge	.L48
 708              	.LVL56:
 616:main.c        **** 		}
 617:main.c        **** 		temp &= 0x0000FFC0;
 709              		.loc 1 617 0
 710 05c4 18089FE5 		ldr	r0, .L152+16
 618:main.c        **** 		temp2 = temp / 0x00000040;
 619:main.c        **** 
 620:main.c        **** 		AD0CR = 0x00000000;
 711              		.loc 1 620 0
 712 05c8 0C389FE5 		ldr	r3, .L152+8
 617:main.c        **** 		temp2 = temp / 0x00000040;
 713              		.loc 1 617 0
 714 05cc 000002E0 		and	r0, r2, r0
 715              	.LVL57:
 716              		.loc 1 620 0
 717 05d0 0020A0E3 		mov	r2, #0
 718 05d4 002083E5 		str	r2, [r3, #0]
 621:main.c        **** 
 622:main.c        **** 		if(asc == 'Y' || asc == ',')
 719              		.loc 1 622 0
 720 05d8 F8379FE5 		ldr	r3, .L152+4
 721 05dc 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 722 05e0 590053E3 		cmp	r3, #89
 723 05e4 2C005313 		cmpne	r3, #44
 618:main.c        **** 
 724              		.loc 1 618 0
 725 05e8 4003A0E1 		mov	r0, r0, asr #6
 726              	.LVL58:
 727              		.loc 1 622 0
 728 05ec 2C00001A 		bne	.L49
 623:main.c        **** 		{
 624:main.c        **** 			itoa(temp2, 10, temp_buff);
 729              		.loc 1 624 0
 730 05f0 0A10A0E3 		mov	r1, #10
 731 05f4 0D20A0E1 		mov	r2, sp
 732 05f8 FEFFFFEB 		bl	itoa
 733              	.LVL59:
 625:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 734              		.loc 1 625 0
 735 05fc 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 736 0600 302043E2 		sub	r2, r3, #48
 737 0604 090052E3 		cmp	r2, #9
 626:main.c        **** 			{
 627:main.c        **** 				q[ind] = temp_buff[0];
 738              		.loc 1 627 0
 739 0608 38108D92 		addls	r1, sp, #56
 740 060c 04208190 		addls	r2, r1, r4
 741 0610 34304295 		strlsb	r3, [r2, #-52]
 628:main.c        **** 				ind++;
 629:main.c        **** 			}
 630:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 742              		.loc 1 630 0
 743 0614 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 744 0618 302043E2 		sub	r2, r3, #48
 628:main.c        **** 				ind++;
 745              		.loc 1 628 0
 746 061c 01408492 		addls	r4, r4, #1
 747              	.LVL60:
 748              		.loc 1 630 0
 749 0620 090052E3 		cmp	r2, #9
 631:main.c        **** 			{
 632:main.c        **** 				q[ind] = temp_buff[1];
 750              		.loc 1 632 0
 751 0624 38108D92 		addls	r1, sp, #56
 752 0628 04208190 		addls	r2, r1, r4
 753 062c 34304295 		strlsb	r3, [r2, #-52]
 633:main.c        **** 				ind++;
 634:main.c        **** 			}
 635:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 754              		.loc 1 635 0
 755 0630 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 756 0634 302043E2 		sub	r2, r3, #48
 633:main.c        **** 				ind++;
 757              		.loc 1 633 0
 758 0638 01408492 		addls	r4, r4, #1
 759              	.LVL61:
 760              		.loc 1 635 0
 761 063c 090052E3 		cmp	r2, #9
 636:main.c        **** 			{
 637:main.c        **** 				q[ind] = temp_buff[2];
 762              		.loc 1 637 0
 763 0640 38108D92 		addls	r1, sp, #56
 764 0644 04208190 		addls	r2, r1, r4
 765 0648 34304295 		strlsb	r3, [r2, #-52]
 638:main.c        **** 				ind++;
 639:main.c        **** 			}
 640:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 766              		.loc 1 640 0
 767 064c 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 768 0650 302043E2 		sub	r2, r3, #48
 638:main.c        **** 				ind++;
 769              		.loc 1 638 0
 770 0654 01408492 		addls	r4, r4, #1
 771              	.LVL62:
 772              		.loc 1 640 0
 773 0658 090052E3 		cmp	r2, #9
 641:main.c        **** 			{
 642:main.c        **** 				q[ind] = temp_buff[3];
 774              		.loc 1 642 0
 775 065c 38108D92 		addls	r1, sp, #56
 776 0660 04208190 		addls	r2, r1, r4
 777 0664 34304295 		strlsb	r3, [r2, #-52]
 643:main.c        **** 				ind++;
 644:main.c        **** 			}
 645:main.c        **** 
 646:main.c        **** 			if(asc == ',')
 778              		.loc 1 646 0
 779 0668 68379FE5 		ldr	r3, .L152+4
 780 066c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 643:main.c        **** 				ind++;
 781              		.loc 1 643 0
 782 0670 01408492 		addls	r4, r4, #1
 783              	.LVL63:
 784 0674 38108DE2 		add	r1, sp, #56
 785              		.loc 1 646 0
 786 0678 2C0052E3 		cmp	r2, #44
 787 067c 043081E0 		add	r3, r1, r4
 647:main.c        **** 			{
 648:main.c        **** 				q[ind] = ',';
 649:main.c        **** 			}
 650:main.c        **** 			else
 651:main.c        **** 			{
 652:main.c        **** 				q[ind] = 0;
 788              		.loc 1 652 0
 789 0680 0020A013 		movne	r2, #0
 790 0684 342043E5 		strb	r2, [r3, #-52]
 653:main.c        **** 			}
 654:main.c        **** 			ind++;
 655:main.c        **** 			temp = 0; 
 656:main.c        **** 			temp2 = 0;
 657:main.c        **** 			temp_buff[0] = 0;
 791              		.loc 1 657 0
 792 0688 0030A0E3 		mov	r3, #0
 654:main.c        **** 			temp = 0; 
 793              		.loc 1 654 0
 794 068c 014084E2 		add	r4, r4, #1
 795              	.LVL64:
 796              		.loc 1 657 0
 797 0690 0030CDE5 		strb	r3, [sp, #0]
 658:main.c        **** 			temp_buff[1] = 0;
 798              		.loc 1 658 0
 799 0694 0130CDE5 		strb	r3, [sp, #1]
 659:main.c        **** 			temp_buff[2] = 0;
 800              		.loc 1 659 0
 801 0698 0230CDE5 		strb	r3, [sp, #2]
 660:main.c        **** 			temp_buff[3] = 0;
 802              		.loc 1 660 0
 803 069c 0330CDE5 		strb	r3, [sp, #3]
 804 06a0 070000EA 		b	.L47
 805              	.LVL65:
 806              	.L49:
 661:main.c        **** 
 662:main.c        **** 		}
 663:main.c        **** 
 664:main.c        **** 		else if(asc == 'N')
 807              		.loc 1 664 0
 808 06a4 4E0053E3 		cmp	r3, #78
 809 06a8 0500001A 		bne	.L47
 810              	.LVL66:
 665:main.c        **** 		{
 666:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 667:main.c        **** 			q[ind] = (char)a;
 811              		.loc 1 667 0
 812 06ac 38208DE2 		add	r2, sp, #56
 813 06b0 043082E0 		add	r3, r2, r4
 666:main.c        **** 			q[ind] = (char)a;
 814              		.loc 1 666 0
 815 06b4 2024A0E1 		mov	r2, r0, lsr #8
 816              		.loc 1 667 0
 817 06b8 342043E5 		strb	r2, [r3, #-52]
 668:main.c        **** 			
 669:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 818              		.loc 1 669 0
 819 06bc 330043E5 		strb	r0, [r3, #-51]
 670:main.c        **** 			ind += 2;
 820              		.loc 1 670 0
 821 06c0 024084E2 		add	r4, r4, #2
 822              	.LVL67:
 823              	.L47:
 671:main.c        **** 			temp = 0;
 672:main.c        **** 		}
 673:main.c        **** 	}
 674:main.c        **** 	// ADC_5
 675:main.c        **** 	// Get AD1.7
 676:main.c        **** 	if(ad1_7 == 'Y')
 824              		.loc 1 676 0
 825 06c4 0C379FE5 		ldr	r3, .L152+4
 826 06c8 0930D3E5 		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 827 06cc 590053E3 		cmp	r3, #89
 828 06d0 4800001A 		bne	.L56
 677:main.c        **** 	{
 678:main.c        **** 		AD1CR = 0x00020FF80; // AD1.7
 829              		.loc 1 678 0
 830 06d4 18379FE5 		ldr	r3, .L152+32
 831 06d8 18279FE5 		ldr	r2, .L152+36
 832 06dc 002083E5 		str	r2, [r3, #0]
 679:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 833              		.loc 1 679 0
 834 06e0 002093E5 		ldr	r2, [r3, #0]
 835 06e4 012482E3 		orr	r2, r2, #16777216
 836 06e8 002083E5 		str	r2, [r3, #0]
 837              	.L57:
 680:main.c        **** 		while((temp & 0x80000000) == 0)
 681:main.c        **** 		{
 682:main.c        **** 			temp = AD1DR;
 838              		.loc 1 682 0
 839 06ec 042093E5 		ldr	r2, [r3, #4]
 840              	.LVL68:
 680:main.c        **** 		while((temp & 0x80000000) == 0)
 841              		.loc 1 680 0
 842 06f0 000052E3 		cmp	r2, #0
 843 06f4 FCFFFFAA 		bge	.L57
 844              	.LVL69:
 683:main.c        **** 		}
 684:main.c        **** 		temp &= 0x0000FFC0;
 845              		.loc 1 684 0
 846 06f8 E4069FE5 		ldr	r0, .L152+16
 685:main.c        **** 		temp2 = temp / 0x00000040;
 686:main.c        **** 
 687:main.c        **** 		AD1CR = 0x00000000;
 847              		.loc 1 687 0
 848 06fc F0369FE5 		ldr	r3, .L152+32
 684:main.c        **** 		temp2 = temp / 0x00000040;
 849              		.loc 1 684 0
 850 0700 000002E0 		and	r0, r2, r0
 851              	.LVL70:
 852              		.loc 1 687 0
 853 0704 0020A0E3 		mov	r2, #0
 854 0708 002083E5 		str	r2, [r3, #0]
 688:main.c        **** 
 689:main.c        **** 		if(asc == 'Y' || asc == ',')
 855              		.loc 1 689 0
 856 070c C4369FE5 		ldr	r3, .L152+4
 857 0710 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 858 0714 590053E3 		cmp	r3, #89
 859 0718 2C005313 		cmpne	r3, #44
 685:main.c        **** 
 860              		.loc 1 685 0
 861 071c 4003A0E1 		mov	r0, r0, asr #6
 862              	.LVL71:
 863              		.loc 1 689 0
 864 0720 2C00001A 		bne	.L58
 690:main.c        **** 		{
 691:main.c        **** 			itoa(temp2, 10, temp_buff);
 865              		.loc 1 691 0
 866 0724 0A10A0E3 		mov	r1, #10
 867 0728 0D20A0E1 		mov	r2, sp
 868 072c FEFFFFEB 		bl	itoa
 869              	.LVL72:
 692:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 870              		.loc 1 692 0
 871 0730 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 872 0734 302043E2 		sub	r2, r3, #48
 873 0738 090052E3 		cmp	r2, #9
 693:main.c        **** 			{
 694:main.c        **** 				q[ind] = temp_buff[0];
 874              		.loc 1 694 0
 875 073c 38108D92 		addls	r1, sp, #56
 876 0740 04208190 		addls	r2, r1, r4
 877 0744 34304295 		strlsb	r3, [r2, #-52]
 695:main.c        **** 				ind++;
 696:main.c        **** 			}
 697:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 878              		.loc 1 697 0
 879 0748 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 880 074c 302043E2 		sub	r2, r3, #48
 695:main.c        **** 				ind++;
 881              		.loc 1 695 0
 882 0750 01408492 		addls	r4, r4, #1
 883              	.LVL73:
 884              		.loc 1 697 0
 885 0754 090052E3 		cmp	r2, #9
 698:main.c        **** 			{
 699:main.c        **** 				q[ind] = temp_buff[1];
 886              		.loc 1 699 0
 887 0758 38108D92 		addls	r1, sp, #56
 888 075c 04208190 		addls	r2, r1, r4
 889 0760 34304295 		strlsb	r3, [r2, #-52]
 700:main.c        **** 				ind++;
 701:main.c        **** 			}
 702:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 890              		.loc 1 702 0
 891 0764 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 892 0768 302043E2 		sub	r2, r3, #48
 700:main.c        **** 				ind++;
 893              		.loc 1 700 0
 894 076c 01408492 		addls	r4, r4, #1
 895              	.LVL74:
 896              		.loc 1 702 0
 897 0770 090052E3 		cmp	r2, #9
 703:main.c        **** 			{
 704:main.c        **** 				q[ind] = temp_buff[2];
 898              		.loc 1 704 0
 899 0774 38108D92 		addls	r1, sp, #56
 900 0778 04208190 		addls	r2, r1, r4
 901 077c 34304295 		strlsb	r3, [r2, #-52]
 705:main.c        **** 				ind++;
 706:main.c        **** 			}
 707:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 902              		.loc 1 707 0
 903 0780 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 904 0784 302043E2 		sub	r2, r3, #48
 705:main.c        **** 				ind++;
 905              		.loc 1 705 0
 906 0788 01408492 		addls	r4, r4, #1
 907              	.LVL75:
 908              		.loc 1 707 0
 909 078c 090052E3 		cmp	r2, #9
 708:main.c        **** 			{
 709:main.c        **** 				q[ind] = temp_buff[3];
 910              		.loc 1 709 0
 911 0790 38108D92 		addls	r1, sp, #56
 912 0794 04208190 		addls	r2, r1, r4
 913 0798 34304295 		strlsb	r3, [r2, #-52]
 710:main.c        **** 				ind++;
 711:main.c        **** 			}
 712:main.c        **** 
 713:main.c        **** 			if(asc == ',')
 914              		.loc 1 713 0
 915 079c 34369FE5 		ldr	r3, .L152+4
 916 07a0 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 710:main.c        **** 				ind++;
 917              		.loc 1 710 0
 918 07a4 01408492 		addls	r4, r4, #1
 919              	.LVL76:
 920 07a8 38108DE2 		add	r1, sp, #56
 921              		.loc 1 713 0
 922 07ac 2C0052E3 		cmp	r2, #44
 923 07b0 043081E0 		add	r3, r1, r4
 714:main.c        **** 			{
 715:main.c        **** 				q[ind] = ',';
 716:main.c        **** 			}
 717:main.c        **** 			else
 718:main.c        **** 			{
 719:main.c        **** 				q[ind] = 0;
 924              		.loc 1 719 0
 925 07b4 0020A013 		movne	r2, #0
 926 07b8 342043E5 		strb	r2, [r3, #-52]
 720:main.c        **** 			}
 721:main.c        **** 			ind++;
 722:main.c        **** 			temp = 0; 
 723:main.c        **** 			temp2 = 0;
 724:main.c        **** 			temp_buff[0] = 0;
 927              		.loc 1 724 0
 928 07bc 0030A0E3 		mov	r3, #0
 721:main.c        **** 			temp = 0; 
 929              		.loc 1 721 0
 930 07c0 014084E2 		add	r4, r4, #1
 931              	.LVL77:
 932              		.loc 1 724 0
 933 07c4 0030CDE5 		strb	r3, [sp, #0]
 725:main.c        **** 			temp_buff[1] = 0;
 934              		.loc 1 725 0
 935 07c8 0130CDE5 		strb	r3, [sp, #1]
 726:main.c        **** 			temp_buff[2] = 0;
 936              		.loc 1 726 0
 937 07cc 0230CDE5 		strb	r3, [sp, #2]
 727:main.c        **** 			temp_buff[3] = 0;
 938              		.loc 1 727 0
 939 07d0 0330CDE5 		strb	r3, [sp, #3]
 940 07d4 070000EA 		b	.L56
 941              	.LVL78:
 942              	.L58:
 728:main.c        **** 
 729:main.c        **** 		}
 730:main.c        **** 
 731:main.c        **** 		else if(asc == 'N')
 943              		.loc 1 731 0
 944 07d8 4E0053E3 		cmp	r3, #78
 945 07dc 0500001A 		bne	.L56
 946              	.LVL79:
 732:main.c        **** 		{
 733:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 734:main.c        **** 			q[ind] = (char)a;
 947              		.loc 1 734 0
 948 07e0 38208DE2 		add	r2, sp, #56
 949 07e4 043082E0 		add	r3, r2, r4
 733:main.c        **** 			q[ind] = (char)a;
 950              		.loc 1 733 0
 951 07e8 2024A0E1 		mov	r2, r0, lsr #8
 952              		.loc 1 734 0
 953 07ec 342043E5 		strb	r2, [r3, #-52]
 735:main.c        **** 			
 736:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 954              		.loc 1 736 0
 955 07f0 330043E5 		strb	r0, [r3, #-51]
 737:main.c        **** 			ind += 2;
 956              		.loc 1 737 0
 957 07f4 024084E2 		add	r4, r4, #2
 958              	.LVL80:
 959              	.L56:
 738:main.c        **** 			temp = 0;
 739:main.c        **** 		}
 740:main.c        **** 	}
 741:main.c        **** 	// ADC_6
 742:main.c        **** 	// Get AD1.6
 743:main.c        **** 	if(ad1_6 == 'Y')
 960              		.loc 1 743 0
 961 07f8 D8359FE5 		ldr	r3, .L152+4
 962 07fc 0A30D3E5 		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 963 0800 590053E3 		cmp	r3, #89
 964 0804 4800001A 		bne	.L65
 744:main.c        **** 	{
 745:main.c        **** 		AD1CR = 0x00020FF40; // AD1.3
 965              		.loc 1 745 0
 966 0808 E4359FE5 		ldr	r3, .L152+32
 967 080c E8259FE5 		ldr	r2, .L152+40
 968 0810 002083E5 		str	r2, [r3, #0]
 746:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 969              		.loc 1 746 0
 970 0814 002093E5 		ldr	r2, [r3, #0]
 971 0818 012482E3 		orr	r2, r2, #16777216
 972 081c 002083E5 		str	r2, [r3, #0]
 973              	.L66:
 747:main.c        **** 		while((temp & 0x80000000) == 0)
 748:main.c        **** 		{
 749:main.c        **** 			temp = AD1DR;
 974              		.loc 1 749 0
 975 0820 042093E5 		ldr	r2, [r3, #4]
 976              	.LVL81:
 747:main.c        **** 		while((temp & 0x80000000) == 0)
 977              		.loc 1 747 0
 978 0824 000052E3 		cmp	r2, #0
 979 0828 FCFFFFAA 		bge	.L66
 980              	.LVL82:
 750:main.c        **** 		}
 751:main.c        **** 		temp &= 0x0000FFC0;
 981              		.loc 1 751 0
 982 082c B0059FE5 		ldr	r0, .L152+16
 752:main.c        **** 		temp2 = temp / 0x00000040;
 753:main.c        **** 
 754:main.c        **** 		AD1CR = 0x00000000;
 983              		.loc 1 754 0
 984 0830 BC359FE5 		ldr	r3, .L152+32
 751:main.c        **** 		temp2 = temp / 0x00000040;
 985              		.loc 1 751 0
 986 0834 000002E0 		and	r0, r2, r0
 987              	.LVL83:
 988              		.loc 1 754 0
 989 0838 0020A0E3 		mov	r2, #0
 990 083c 002083E5 		str	r2, [r3, #0]
 755:main.c        **** 
 756:main.c        **** 		if(asc == 'Y' || asc == ',')
 991              		.loc 1 756 0
 992 0840 90359FE5 		ldr	r3, .L152+4
 993 0844 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 994 0848 590053E3 		cmp	r3, #89
 995 084c 2C005313 		cmpne	r3, #44
 752:main.c        **** 
 996              		.loc 1 752 0
 997 0850 4003A0E1 		mov	r0, r0, asr #6
 998              	.LVL84:
 999              		.loc 1 756 0
 1000 0854 2C00001A 		bne	.L67
 757:main.c        **** 		{
 758:main.c        **** 			itoa(temp2, 10, temp_buff);
 1001              		.loc 1 758 0
 1002 0858 0A10A0E3 		mov	r1, #10
 1003 085c 0D20A0E1 		mov	r2, sp
 1004 0860 FEFFFFEB 		bl	itoa
 1005              	.LVL85:
 759:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 1006              		.loc 1 759 0
 1007 0864 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1008 0868 302043E2 		sub	r2, r3, #48
 1009 086c 090052E3 		cmp	r2, #9
 760:main.c        **** 			{
 761:main.c        **** 				q[ind] = temp_buff[0];
 1010              		.loc 1 761 0
 1011 0870 38108D92 		addls	r1, sp, #56
 1012 0874 04208190 		addls	r2, r1, r4
 1013 0878 34304295 		strlsb	r3, [r2, #-52]
 762:main.c        **** 				ind++;
 763:main.c        **** 			}
 764:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 1014              		.loc 1 764 0
 1015 087c 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1016 0880 302043E2 		sub	r2, r3, #48
 762:main.c        **** 				ind++;
 1017              		.loc 1 762 0
 1018 0884 01408492 		addls	r4, r4, #1
 1019              	.LVL86:
 1020              		.loc 1 764 0
 1021 0888 090052E3 		cmp	r2, #9
 765:main.c        **** 			{
 766:main.c        **** 				q[ind] = temp_buff[1];
 1022              		.loc 1 766 0
 1023 088c 38108D92 		addls	r1, sp, #56
 1024 0890 04208190 		addls	r2, r1, r4
 1025 0894 34304295 		strlsb	r3, [r2, #-52]
 767:main.c        **** 				ind++;
 768:main.c        **** 			}
 769:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 1026              		.loc 1 769 0
 1027 0898 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1028 089c 302043E2 		sub	r2, r3, #48
 767:main.c        **** 				ind++;
 1029              		.loc 1 767 0
 1030 08a0 01408492 		addls	r4, r4, #1
 1031              	.LVL87:
 1032              		.loc 1 769 0
 1033 08a4 090052E3 		cmp	r2, #9
 770:main.c        **** 			{
 771:main.c        **** 				q[ind] = temp_buff[2];
 1034              		.loc 1 771 0
 1035 08a8 38108D92 		addls	r1, sp, #56
 1036 08ac 04208190 		addls	r2, r1, r4
 1037 08b0 34304295 		strlsb	r3, [r2, #-52]
 772:main.c        **** 				ind++;
 773:main.c        **** 			}
 774:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 1038              		.loc 1 774 0
 1039 08b4 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1040 08b8 302043E2 		sub	r2, r3, #48
 772:main.c        **** 				ind++;
 1041              		.loc 1 772 0
 1042 08bc 01408492 		addls	r4, r4, #1
 1043              	.LVL88:
 1044              		.loc 1 774 0
 1045 08c0 090052E3 		cmp	r2, #9
 775:main.c        **** 			{
 776:main.c        **** 				q[ind] = temp_buff[3];
 1046              		.loc 1 776 0
 1047 08c4 38108D92 		addls	r1, sp, #56
 1048 08c8 04208190 		addls	r2, r1, r4
 1049 08cc 34304295 		strlsb	r3, [r2, #-52]
 777:main.c        **** 				ind++;
 778:main.c        **** 			}
 779:main.c        **** 
 780:main.c        **** 			if(asc == ',')
 1050              		.loc 1 780 0
 1051 08d0 00359FE5 		ldr	r3, .L152+4
 1052 08d4 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 777:main.c        **** 				ind++;
 1053              		.loc 1 777 0
 1054 08d8 01408492 		addls	r4, r4, #1
 1055              	.LVL89:
 1056 08dc 38108DE2 		add	r1, sp, #56
 1057              		.loc 1 780 0
 1058 08e0 2C0052E3 		cmp	r2, #44
 1059 08e4 043081E0 		add	r3, r1, r4
 781:main.c        **** 			{
 782:main.c        **** 				q[ind] = ',';
 783:main.c        **** 			}
 784:main.c        **** 			else
 785:main.c        **** 			{
 786:main.c        **** 				q[ind] = 0;
 1060              		.loc 1 786 0
 1061 08e8 0020A013 		movne	r2, #0
 1062 08ec 342043E5 		strb	r2, [r3, #-52]
 787:main.c        **** 			}
 788:main.c        **** 			ind++;
 789:main.c        **** 			temp = 0; 
 790:main.c        **** 			temp2 = 0;
 791:main.c        **** 			temp_buff[0] = 0;
 1063              		.loc 1 791 0
 1064 08f0 0030A0E3 		mov	r3, #0
 788:main.c        **** 			temp = 0; 
 1065              		.loc 1 788 0
 1066 08f4 014084E2 		add	r4, r4, #1
 1067              	.LVL90:
 1068              		.loc 1 791 0
 1069 08f8 0030CDE5 		strb	r3, [sp, #0]
 792:main.c        **** 			temp_buff[1] = 0;
 1070              		.loc 1 792 0
 1071 08fc 0130CDE5 		strb	r3, [sp, #1]
 793:main.c        **** 			temp_buff[2] = 0;
 1072              		.loc 1 793 0
 1073 0900 0230CDE5 		strb	r3, [sp, #2]
 794:main.c        **** 			temp_buff[3] = 0;
 1074              		.loc 1 794 0
 1075 0904 0330CDE5 		strb	r3, [sp, #3]
 1076 0908 070000EA 		b	.L65
 1077              	.LVL91:
 1078              	.L67:
 795:main.c        **** 
 796:main.c        **** 		}
 797:main.c        **** 
 798:main.c        **** 		else if(asc == 'N')
 1079              		.loc 1 798 0
 1080 090c 4E0053E3 		cmp	r3, #78
 1081 0910 0500001A 		bne	.L65
 1082              	.LVL92:
 799:main.c        **** 		{
 800:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 801:main.c        **** 			q[ind] = (char)a;
 1083              		.loc 1 801 0
 1084 0914 38208DE2 		add	r2, sp, #56
 1085 0918 043082E0 		add	r3, r2, r4
 800:main.c        **** 			q[ind] = (char)a;
 1086              		.loc 1 800 0
 1087 091c 2024A0E1 		mov	r2, r0, lsr #8
 1088              		.loc 1 801 0
 1089 0920 342043E5 		strb	r2, [r3, #-52]
 802:main.c        **** 			
 803:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 1090              		.loc 1 803 0
 1091 0924 330043E5 		strb	r0, [r3, #-51]
 804:main.c        **** 			ind += 2;
 1092              		.loc 1 804 0
 1093 0928 024084E2 		add	r4, r4, #2
 1094              	.LVL93:
 1095              	.L65:
 805:main.c        **** 			temp = 0;
 806:main.c        **** 		}
 807:main.c        **** 	}
 808:main.c        **** 	// ADC_7
 809:main.c        **** 	// Get AD1.2
 810:main.c        **** 	if(ad1_2 == 'Y')
 1096              		.loc 1 810 0
 1097 092c A4349FE5 		ldr	r3, .L152+4
 1098 0930 0B30D3E5 		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 1099 0934 590053E3 		cmp	r3, #89
 1100 0938 4800001A 		bne	.L74
 811:main.c        **** 	{
 812:main.c        **** 		AD1CR = 0x00020FF04; // AD1.2
 1101              		.loc 1 812 0
 1102 093c B0349FE5 		ldr	r3, .L152+32
 1103 0940 A0249FE5 		ldr	r2, .L152+20
 1104 0944 002083E5 		str	r2, [r3, #0]
 813:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 1105              		.loc 1 813 0
 1106 0948 002093E5 		ldr	r2, [r3, #0]
 1107 094c 012482E3 		orr	r2, r2, #16777216
 1108 0950 002083E5 		str	r2, [r3, #0]
 1109              	.L75:
 814:main.c        **** 		while((temp & 0x80000000) == 0)
 815:main.c        **** 		{
 816:main.c        **** 			temp = AD1DR;
 1110              		.loc 1 816 0
 1111 0954 042093E5 		ldr	r2, [r3, #4]
 1112              	.LVL94:
 814:main.c        **** 		while((temp & 0x80000000) == 0)
 1113              		.loc 1 814 0
 1114 0958 000052E3 		cmp	r2, #0
 1115 095c FCFFFFAA 		bge	.L75
 1116              	.LVL95:
 817:main.c        **** 		}
 818:main.c        **** 		temp &= 0x0000FFC0;
 1117              		.loc 1 818 0
 1118 0960 7C049FE5 		ldr	r0, .L152+16
 819:main.c        **** 		temp2 = temp / 0x00000040;
 820:main.c        **** 
 821:main.c        **** 		AD1CR = 0x00000000;
 1119              		.loc 1 821 0
 1120 0964 88349FE5 		ldr	r3, .L152+32
 818:main.c        **** 		temp2 = temp / 0x00000040;
 1121              		.loc 1 818 0
 1122 0968 000002E0 		and	r0, r2, r0
 1123              	.LVL96:
 1124              		.loc 1 821 0
 1125 096c 0020A0E3 		mov	r2, #0
 1126 0970 002083E5 		str	r2, [r3, #0]
 822:main.c        **** 
 823:main.c        **** 		if(asc == 'Y' || asc == ',')
 1127              		.loc 1 823 0
 1128 0974 5C349FE5 		ldr	r3, .L152+4
 1129 0978 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1130 097c 590053E3 		cmp	r3, #89
 1131 0980 2C005313 		cmpne	r3, #44
 819:main.c        **** 
 1132              		.loc 1 819 0
 1133 0984 4003A0E1 		mov	r0, r0, asr #6
 1134              	.LVL97:
 1135              		.loc 1 823 0
 1136 0988 2C00001A 		bne	.L76
 824:main.c        **** 		{
 825:main.c        **** 			itoa(temp2, 10, temp_buff);
 1137              		.loc 1 825 0
 1138 098c 0A10A0E3 		mov	r1, #10
 1139 0990 0D20A0E1 		mov	r2, sp
 1140 0994 FEFFFFEB 		bl	itoa
 1141              	.LVL98:
 826:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 1142              		.loc 1 826 0
 1143 0998 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1144 099c 302043E2 		sub	r2, r3, #48
 1145 09a0 090052E3 		cmp	r2, #9
 827:main.c        **** 			{
 828:main.c        **** 				q[ind] = temp_buff[0];
 1146              		.loc 1 828 0
 1147 09a4 38108D92 		addls	r1, sp, #56
 1148 09a8 04208190 		addls	r2, r1, r4
 1149 09ac 34304295 		strlsb	r3, [r2, #-52]
 829:main.c        **** 				ind++;
 830:main.c        **** 			}
 831:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 1150              		.loc 1 831 0
 1151 09b0 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1152 09b4 302043E2 		sub	r2, r3, #48
 829:main.c        **** 				ind++;
 1153              		.loc 1 829 0
 1154 09b8 01408492 		addls	r4, r4, #1
 1155              	.LVL99:
 1156              		.loc 1 831 0
 1157 09bc 090052E3 		cmp	r2, #9
 832:main.c        **** 			{
 833:main.c        **** 				q[ind] = temp_buff[1];
 1158              		.loc 1 833 0
 1159 09c0 38108D92 		addls	r1, sp, #56
 1160 09c4 04208190 		addls	r2, r1, r4
 1161 09c8 34304295 		strlsb	r3, [r2, #-52]
 834:main.c        **** 				ind++;
 835:main.c        **** 			}
 836:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 1162              		.loc 1 836 0
 1163 09cc 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1164 09d0 302043E2 		sub	r2, r3, #48
 834:main.c        **** 				ind++;
 1165              		.loc 1 834 0
 1166 09d4 01408492 		addls	r4, r4, #1
 1167              	.LVL100:
 1168              		.loc 1 836 0
 1169 09d8 090052E3 		cmp	r2, #9
 837:main.c        **** 			{
 838:main.c        **** 				q[ind] = temp_buff[2];
 1170              		.loc 1 838 0
 1171 09dc 38108D92 		addls	r1, sp, #56
 1172 09e0 04208190 		addls	r2, r1, r4
 1173 09e4 34304295 		strlsb	r3, [r2, #-52]
 839:main.c        **** 				ind++;
 840:main.c        **** 			}
 841:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 1174              		.loc 1 841 0
 1175 09e8 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1176 09ec 302043E2 		sub	r2, r3, #48
 839:main.c        **** 				ind++;
 1177              		.loc 1 839 0
 1178 09f0 01408492 		addls	r4, r4, #1
 1179              	.LVL101:
 1180              		.loc 1 841 0
 1181 09f4 090052E3 		cmp	r2, #9
 842:main.c        **** 			{
 843:main.c        **** 				q[ind] = temp_buff[3];
 1182              		.loc 1 843 0
 1183 09f8 38108D92 		addls	r1, sp, #56
 1184 09fc 04208190 		addls	r2, r1, r4
 1185 0a00 34304295 		strlsb	r3, [r2, #-52]
 844:main.c        **** 				ind++;
 845:main.c        **** 			}
 846:main.c        **** 
 847:main.c        **** 			if(asc == ',')
 1186              		.loc 1 847 0
 1187 0a04 CC339FE5 		ldr	r3, .L152+4
 1188 0a08 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 844:main.c        **** 				ind++;
 1189              		.loc 1 844 0
 1190 0a0c 01408492 		addls	r4, r4, #1
 1191              	.LVL102:
 1192 0a10 38108DE2 		add	r1, sp, #56
 1193              		.loc 1 847 0
 1194 0a14 2C0052E3 		cmp	r2, #44
 1195 0a18 043081E0 		add	r3, r1, r4
 848:main.c        **** 			{
 849:main.c        **** 				q[ind] = ',';
 850:main.c        **** 			}
 851:main.c        **** 			else
 852:main.c        **** 			{
 853:main.c        **** 				q[ind] = 0;
 1196              		.loc 1 853 0
 1197 0a1c 0020A013 		movne	r2, #0
 1198 0a20 342043E5 		strb	r2, [r3, #-52]
 854:main.c        **** 			}
 855:main.c        **** 			ind++;
 856:main.c        **** 			temp = 0; 
 857:main.c        **** 			temp2 = 0;
 858:main.c        **** 			temp_buff[0] = 0;
 1199              		.loc 1 858 0
 1200 0a24 0030A0E3 		mov	r3, #0
 855:main.c        **** 			temp = 0; 
 1201              		.loc 1 855 0
 1202 0a28 014084E2 		add	r4, r4, #1
 1203              	.LVL103:
 1204              		.loc 1 858 0
 1205 0a2c 0030CDE5 		strb	r3, [sp, #0]
 859:main.c        **** 			temp_buff[1] = 0;
 1206              		.loc 1 859 0
 1207 0a30 0130CDE5 		strb	r3, [sp, #1]
 860:main.c        **** 			temp_buff[2] = 0;
 1208              		.loc 1 860 0
 1209 0a34 0230CDE5 		strb	r3, [sp, #2]
 861:main.c        **** 			temp_buff[3] = 0;
 1210              		.loc 1 861 0
 1211 0a38 0330CDE5 		strb	r3, [sp, #3]
 1212 0a3c 070000EA 		b	.L74
 1213              	.LVL104:
 1214              	.L76:
 862:main.c        **** 
 863:main.c        **** 		}
 864:main.c        **** 
 865:main.c        **** 		else if(asc == 'N')
 1215              		.loc 1 865 0
 1216 0a40 4E0053E3 		cmp	r3, #78
 1217 0a44 0500001A 		bne	.L74
 1218              	.LVL105:
 866:main.c        **** 		{
 867:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 868:main.c        **** 			q[ind] = (char)a;
 1219              		.loc 1 868 0
 1220 0a48 38208DE2 		add	r2, sp, #56
 1221 0a4c 043082E0 		add	r3, r2, r4
 867:main.c        **** 			q[ind] = (char)a;
 1222              		.loc 1 867 0
 1223 0a50 2024A0E1 		mov	r2, r0, lsr #8
 1224              		.loc 1 868 0
 1225 0a54 342043E5 		strb	r2, [r3, #-52]
 869:main.c        **** 			
 870:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 1226              		.loc 1 870 0
 1227 0a58 330043E5 		strb	r0, [r3, #-51]
 871:main.c        **** 			ind += 2;
 1228              		.loc 1 871 0
 1229 0a5c 024084E2 		add	r4, r4, #2
 1230              	.LVL106:
 1231              	.L74:
 872:main.c        **** 			temp = 0;
 873:main.c        **** 		}
 874:main.c        **** 	}
 875:main.c        **** 	// ADC_8
 876:main.c        **** 	// Get AD1.3
 877:main.c        **** 	if(ad1_3 == 'Y')
 1232              		.loc 1 877 0
 1233 0a60 70339FE5 		ldr	r3, .L152+4
 1234 0a64 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1235 0a68 590053E3 		cmp	r3, #89
 1236 0a6c 4800001A 		bne	.L83
 878:main.c        **** 	{
 879:main.c        **** 		AD1CR = 0x00020FF08; // AD1.3
 1237              		.loc 1 879 0
 1238 0a70 7C339FE5 		ldr	r3, .L152+32
 1239 0a74 64239FE5 		ldr	r2, .L152+12
 1240 0a78 002083E5 		str	r2, [r3, #0]
 880:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 1241              		.loc 1 880 0
 1242 0a7c 002093E5 		ldr	r2, [r3, #0]
 1243 0a80 012482E3 		orr	r2, r2, #16777216
 1244 0a84 002083E5 		str	r2, [r3, #0]
 1245              	.L84:
 881:main.c        **** 		while((temp & 0x80000000) == 0)
 882:main.c        **** 		{
 883:main.c        **** 			temp = AD1DR;
 1246              		.loc 1 883 0
 1247 0a88 042093E5 		ldr	r2, [r3, #4]
 1248              	.LVL107:
 881:main.c        **** 		while((temp & 0x80000000) == 0)
 1249              		.loc 1 881 0
 1250 0a8c 000052E3 		cmp	r2, #0
 1251 0a90 FCFFFFAA 		bge	.L84
 1252              	.LVL108:
 884:main.c        **** 		}
 885:main.c        **** 		temp &= 0x0000FFC0;
 1253              		.loc 1 885 0
 1254 0a94 48039FE5 		ldr	r0, .L152+16
 886:main.c        **** 		temp2 = temp / 0x00000040;
 887:main.c        **** 
 888:main.c        **** 		AD1CR = 0x00000000;
 1255              		.loc 1 888 0
 1256 0a98 54339FE5 		ldr	r3, .L152+32
 885:main.c        **** 		temp2 = temp / 0x00000040;
 1257              		.loc 1 885 0
 1258 0a9c 000002E0 		and	r0, r2, r0
 1259              	.LVL109:
 1260              		.loc 1 888 0
 1261 0aa0 0020A0E3 		mov	r2, #0
 1262 0aa4 002083E5 		str	r2, [r3, #0]
 889:main.c        **** 
 890:main.c        **** 		if(asc == 'Y' || asc == ',')
 1263              		.loc 1 890 0
 1264 0aa8 28339FE5 		ldr	r3, .L152+4
 1265 0aac 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1266 0ab0 590053E3 		cmp	r3, #89
 1267 0ab4 2C005313 		cmpne	r3, #44
 886:main.c        **** 
 1268              		.loc 1 886 0
 1269 0ab8 4003A0E1 		mov	r0, r0, asr #6
 1270              	.LVL110:
 1271              		.loc 1 890 0
 1272 0abc 2C00001A 		bne	.L85
 891:main.c        **** 		{
 892:main.c        **** 			itoa(temp2, 10, temp_buff);
 1273              		.loc 1 892 0
 1274 0ac0 0A10A0E3 		mov	r1, #10
 1275 0ac4 0D20A0E1 		mov	r2, sp
 1276 0ac8 FEFFFFEB 		bl	itoa
 1277              	.LVL111:
 893:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 1278              		.loc 1 893 0
 1279 0acc 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1280 0ad0 302043E2 		sub	r2, r3, #48
 1281 0ad4 090052E3 		cmp	r2, #9
 894:main.c        **** 			{
 895:main.c        **** 				q[ind] = temp_buff[0];
 1282              		.loc 1 895 0
 1283 0ad8 38108D92 		addls	r1, sp, #56
 1284 0adc 04208190 		addls	r2, r1, r4
 1285 0ae0 34304295 		strlsb	r3, [r2, #-52]
 896:main.c        **** 				ind++;
 897:main.c        **** 			}
 898:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 1286              		.loc 1 898 0
 1287 0ae4 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1288 0ae8 302043E2 		sub	r2, r3, #48
 896:main.c        **** 				ind++;
 1289              		.loc 1 896 0
 1290 0aec 01408492 		addls	r4, r4, #1
 1291              	.LVL112:
 1292              		.loc 1 898 0
 1293 0af0 090052E3 		cmp	r2, #9
 899:main.c        **** 			{
 900:main.c        **** 				q[ind] = temp_buff[1];
 1294              		.loc 1 900 0
 1295 0af4 38108D92 		addls	r1, sp, #56
 1296 0af8 04208190 		addls	r2, r1, r4
 1297 0afc 34304295 		strlsb	r3, [r2, #-52]
 901:main.c        **** 				ind++;
 902:main.c        **** 			}
 903:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 1298              		.loc 1 903 0
 1299 0b00 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1300 0b04 302043E2 		sub	r2, r3, #48
 901:main.c        **** 				ind++;
 1301              		.loc 1 901 0
 1302 0b08 01408492 		addls	r4, r4, #1
 1303              	.LVL113:
 1304              		.loc 1 903 0
 1305 0b0c 090052E3 		cmp	r2, #9
 904:main.c        **** 			{
 905:main.c        **** 				q[ind] = temp_buff[2];
 1306              		.loc 1 905 0
 1307 0b10 38108D92 		addls	r1, sp, #56
 1308 0b14 04208190 		addls	r2, r1, r4
 1309 0b18 34304295 		strlsb	r3, [r2, #-52]
 906:main.c        **** 				ind++;
 907:main.c        **** 			}
 908:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 1310              		.loc 1 908 0
 1311 0b1c 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1312 0b20 302043E2 		sub	r2, r3, #48
 906:main.c        **** 				ind++;
 1313              		.loc 1 906 0
 1314 0b24 01408492 		addls	r4, r4, #1
 1315              	.LVL114:
 1316              		.loc 1 908 0
 1317 0b28 090052E3 		cmp	r2, #9
 909:main.c        **** 			{
 910:main.c        **** 				q[ind] = temp_buff[3];
 1318              		.loc 1 910 0
 1319 0b2c 38108D92 		addls	r1, sp, #56
 1320 0b30 04208190 		addls	r2, r1, r4
 1321 0b34 34304295 		strlsb	r3, [r2, #-52]
 911:main.c        **** 				ind++;
 912:main.c        **** 			}
 913:main.c        **** 	
 914:main.c        **** 			if(asc == ',')
 1322              		.loc 1 914 0
 1323 0b38 98329FE5 		ldr	r3, .L152+4
 1324 0b3c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 911:main.c        **** 				ind++;
 1325              		.loc 1 911 0
 1326 0b40 01408492 		addls	r4, r4, #1
 1327              	.LVL115:
 1328 0b44 38108DE2 		add	r1, sp, #56
 1329              		.loc 1 914 0
 1330 0b48 2C0052E3 		cmp	r2, #44
 1331 0b4c 043081E0 		add	r3, r1, r4
 915:main.c        **** 			{
 916:main.c        **** 				q[ind] = ',';
 917:main.c        **** 			}
 918:main.c        **** 			else
 919:main.c        **** 			{
 920:main.c        **** 				q[ind] = 0;
 1332              		.loc 1 920 0
 1333 0b50 0020A013 		movne	r2, #0
 1334 0b54 342043E5 		strb	r2, [r3, #-52]
 921:main.c        **** 			}
 922:main.c        **** 			ind++;
 923:main.c        **** 			temp = 0; 
 924:main.c        **** 			temp2 = 0;
 925:main.c        **** 			temp_buff[0] = 0;
 1335              		.loc 1 925 0
 1336 0b58 0030A0E3 		mov	r3, #0
 922:main.c        **** 			temp = 0; 
 1337              		.loc 1 922 0
 1338 0b5c 014084E2 		add	r4, r4, #1
 1339              	.LVL116:
 1340              		.loc 1 925 0
 1341 0b60 0030CDE5 		strb	r3, [sp, #0]
 926:main.c        **** 			temp_buff[1] = 0;
 1342              		.loc 1 926 0
 1343 0b64 0130CDE5 		strb	r3, [sp, #1]
 927:main.c        **** 			temp_buff[2] = 0;
 1344              		.loc 1 927 0
 1345 0b68 0230CDE5 		strb	r3, [sp, #2]
 928:main.c        **** 			temp_buff[3] = 0;
 1346              		.loc 1 928 0
 1347 0b6c 0330CDE5 		strb	r3, [sp, #3]
 1348 0b70 070000EA 		b	.L83
 1349              	.LVL117:
 1350              	.L85:
 929:main.c        **** 
 930:main.c        **** 		}
 931:main.c        **** 
 932:main.c        **** 		else if(asc == 'N')
 1351              		.loc 1 932 0
 1352 0b74 4E0053E3 		cmp	r3, #78
 1353 0b78 0500001A 		bne	.L83
 1354              	.LVL118:
 933:main.c        **** 		{
 934:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 935:main.c        **** 			q[ind] = (char)a;
 1355              		.loc 1 935 0
 1356 0b7c 38208DE2 		add	r2, sp, #56
 1357 0b80 043082E0 		add	r3, r2, r4
 934:main.c        **** 			q[ind] = (char)a;
 1358              		.loc 1 934 0
 1359 0b84 2024A0E1 		mov	r2, r0, lsr #8
 1360              		.loc 1 935 0
 1361 0b88 342043E5 		strb	r2, [r3, #-52]
 936:main.c        **** 			
 937:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 1362              		.loc 1 937 0
 1363 0b8c 330043E5 		strb	r0, [r3, #-51]
 938:main.c        **** 			ind += 2;
 1364              		.loc 1 938 0
 1365 0b90 024084E2 		add	r4, r4, #2
 1366              	.LVL119:
 1367              	.L83:
 939:main.c        **** 			temp = 0;
 940:main.c        **** 		}
 941:main.c        **** 	}	
 942:main.c        **** 	if(asc == ',')	// remove final comma, replace with zero (NULL)
 1368              		.loc 1 942 0
 1369 0b94 3C329FE5 		ldr	r3, .L152+4
 1370 0b98 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1371 0b9c 2C0053E3 		cmp	r3, #44
 1372 0ba0 0400001A 		bne	.L92
 943:main.c        **** 	{
 944:main.c        **** 		if(ind > 0)	// sanity check, maybe no ADCs were marked to be read
 1373              		.loc 1 944 0
 1374 0ba4 000054E3 		cmp	r4, #0
 945:main.c        **** 		{
 946:main.c        **** 			q[ind-1] = 0;
 1375              		.loc 1 946 0
 1376 0ba8 38108D12 		addne	r1, sp, #56
 1377 0bac 04208110 		addne	r2, r1, r4
 1378 0bb0 0010A013 		movne	r1, #0
 1379 0bb4 35104215 		strneb	r1, [r2, #-53]
 1380              	.L92:
 1381 0bb8 40129FE5 		ldr	r1, .L152+44
 1382 0bbc 40729FE5 		ldr	r7, .L152+48
 1383 0bc0 B020D1E1 		ldrh	r2, [r1, #0]
 1384 0bc4 02C0D1E5 		ldrb	ip, [r1, #2]	@ zero_extendqisi2
 1385 0bc8 0300D1E5 		ldrb	r0, [r1, #3]	@ zero_extendqisi2
 947:main.c        **** 		}
 948:main.c        **** 	}
 949:main.c        **** 	
 950:main.c        **** 	for(j = 0; j < ind; j++)
 951:main.c        **** 	{
 952:main.c        **** 		if(RX_in < 512)
 953:main.c        **** 		{
 954:main.c        **** 			RX_array1[RX_in] = q[j];
 955:main.c        **** 			RX_in++;
 956:main.c        **** 
 957:main.c        **** 			if(RX_in == 512) log_array1 = 1;
 958:main.c        **** 		}
 959:main.c        **** 		else if(RX_in >= 512)
 960:main.c        **** 		{
 961:main.c        **** 			RX_array2[RX_in - 512] = q[j];
 1386              		.loc 1 961 0 discriminator 1
 1387 0bcc 34829FE5 		ldr	r8, .L152+52
 962:main.c        **** 			RX_in++;
 963:main.c        **** 
 964:main.c        **** 			if(RX_in == 1024)
 965:main.c        **** 			{
 966:main.c        **** 				log_array2 = 1;
 967:main.c        **** 				RX_in = 0;
 1388              		.loc 1 967 0 discriminator 1
 1389 0bd0 0010A0E3 		mov	r1, #0
 954:main.c        **** 			RX_in++;
 1390              		.loc 1 954 0 discriminator 1
 1391 0bd4 30A29FE5 		ldr	sl, .L152+56
 1392 0bd8 170000EA 		b	.L93
 1393              	.LVL120:
 1394              	.L97:
 952:main.c        **** 		{
 1395              		.loc 1 952 0
 1396 0bdc 0298A0E1 		mov	r9, r2, asl #16
 1397 0be0 4968A0E1 		mov	r6, r9, asr #16
 1398 0be4 070056E1 		cmp	r6, r7
 1399 0be8 04508DE2 		add	r5, sp, #4
 1400 0bec 070000CA 		bgt	.L94
 954:main.c        **** 			RX_in++;
 1401              		.loc 1 954 0
 1402 0bf0 0150D5E7 		ldrb	r5, [r5, r1]	@ zero_extendqisi2
 955:main.c        **** 
 1403              		.loc 1 955 0
 1404 0bf4 012082E2 		add	r2, r2, #1
 954:main.c        **** 			RX_in++;
 1405              		.loc 1 954 0
 1406 0bf8 4958CAE7 		strb	r5, [sl, r9, asr #16]
 955:main.c        **** 
 1407              		.loc 1 955 0
 1408 0bfc 0258A0E1 		mov	r5, r2, asl #16
 957:main.c        **** 		}
 1409              		.loc 1 957 0
 1410 0c00 020455E3 		cmp	r5, #33554432
 1411 0c04 2528A0E1 		mov	r2, r5, lsr #16
 1412 0c08 01C0A003 		moveq	ip, #1
 1413 0c0c 090000EA 		b	.L95
 1414              	.L94:
 961:main.c        **** 			RX_in++;
 1415              		.loc 1 961 0
 1416 0c10 0150D5E7 		ldrb	r5, [r5, r1]	@ zero_extendqisi2
 962:main.c        **** 
 1417              		.loc 1 962 0
 1418 0c14 012082E2 		add	r2, r2, #1
 1419 0c18 0228A0E1 		mov	r2, r2, asl #16
 961:main.c        **** 			RX_in++;
 1420              		.loc 1 961 0
 1421 0c1c 066088E0 		add	r6, r8, r6
 1422 0c20 005246E5 		strb	r5, [r6, #-512]
 964:main.c        **** 			{
 1423              		.loc 1 964 0
 1424 0c24 4258A0E1 		mov	r5, r2, asr #16
 966:main.c        **** 				RX_in = 0;
 1425              		.loc 1 966 0
 1426 0c28 010B55E3 		cmp	r5, #1024
 1427 0c2c 0100A003 		moveq	r0, #1
 1428 0c30 0020A003 		moveq	r2, #0
 1429 0c34 2228A011 		movne	r2, r2, lsr #16
 1430              	.L95:
 950:main.c        **** 	{
 1431              		.loc 1 950 0
 1432 0c38 011081E2 		add	r1, r1, #1
 1433              	.LVL121:
 1434              	.L93:
 950:main.c        **** 	{
 1435              		.loc 1 950 0 is_stmt 0 discriminator 1
 1436 0c3c 040051E1 		cmp	r1, r4
 1437 0c40 E5FFFFBA 		blt	.L97
 1438 0c44 B4119FE5 		ldr	r1, .L152+44
 1439              	.LVL122:
 1440 0c48 02C0C1E5 		strb	ip, [r1, #2]
 1441 0c4c 0300C1E5 		strb	r0, [r1, #3]
 968:main.c        **** 			}
 969:main.c        **** 		}
 970:main.c        **** 	}
 971:main.c        **** 	if(RX_in < 512)
 1442              		.loc 1 971 0 is_stmt 1
 1443 0c50 ACC19FE5 		ldr	ip, .L152+48
 1444 0c54 0208A0E1 		mov	r0, r2, asl #16
 1445 0c58 4018A0E1 		mov	r1, r0, asr #16
 1446 0c5c 0C0051E1 		cmp	r1, ip
 1447 0c60 110000CA 		bgt	.L98
 972:main.c        **** 	{
 973:main.c        **** 		if(asc == 'N') { RX_array1[RX_in] = '$'; }
 1448              		.loc 1 973 0
 1449 0c64 4E0053E3 		cmp	r3, #78
 1450 0c68 24C0A003 		moveq	ip, #36
 1451 0c6c 0300000A 		beq	.L148
 1452              	.L99:
 974:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array1[RX_in] = 13; }
 1453              		.loc 1 974 0
 1454 0c70 590053E3 		cmp	r3, #89
 1455 0c74 2C005313 		cmpne	r3, #44
 1456 0c78 0200001A 		bne	.L100
 1457              		.loc 1 974 0 is_stmt 0 discriminator 1
 1458 0c7c 0DC0A0E3 		mov	ip, #13
 1459              	.L148:
 1460 0c80 84119FE5 		ldr	r1, .L152+56
 1461 0c84 40C8C1E7 		strb	ip, [r1, r0, asr #16]
 1462              	.L100:
 975:main.c        **** 		RX_in++;
 1463              		.loc 1 975 0 is_stmt 1
 1464 0c88 012082E2 		add	r2, r2, #1
 1465 0c8c 0228A0E1 		mov	r2, r2, asl #16
 1466 0c90 2228A0E1 		mov	r2, r2, lsr #16
 1467 0c94 64119FE5 		ldr	r1, .L152+44
 976:main.c        **** 
 977:main.c        **** 		if(RX_in == 512) log_array1 = 1;
 1468              		.loc 1 977 0
 1469 0c98 020C52E3 		cmp	r2, #512
 975:main.c        **** 		RX_in++;
 1470              		.loc 1 975 0
 1471 0c9c B020C1E1 		strh	r2, [r1, #0]	@ movhi
 1472              		.loc 1 977 0
 1473 0ca0 0120A003 		moveq	r2, #1
 1474 0ca4 0220C105 		streqb	r2, [r1, #2]
 1475 0ca8 150000EA 		b	.L102
 1476              	.L98:
 978:main.c        **** 	}
 979:main.c        **** 	else if(RX_in >= 512)
 980:main.c        **** 	{
 981:main.c        **** 		
 982:main.c        **** 		if(asc == 'N') RX_array2[RX_in - 512] = '$';
 1477              		.loc 1 982 0
 1478 0cac 4E0053E3 		cmp	r3, #78
 1479              		.loc 1 982 0 is_stmt 0 discriminator 1
 1480 0cb0 50019F05 		ldreq	r0, .L152+52
 1481 0cb4 01108000 		addeq	r1, r0, r1
 1482 0cb8 2400A003 		moveq	r0, #36
 1483 0cbc 0500000A 		beq	.L149
 1484              	.L103:
 983:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array2[RX_in - 512] = 13; }
 1485              		.loc 1 983 0 is_stmt 1
 1486 0cc0 590053E3 		cmp	r3, #89
 1487 0cc4 2C005313 		cmpne	r3, #44
 1488 0cc8 0300001A 		bne	.L104
 1489              		.loc 1 983 0 is_stmt 0 discriminator 1
 1490 0ccc 34019FE5 		ldr	r0, .L152+52
 1491 0cd0 011080E0 		add	r1, r0, r1
 1492 0cd4 0D00A0E3 		mov	r0, #13
 1493              	.L149:
 1494 0cd8 000241E5 		strb	r0, [r1, #-512]
 1495              	.L104:
 984:main.c        **** 		RX_in++;
 1496              		.loc 1 984 0 is_stmt 1
 1497 0cdc 012082E2 		add	r2, r2, #1
 1498 0ce0 0228A0E1 		mov	r2, r2, asl #16
 1499 0ce4 2228A0E1 		mov	r2, r2, lsr #16
 1500 0ce8 10119FE5 		ldr	r1, .L152+44
 985:main.c        **** 		
 986:main.c        **** 		if(RX_in == 1024)
 1501              		.loc 1 986 0
 1502 0cec 010B52E3 		cmp	r2, #1024
 984:main.c        **** 		RX_in++;
 1503              		.loc 1 984 0
 1504 0cf0 B020C1E1 		strh	r2, [r1, #0]	@ movhi
 987:main.c        **** 		{
 988:main.c        **** 			log_array2 = 1;
 1505              		.loc 1 988 0
 1506 0cf4 0120A003 		moveq	r2, #1
 1507 0cf8 0320C105 		streqb	r2, [r1, #3]
 989:main.c        **** 			RX_in = 0;
 1508              		.loc 1 989 0
 1509 0cfc 0020A003 		moveq	r2, #0
 1510 0d00 B020C101 		streqh	r2, [r1, #0]	@ movhi
 1511              	.L102:
 990:main.c        **** 		}
 991:main.c        **** 	}
 992:main.c        **** 	if(RX_in < 512)
 1512              		.loc 1 992 0
 1513 0d04 F4209FE5 		ldr	r2, .L152+44
 1514 0d08 B020D2E1 		ldrh	r2, [r2, #0]
 1515 0d0c 0208A0E1 		mov	r0, r2, asl #16
 1516 0d10 4018A0E1 		mov	r1, r0, asr #16
 1517 0d14 020C51E3 		cmp	r1, #512
 1518 0d18 110000AA 		bge	.L106
 993:main.c        **** 	{
 994:main.c        **** 		if(asc == 'N') RX_array1[RX_in] = '$';
 1519              		.loc 1 994 0
 1520 0d1c 4E0053E3 		cmp	r3, #78
 1521 0d20 2410A003 		moveq	r1, #36
 1522 0d24 0300000A 		beq	.L150
 1523              	.L107:
 995:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array1[RX_in] = 10; }
 1524              		.loc 1 995 0
 1525 0d28 590053E3 		cmp	r3, #89
 1526 0d2c 2C005313 		cmpne	r3, #44
 1527 0d30 0200001A 		bne	.L108
 1528              		.loc 1 995 0 is_stmt 0 discriminator 1
 1529 0d34 0A10A0E3 		mov	r1, #10
 1530              	.L150:
 1531 0d38 CC309FE5 		ldr	r3, .L152+56
 1532 0d3c 4018C3E7 		strb	r1, [r3, r0, asr #16]
 1533              	.L108:
 996:main.c        **** 		RX_in++;
 1534              		.loc 1 996 0 is_stmt 1
 1535 0d40 012082E2 		add	r2, r2, #1
 1536 0d44 0228A0E1 		mov	r2, r2, asl #16
 1537 0d48 2228A0E1 		mov	r2, r2, lsr #16
 1538 0d4c AC309FE5 		ldr	r3, .L152+44
 997:main.c        **** 
 998:main.c        **** 		if(RX_in == 512) log_array1 = 1;
 1539              		.loc 1 998 0
 1540 0d50 020C52E3 		cmp	r2, #512
 996:main.c        **** 		RX_in++;
 1541              		.loc 1 996 0
 1542 0d54 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 1543              		.loc 1 998 0
 1544 0d58 0120A003 		moveq	r2, #1
 1545 0d5c 0220C305 		streqb	r2, [r3, #2]
 1546 0d60 150000EA 		b	.L110
 1547              	.L106:
 999:main.c        **** 	}
1000:main.c        **** 	else if(RX_in >= 512)
1001:main.c        **** 	{
1002:main.c        **** 		
1003:main.c        **** 		if(asc == 'N') RX_array2[RX_in - 512] = '$';
 1548              		.loc 1 1003 0
 1549 0d64 4E0053E3 		cmp	r3, #78
 1550              		.loc 1 1003 0 is_stmt 0 discriminator 1
 1551 0d68 98309F05 		ldreq	r3, .L152+52
 1552 0d6c 01108300 		addeq	r1, r3, r1
 1553 0d70 2430A003 		moveq	r3, #36
 1554 0d74 0500000A 		beq	.L151
 1555              	.L111:
1004:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array2[RX_in - 512] = 10; }
 1556              		.loc 1 1004 0 is_stmt 1
 1557 0d78 590053E3 		cmp	r3, #89
 1558 0d7c 2C005313 		cmpne	r3, #44
 1559 0d80 0300001A 		bne	.L112
 1560              		.loc 1 1004 0 is_stmt 0 discriminator 1
 1561 0d84 7C309FE5 		ldr	r3, .L152+52
 1562 0d88 011083E0 		add	r1, r3, r1
 1563 0d8c 0A30A0E3 		mov	r3, #10
 1564              	.L151:
 1565 0d90 003241E5 		strb	r3, [r1, #-512]
 1566              	.L112:
1005:main.c        **** 		RX_in++;
 1567              		.loc 1 1005 0 is_stmt 1
 1568 0d94 012082E2 		add	r2, r2, #1
 1569 0d98 0228A0E1 		mov	r2, r2, asl #16
 1570 0d9c 2228A0E1 		mov	r2, r2, lsr #16
 1571 0da0 58309FE5 		ldr	r3, .L152+44
1006:main.c        **** 		
1007:main.c        **** 		if(RX_in == 1024)
 1572              		.loc 1 1007 0
 1573 0da4 010B52E3 		cmp	r2, #1024
1005:main.c        **** 		RX_in++;
 1574              		.loc 1 1005 0
 1575 0da8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
1008:main.c        **** 		{
1009:main.c        **** 			log_array2 = 1;
 1576              		.loc 1 1009 0
 1577 0dac 0120A003 		moveq	r2, #1
 1578 0db0 0320C305 		streqb	r2, [r3, #3]
1010:main.c        **** 			RX_in = 0;
 1579              		.loc 1 1010 0
 1580 0db4 0020A003 		moveq	r2, #0
 1581 0db8 B020C301 		streqh	r2, [r3, #0]	@ movhi
 1582              	.L110:
1011:main.c        **** 		}
1012:main.c        **** 	}
1013:main.c        **** 
1014:main.c        **** 	VICVectAddr= 0;
 1583              		.loc 1 1014 0
 1584 0dbc 0020A0E3 		mov	r2, #0
 1585 0dc0 0030E0E3 		mvn	r3, #0
 1586 0dc4 CF2F03E5 		str	r2, [r3, #-4047]
1015:main.c        **** }
 1587              		.loc 1 1015 0
 1588 0dc8 38D08DE2 		add	sp, sp, #56
 1589 0dcc F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1590 0dd0 1EFF2FE1 		bx	lr
 1591              	.L153:
 1592              		.align	2
 1593              	.L152:
 1594 0dd4 004000E0 		.word	-536854528
 1595 0dd8 00000000 		.word	.LANCHOR1
 1596 0ddc 004003E0 		.word	-536657920
 1597 0de0 08FF2000 		.word	2162440
 1598 0de4 C0FF0000 		.word	65472
 1599 0de8 04FF2000 		.word	2162436
 1600 0dec 02FF2000 		.word	2162434
 1601 0df0 10FF2000 		.word	2162448
 1602 0df4 000006E0 		.word	-536477696
 1603 0df8 80FF2000 		.word	2162560
 1604 0dfc 40FF2000 		.word	2162496
 1605 0e00 00000000 		.word	.LANCHOR0
 1606 0e04 FF010000 		.word	511
 1607 0e08 00000000 		.word	RX_array2
 1608 0e0c 00000000 		.word	RX_array1
 1609              		.cfi_endproc
 1610              	.LFE5:
 1612              		.align	2
 1613              		.global	Initialize
 1615              	Initialize:
 1616              	.LFB1:
 289:main.c        **** 	rprintf_devopen(putc_serial0);
 1617              		.loc 1 289 0
 1618              		.cfi_startproc
 1619              		@ Function supports interworking.
 1620              		@ args = 0, pretend = 0, frame = 0
 1621              		@ frame_needed = 0, uses_anonymous_args = 0
 1622 0e10 04E02DE5 		str	lr, [sp, #-4]!
 1623              	.LCFI3:
 1624              		.cfi_def_cfa_offset 4
 1625              		.cfi_offset 14, -4
 290:main.c        **** 	
 1626              		.loc 1 290 0
 1627 0e14 4C009FE5 		ldr	r0, .L155
 1628 0e18 FEFFFFEB 		bl	rprintf_devopen
 1629              	.LVL123:
 292:main.c        **** 	PINSEL1 = 0x15441801;
 1630              		.loc 1 292 0
 1631 0e1c 48309FE5 		ldr	r3, .L155+4
 1632 0e20 48209FE5 		ldr	r2, .L155+8
 1633 0e24 002083E5 		str	r2, [r3, #0]
 293:main.c        **** 	IODIR0 |= 0x00000884;
 1634              		.loc 1 293 0
 1635 0e28 44209FE5 		ldr	r2, .L155+12
 1636 0e2c 042083E5 		str	r2, [r3, #4]
 294:main.c        **** 	IOSET0 = 0x00000080;
 1637              		.loc 1 294 0
 1638 0e30 013943E2 		sub	r3, r3, #16384
 1639 0e34 082093E5 		ldr	r2, [r3, #8]
 1640 0e38 222D82E3 		orr	r2, r2, #2176
 1641 0e3c 042082E3 		orr	r2, r2, #4
 1642 0e40 082083E5 		str	r2, [r3, #8]
 295:main.c        **** 
 1643              		.loc 1 295 0
 1644 0e44 8020A0E3 		mov	r2, #128
 1645 0e48 042083E5 		str	r2, [r3, #4]
 297:main.c        **** 	S0SPCR = 0x30;  // master, msb, first clk edge, active high, no ints
 1646              		.loc 1 297 0
 1647 0e4c 023943E2 		sub	r3, r3, #32768
 1648 0e50 0820A0E3 		mov	r2, #8
 1649 0e54 0020C3E5 		strb	r2, [r3, #0]
 298:main.c        **** 
 1650              		.loc 1 298 0
 1651 0e58 3020A0E3 		mov	r2, #48
 1652 0e5c 0020C3E5 		strb	r2, [r3, #0]
 300:main.c        **** 
 1653              		.loc 1 300 0
 1654 0e60 04E09DE4 		ldr	lr, [sp], #4
 1655 0e64 1EFF2FE1 		bx	lr
 1656              	.L156:
 1657              		.align	2
 1658              	.L155:
 1659 0e68 00000000 		.word	putc_serial0
 1660 0e6c 00C002E0 		.word	-536690688
 1661 0e70 051535CF 		.word	-818604795
 1662 0e74 01184415 		.word	356784129
 1663              		.cfi_endproc
 1664              	.LFE1:
 1666              		.align	2
 1667              		.global	feed
 1669              	feed:
 1670              	.LFB2:
 303:main.c        **** 	PLLFEED=0xAA;
 1671              		.loc 1 303 0
 1672              		.cfi_startproc
 1673              		@ Function supports interworking.
 1674              		@ args = 0, pretend = 0, frame = 0
 1675              		@ frame_needed = 0, uses_anonymous_args = 0
 1676              		@ link register save eliminated.
 304:main.c        **** 	PLLFEED=0x55;
 1677              		.loc 1 304 0
 1678 0e78 10309FE5 		ldr	r3, .L158
 1679 0e7c 5520E0E3 		mvn	r2, #85
 1680 0e80 8C20C3E5 		strb	r2, [r3, #140]
 305:main.c        **** }
 1681              		.loc 1 305 0
 1682 0e84 5520A0E3 		mov	r2, #85
 1683 0e88 8C20C3E5 		strb	r2, [r3, #140]
 1684 0e8c 1EFF2FE1 		bx	lr
 1685              	.L159:
 1686              		.align	2
 1687              	.L158:
 1688 0e90 00C01FE0 		.word	-534790144
 1689              		.cfi_endproc
 1690              	.LFE2:
 1692              		.align	2
 1693              		.global	FIQ_Routine
 1695              	FIQ_Routine:
 1696              	.LFB6:
1016:main.c        **** 
1017:main.c        **** void FIQ_Routine(void)
1018:main.c        **** {
 1697              		.loc 1 1018 0
 1698              		.cfi_startproc
 1699              		@ Fast Interrupt Service Routine.
 1700              		@ args = 0, pretend = 0, frame = 0
 1701              		@ frame_needed = 0, uses_anonymous_args = 0
 1702              		@ link register save eliminated.
 1703              	.LVL124:
 1704 0e94 0C002DE9 		stmfd	sp!, {r2, r3}
 1705              	.LCFI4:
 1706              		.cfi_def_cfa_offset 8
 1707              		.cfi_offset 2, -8
 1708              		.cfi_offset 3, -4
 1709              	.LBB10:
 1710              	.LBB11:
1019:main.c        **** 	char a;
1020:main.c        **** 	int j;
1021:main.c        **** 
1022:main.c        **** 	stat(0,ON);
1023:main.c        **** 	for(j = 0; j < 5000000; j++);
1024:main.c        **** 	stat(0,OFF);
1025:main.c        **** 	a = U0RBR;
1026:main.c        **** 
1027:main.c        **** 	a = U0IIR;  // have to read this to clear the interrupt
1028:main.c        **** }
1029:main.c        **** 
1030:main.c        **** void SWI_Routine(void)
1031:main.c        **** {
1032:main.c        **** 	while(1);
1033:main.c        **** }
1034:main.c        **** 
1035:main.c        **** void UNDEF_Routine(void)
1036:main.c        **** {
1037:main.c        **** 	stat(0,ON);
1038:main.c        **** }
1039:main.c        **** 
1040:main.c        **** void setup_uart0(int newbaud, char want_ints)
1041:main.c        **** {
1042:main.c        **** 	baud = newbaud;
1043:main.c        **** 	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
1044:main.c        **** 	
1045:main.c        **** 	if(baud == 1200)
1046:main.c        **** 	{
1047:main.c        **** 		U0DLM = 0x0C;
1048:main.c        **** 		U0DLL = 0x00;
1049:main.c        **** 	}
1050:main.c        **** 	else if(baud == 2400)
1051:main.c        **** 	{
1052:main.c        **** 		U0DLM = 0x06;
1053:main.c        **** 		U0DLL = 0x00;
1054:main.c        **** 	}
1055:main.c        **** 	else if(baud == 4800)
1056:main.c        **** 	{
1057:main.c        **** 		U0DLM = 0x03;
1058:main.c        **** 		U0DLL = 0x00;
1059:main.c        **** 	}
1060:main.c        **** 	else if(baud == 9600)
1061:main.c        **** 	{
1062:main.c        **** 		U0DLM = 0x01;
1063:main.c        **** 		U0DLL = 0x80;
1064:main.c        **** 	}
1065:main.c        **** 	else if(baud == 19200)
1066:main.c        **** 	{
1067:main.c        **** 		U0DLM = 0x00;
1068:main.c        **** 		U0DLL = 0xC0;
1069:main.c        **** 	}
1070:main.c        **** 	else if(baud == 38400)
1071:main.c        **** 	{
1072:main.c        **** 		U0DLM = 0x00;
1073:main.c        **** 		U0DLL = 0x60;
1074:main.c        **** 	}
1075:main.c        **** 	else if(baud == 57600)
1076:main.c        **** 	{
1077:main.c        **** 		U0DLM = 0x00;
1078:main.c        **** 		U0DLL = 0x40;
1079:main.c        **** 	}
1080:main.c        **** 	else if(baud == 115200)
1081:main.c        **** 	{
1082:main.c        **** 		U0DLM = 0x00;
1083:main.c        **** 		U0DLL = 0x20;
1084:main.c        **** 	}
1085:main.c        **** 
1086:main.c        **** 	U0FCR = 0x01;
1087:main.c        **** 	U0LCR = 0x03;   
1088:main.c        **** 
1089:main.c        **** 	if(want_ints == 1)
1090:main.c        **** 	{
1091:main.c        **** 		enableIRQ();
1092:main.c        **** 		VICIntSelect &= ~0x00000040;
1093:main.c        **** 		VICIntEnable |= 0x00000040;
1094:main.c        **** 		VICVectCntl1 = 0x26;
1095:main.c        **** 		VICVectAddr1 = (unsigned int)UART0ISR;
1096:main.c        **** 		U0IER = 0x01;
1097:main.c        **** 	}
1098:main.c        **** 	else if(want_ints == 2)
1099:main.c        **** 	{
1100:main.c        **** 		enableIRQ();
1101:main.c        **** 		VICIntSelect &= ~0x00000040;
1102:main.c        **** 		VICIntEnable |= 0x00000040;
1103:main.c        **** 		VICVectCntl2 = 0x26;
1104:main.c        **** 		VICVectAddr2 = (unsigned int)UART0ISR_2;
1105:main.c        **** 		U0IER = 0X01;
1106:main.c        **** 	}
1107:main.c        **** 	else if(want_ints == 0)
1108:main.c        **** 	{
1109:main.c        **** 		VICIntEnClr = 0x00000040;
1110:main.c        **** 		U0IER = 0x00;
1111:main.c        **** 	}
1112:main.c        **** }
1113:main.c        **** 
1114:main.c        **** void stat(int statnum, int onoff)
1115:main.c        **** {
1116:main.c        **** 	if(statnum) // Stat 1
1117:main.c        **** 	{
1118:main.c        **** 		if(onoff){ IOCLR0 = 0x00000800; } // On
1119:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
1120:main.c        **** 	}
1121:main.c        **** 	else // Stat 0 
1122:main.c        **** 	{
1123:main.c        **** 		if(onoff){ IOCLR0 = 0x00000004; } // On
 1711              		.loc 1 1123 0
 1712 0e98 1C309FE5 		ldr	r3, .L161
 1713 0e9c 0420A0E3 		mov	r2, #4
 1714 0ea0 0C2083E5 		str	r2, [r3, #12]
 1715              	.LVL125:
 1716              	.LBE11:
 1717              	.LBE10:
 1718              	.LBB12:
 1719              	.LBB13:
1124:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 1720              		.loc 1 1124 0
 1721 0ea4 042083E5 		str	r2, [r3, #4]
 1722              	.LBE13:
 1723              	.LBE12:
1025:main.c        **** 
 1724              		.loc 1 1025 0
 1725 0ea8 073943E2 		sub	r3, r3, #114688
 1726 0eac 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1727              	.LVL126:
1027:main.c        **** }
 1728              		.loc 1 1027 0
 1729 0eb0 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
1028:main.c        **** 
 1730              		.loc 1 1028 0
 1731 0eb4 0C00BDE8 		ldmfd	sp!, {r2, r3}
 1732 0eb8 04F05EE2 		subs	pc, lr, #4
 1733              	.L162:
 1734              		.align	2
 1735              	.L161:
 1736 0ebc 008002E0 		.word	-536707072
 1737              		.cfi_endproc
 1738              	.LFE6:
 1740              		.align	2
 1741              		.global	SWI_Routine
 1743              	SWI_Routine:
 1744              	.LFB7:
1031:main.c        **** 	while(1);
 1745              		.loc 1 1031 0
 1746              		.cfi_startproc
 1747              		@ ARM Exception Handler.
 1748              		@ Volatile: function does not return.
 1749              		@ args = 0, pretend = 0, frame = 0
 1750              		@ frame_needed = 0, uses_anonymous_args = 0
 1751              		@ link register save eliminated.
 1752              	.L164:
 1753 0ec0 FEFFFFEA 		b	.L164
 1754              		.cfi_endproc
 1755              	.LFE7:
 1757              		.align	2
 1758              		.global	UNDEF_Routine
 1760              	UNDEF_Routine:
 1761              	.LFB8:
1036:main.c        **** 	stat(0,ON);
 1762              		.loc 1 1036 0
 1763              		.cfi_startproc
 1764              		@ ARM Exception Handler.
 1765              		@ args = 0, pretend = 0, frame = 0
 1766              		@ frame_needed = 0, uses_anonymous_args = 0
 1767              		@ link register save eliminated.
 1768              	.LVL127:
1036:main.c        **** 	stat(0,ON);
 1769              		.loc 1 1036 0
 1770 0ec4 0C002DE9 		stmfd	sp!, {r2, r3}
 1771              	.LCFI5:
 1772              		.cfi_def_cfa_offset 8
 1773              		.cfi_offset 2, -8
 1774              		.cfi_offset 3, -4
 1775              	.LBB18:
 1776              	.LBB19:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 1777              		.loc 1 1123 0
 1778 0ec8 0C309FE5 		ldr	r3, .L166
 1779 0ecc 0420A0E3 		mov	r2, #4
 1780 0ed0 0C2083E5 		str	r2, [r3, #12]
 1781              	.LBE19:
 1782              	.LBE18:
1038:main.c        **** 
 1783              		.loc 1 1038 0
 1784 0ed4 0C00BDE8 		ldmfd	sp!, {r2, r3}
 1785 0ed8 0EF0B0E1 		movs	pc, lr
 1786              	.L167:
 1787              		.align	2
 1788              	.L166:
 1789 0edc 008002E0 		.word	-536707072
 1790              		.cfi_endproc
 1791              	.LFE8:
 1793              		.align	2
 1794              		.global	setup_uart0
 1796              	setup_uart0:
 1797              	.LFB9:
1041:main.c        **** 	baud = newbaud;
 1798              		.loc 1 1041 0
 1799              		.cfi_startproc
 1800              		@ Function supports interworking.
 1801              		@ args = 0, pretend = 0, frame = 0
 1802              		@ frame_needed = 0, uses_anonymous_args = 0
 1803              	.LVL128:
1042:main.c        **** 	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
 1804              		.loc 1 1042 0
 1805 0ee0 60319FE5 		ldr	r3, .L183
1041:main.c        **** 	baud = newbaud;
 1806              		.loc 1 1041 0
 1807 0ee4 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1808              	.LCFI6:
 1809              		.cfi_def_cfa_offset 16
 1810              		.cfi_offset 4, -16
 1811              		.cfi_offset 5, -12
 1812              		.cfi_offset 6, -8
 1813              		.cfi_offset 14, -4
1042:main.c        **** 	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
 1814              		.loc 1 1042 0
 1815 0ee8 100083E5 		str	r0, [r3, #16]
1043:main.c        **** 	
 1816              		.loc 1 1043 0
 1817 0eec 58319FE5 		ldr	r3, .L183+4
 1818 0ef0 7C20E0E3 		mvn	r2, #124
1045:main.c        **** 	{
 1819              		.loc 1 1045 0
 1820 0ef4 4B0E50E3 		cmp	r0, #1200
1043:main.c        **** 	
 1821              		.loc 1 1043 0
 1822 0ef8 0C20C3E5 		strb	r2, [r3, #12]
1041:main.c        **** 	baud = newbaud;
 1823              		.loc 1 1041 0
 1824 0efc FF4001E2 		and	r4, r1, #255
1047:main.c        **** 		U0DLL = 0x00;
 1825              		.loc 1 1047 0
 1826 0f00 0C20A003 		moveq	r2, #12
1045:main.c        **** 	{
 1827              		.loc 1 1045 0
 1828 0f04 0200000A 		beq	.L182
 1829              	.L169:
1050:main.c        **** 	{
 1830              		.loc 1 1050 0
 1831 0f08 960E50E3 		cmp	r0, #2400
 1832 0f0c 0300001A 		bne	.L171
1052:main.c        **** 		U0DLL = 0x00;
 1833              		.loc 1 1052 0
 1834 0f10 0620A0E3 		mov	r2, #6
 1835              	.L182:
 1836 0f14 0420C3E5 		strb	r2, [r3, #4]
1053:main.c        **** 	}
 1837              		.loc 1 1053 0
 1838 0f18 0020A0E3 		mov	r2, #0
 1839 0f1c 1C0000EA 		b	.L180
 1840              	.L171:
1055:main.c        **** 	{
 1841              		.loc 1 1055 0
 1842 0f20 4B0D50E3 		cmp	r0, #4800
1057:main.c        **** 		U0DLL = 0x00;
 1843              		.loc 1 1057 0
 1844 0f24 0320A003 		moveq	r2, #3
1055:main.c        **** 	{
 1845              		.loc 1 1055 0
 1846 0f28 F9FFFF0A 		beq	.L182
 1847              	.L172:
1060:main.c        **** 	{
 1848              		.loc 1 1060 0
 1849 0f2c 960D50E3 		cmp	r0, #9600
1062:main.c        **** 		U0DLL = 0x80;
 1850              		.loc 1 1062 0
 1851 0f30 0120A003 		moveq	r2, #1
 1852 0f34 0420C305 		streqb	r2, [r3, #4]
1063:main.c        **** 	}
 1853              		.loc 1 1063 0
 1854 0f38 7F20E003 		mvneq	r2, #127
1060:main.c        **** 	{
 1855              		.loc 1 1060 0
 1856 0f3c 1400000A 		beq	.L180
 1857              	.L173:
1065:main.c        **** 	{
 1858              		.loc 1 1065 0
 1859 0f40 4B0C50E3 		cmp	r0, #19200
1067:main.c        **** 		U0DLL = 0xC0;
 1860              		.loc 1 1067 0
 1861 0f44 0020A003 		moveq	r2, #0
 1862 0f48 0420C305 		streqb	r2, [r3, #4]
1068:main.c        **** 	}
 1863              		.loc 1 1068 0
 1864 0f4c 3F20E003 		mvneq	r2, #63
1065:main.c        **** 	{
 1865              		.loc 1 1065 0
 1866 0f50 0F00000A 		beq	.L180
 1867              	.L174:
1070:main.c        **** 	{
 1868              		.loc 1 1070 0
 1869 0f54 960C50E3 		cmp	r0, #38400
1072:main.c        **** 		U0DLL = 0x60;
 1870              		.loc 1 1072 0
 1871 0f58 0020A003 		moveq	r2, #0
 1872 0f5c 0420C305 		streqb	r2, [r3, #4]
1073:main.c        **** 	}
 1873              		.loc 1 1073 0
 1874 0f60 6020A003 		moveq	r2, #96
1070:main.c        **** 	{
 1875              		.loc 1 1070 0
 1876 0f64 0A00000A 		beq	.L180
 1877              	.L175:
1075:main.c        **** 	{
 1878              		.loc 1 1075 0
 1879 0f68 E10C50E3 		cmp	r0, #57600
1077:main.c        **** 		U0DLL = 0x40;
 1880              		.loc 1 1077 0
 1881 0f6c 0020A003 		moveq	r2, #0
 1882 0f70 0420C305 		streqb	r2, [r3, #4]
1078:main.c        **** 	}
 1883              		.loc 1 1078 0
 1884 0f74 4020A003 		moveq	r2, #64
1075:main.c        **** 	{
 1885              		.loc 1 1075 0
 1886 0f78 0500000A 		beq	.L180
 1887              	.L176:
1080:main.c        **** 	{
 1888              		.loc 1 1080 0
 1889 0f7c CC209FE5 		ldr	r2, .L183+8
 1890 0f80 020050E1 		cmp	r0, r2
 1891 0f84 0300001A 		bne	.L170
1082:main.c        **** 		U0DLL = 0x20;
 1892              		.loc 1 1082 0
 1893 0f88 0020A0E3 		mov	r2, #0
 1894 0f8c 0420C3E5 		strb	r2, [r3, #4]
1083:main.c        **** 	}
 1895              		.loc 1 1083 0
 1896 0f90 2020A0E3 		mov	r2, #32
 1897              	.L180:
 1898 0f94 0020C3E5 		strb	r2, [r3, #0]
 1899              	.L170:
1086:main.c        **** 	U0LCR = 0x03;   
 1900              		.loc 1 1086 0
 1901 0f98 0160A0E3 		mov	r6, #1
1087:main.c        **** 
 1902              		.loc 1 1087 0
 1903 0f9c 0320A0E3 		mov	r2, #3
1089:main.c        **** 	{
 1904              		.loc 1 1089 0
 1905 0fa0 060054E1 		cmp	r4, r6
1086:main.c        **** 	U0LCR = 0x03;   
 1906              		.loc 1 1086 0
 1907 0fa4 0860C3E5 		strb	r6, [r3, #8]
 1908 0fa8 9C509FE5 		ldr	r5, .L183+4
1087:main.c        **** 
 1909              		.loc 1 1087 0
 1910 0fac 0C20C3E5 		strb	r2, [r3, #12]
1089:main.c        **** 	{
 1911              		.loc 1 1089 0
 1912 0fb0 0C00001A 		bne	.L177
1091:main.c        **** 		VICIntSelect &= ~0x00000040;
 1913              		.loc 1 1091 0
 1914 0fb4 FEFFFFEB 		bl	enableIRQ
 1915              	.LVL129:
1092:main.c        **** 		VICIntEnable |= 0x00000040;
 1916              		.loc 1 1092 0
 1917 0fb8 0030E0E3 		mvn	r3, #0
 1918 0fbc F32F13E5 		ldr	r2, [r3, #-4083]
 1919 0fc0 4020C2E3 		bic	r2, r2, #64
 1920 0fc4 F32F03E5 		str	r2, [r3, #-4083]
1093:main.c        **** 		VICVectCntl1 = 0x26;
 1921              		.loc 1 1093 0
 1922 0fc8 EF2F13E5 		ldr	r2, [r3, #-4079]
 1923 0fcc 402082E3 		orr	r2, r2, #64
 1924 0fd0 EF2F03E5 		str	r2, [r3, #-4079]
1094:main.c        **** 		VICVectAddr1 = (unsigned int)UART0ISR;
 1925              		.loc 1 1094 0
 1926 0fd4 2620A0E3 		mov	r2, #38
 1927 0fd8 FB2D03E5 		str	r2, [r3, #-3579]
1095:main.c        **** 		U0IER = 0x01;
 1928              		.loc 1 1095 0
 1929 0fdc 70209FE5 		ldr	r2, .L183+12
 1930 0fe0 FB2E03E5 		str	r2, [r3, #-3835]
 1931 0fe4 140000EA 		b	.L181
 1932              	.LVL130:
 1933              	.L177:
1098:main.c        **** 	{
 1934              		.loc 1 1098 0
 1935 0fe8 020054E3 		cmp	r4, #2
 1936 0fec 0D00001A 		bne	.L179
1100:main.c        **** 		VICIntSelect &= ~0x00000040;
 1937              		.loc 1 1100 0
 1938 0ff0 FEFFFFEB 		bl	enableIRQ
 1939              	.LVL131:
1101:main.c        **** 		VICIntEnable |= 0x00000040;
 1940              		.loc 1 1101 0
 1941 0ff4 0030E0E3 		mvn	r3, #0
 1942 0ff8 F32F13E5 		ldr	r2, [r3, #-4083]
 1943 0ffc 4020C2E3 		bic	r2, r2, #64
 1944 1000 F32F03E5 		str	r2, [r3, #-4083]
1102:main.c        **** 		VICVectCntl2 = 0x26;
 1945              		.loc 1 1102 0
 1946 1004 EF2F13E5 		ldr	r2, [r3, #-4079]
 1947 1008 402082E3 		orr	r2, r2, #64
 1948 100c EF2F03E5 		str	r2, [r3, #-4079]
1103:main.c        **** 		VICVectAddr2 = (unsigned int)UART0ISR_2;
 1949              		.loc 1 1103 0
 1950 1010 2620A0E3 		mov	r2, #38
 1951 1014 F72D03E5 		str	r2, [r3, #-3575]
1104:main.c        **** 		U0IER = 0X01;
 1952              		.loc 1 1104 0
 1953 1018 38209FE5 		ldr	r2, .L183+16
 1954 101c F72E03E5 		str	r2, [r3, #-3831]
1105:main.c        **** 	}
 1955              		.loc 1 1105 0
 1956 1020 0460C5E5 		strb	r6, [r5, #4]
 1957 1024 050000EA 		b	.L168
 1958              	.LVL132:
 1959              	.L179:
1107:main.c        **** 	{
 1960              		.loc 1 1107 0
 1961 1028 000054E3 		cmp	r4, #0
 1962 102c 0300001A 		bne	.L168
1109:main.c        **** 		U0IER = 0x00;
 1963              		.loc 1 1109 0
 1964 1030 4020A0E3 		mov	r2, #64
 1965 1034 0030E0E3 		mvn	r3, #0
 1966 1038 EB2F03E5 		str	r2, [r3, #-4075]
 1967              	.LVL133:
 1968              	.L181:
1110:main.c        **** 	}
 1969              		.loc 1 1110 0
 1970 103c 0440C5E5 		strb	r4, [r5, #4]
 1971              	.L168:
1112:main.c        **** 
 1972              		.loc 1 1112 0
 1973 1040 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1974 1044 1EFF2FE1 		bx	lr
 1975              	.L184:
 1976              		.align	2
 1977              	.L183:
 1978 1048 00000000 		.word	.LANCHOR1
 1979 104c 00C000E0 		.word	-536821760
 1980 1050 00C20100 		.word	115200
 1981 1054 00000000 		.word	UART0ISR
 1982 1058 00000000 		.word	UART0ISR_2
 1983              		.cfi_endproc
 1984              	.LFE9:
 1986              		.align	2
 1987              		.global	stat
 1989              	stat:
 1990              	.LFB10:
1115:main.c        **** 	if(statnum) // Stat 1
 1991              		.loc 1 1115 0
 1992              		.cfi_startproc
 1993              		@ Function supports interworking.
 1994              		@ args = 0, pretend = 0, frame = 0
 1995              		@ frame_needed = 0, uses_anonymous_args = 0
 1996              		@ link register save eliminated.
 1997              	.LVL134:
1116:main.c        **** 	{
 1998              		.loc 1 1116 0
 1999 105c 000050E3 		cmp	r0, #0
 2000 1060 20309FE5 		ldr	r3, .L193
 2001 1064 0200000A 		beq	.L186
 2002              	.LVL135:
 2003              	.LBB22:
 2004              	.LBB23:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 2005              		.loc 1 1118 0
 2006 1068 000051E3 		cmp	r1, #0
 2007 106c 022BA0E3 		mov	r2, #2048
 2008 1070 010000EA 		b	.L192
 2009              	.LVL136:
 2010              	.L186:
 2011              	.LBE23:
 2012              	.LBE22:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 2013              		.loc 1 1123 0
 2014 1074 000051E3 		cmp	r1, #0
 2015 1078 0420A0E3 		mov	r2, #4
 2016              	.L192:
 2017 107c 0C208315 		strne	r2, [r3, #12]
 2018              		.loc 1 1124 0
 2019 1080 04208305 		streq	r2, [r3, #4]
 2020 1084 1EFF2FE1 		bx	lr
 2021              	.L194:
 2022              		.align	2
 2023              	.L193:
 2024 1088 008002E0 		.word	-536707072
 2025              		.cfi_endproc
 2026              	.LFE10:
 2028              		.align	2
 2029              		.global	AD_conversion
 2031              	AD_conversion:
 2032              	.LFB18:
1125:main.c        **** 	}
1126:main.c        **** }
1127:main.c        **** 
1128:main.c        **** void Log_init(void)
1129:main.c        **** {
1130:main.c        **** 	int x, mark = 0, ind = 0;
1131:main.c        **** 	char temp, temp2 = 0, safety = 0;
1132:main.c        **** //	signed char handle;
1133:main.c        **** 
1134:main.c        **** 	if(root_file_exists("LOGCON.txt"))
1135:main.c        **** 	{
1136:main.c        **** 		//rprintf("\n\rFound LOGcon.txt\n");
1137:main.c        **** 		fd = root_open("LOGCON.txt");
1138:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
1139:main.c        **** 		stringBuf[stringSize] = '\0';
1140:main.c        **** 		fat_close_file(fd);
1141:main.c        **** 	}
1142:main.c        **** 	else
1143:main.c        **** 	{
1144:main.c        **** 		//rprintf("Couldn't find LOGcon.txt, creating...\n");
1145:main.c        **** 		fd = root_open_new("LOGCON.txt");
1146:main.c        **** 		if(fd == NULL)
1147:main.c        **** 		{
1148:main.c        **** 		 	rprintf("Error creating LOGCON.txt, locking up...\n\r");
1149:main.c        **** 		 	while(1)
1150:main.c        **** 			{
1151:main.c        **** 				stat(0,ON);
1152:main.c        **** 				delay_ms(50);
1153:main.c        **** 				stat(0,OFF);
1154:main.c        **** 				stat(1,ON);
1155:main.c        **** 				delay_ms(50);
1156:main.c        **** 				stat(1,OFF);
1157:main.c        **** 			}
1158:main.c        **** 		}
1159:main.c        **** 
1160:main.c        **** 		strcpy(stringBuf, "MODE = 0\r\nASCII = N\r\nBaud = 4\r\nFrequency = 100\r\nTrigger Character = $\
1161:main.c        **** 		stringSize = strlen(stringBuf);
1162:main.c        **** 		fat_write_file(fd, (unsigned char*)stringBuf, stringSize);
1163:main.c        **** 		sd_raw_sync();
1164:main.c        **** 	}
1165:main.c        **** 
1166:main.c        **** 	for(x = 0; x < stringSize; x++)
1167:main.c        **** 	{
1168:main.c        **** 		temp = stringBuf[x];
1169:main.c        **** 		if(temp == 10)
1170:main.c        **** 		{
1171:main.c        **** 			mark = x;
1172:main.c        **** 			ind++;
1173:main.c        **** 			if(ind == 1)
1174:main.c        **** 			{
1175:main.c        **** 				// 0 = auto uart, 1 = triggered uart, 2 = adc, 3 = triggered uart + adc
1176:main.c        **** 				// default = 0 (auto uart)
1177:main.c        **** 				mode = stringBuf[mark-2]-48;
1178:main.c        **** 				rprintf("mode = %d\n\r",mode);
1179:main.c        **** 			}
1180:main.c        **** 			else if(ind == 2)
1181:main.c        **** 			{
1182:main.c        **** 				// N = NO, Y = YES, ',' = YES with comma delimiters
1183:main.c        **** 				asc = stringBuf[mark-2]; // default is 'N'
1184:main.c        **** 				rprintf("asc = %c\n\r",asc);
1185:main.c        **** 			}
1186:main.c        **** 			else if(ind == 3)
1187:main.c        **** 			{
1188:main.c        **** 				// default is 9600
1189:main.c        **** 				if(stringBuf[mark-2] == '1'){ baud = 1200; }
1190:main.c        **** 				else if(stringBuf[mark-2] == '2'){ baud = 2400; }
1191:main.c        **** 				else if(stringBuf[mark-2] == '3'){ baud = 4800; }
1192:main.c        **** 				else if(stringBuf[mark-2] == '4'){ baud = 9600; }
1193:main.c        **** 				else if(stringBuf[mark-2] == '5'){ baud = 19200; }
1194:main.c        **** 				else if(stringBuf[mark-2] == '6'){ baud = 38400; }
1195:main.c        **** 				else if(stringBuf[mark-2] == '7'){ baud = 57600; }
1196:main.c        **** 				else if(stringBuf[mark-2] == '8'){ baud = 115200; }
1197:main.c        **** 
1198:main.c        **** 				rprintf("baud = %d\n\r",baud);
1199:main.c        **** 			}
1200:main.c        **** 			else if(ind == 4)
1201:main.c        **** 			{
1202:main.c        **** 				freq = (stringBuf[mark-2]-48) + (stringBuf[mark-3]-48) * 10;
1203:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
1204:main.c        **** 				{
1205:main.c        **** 					freq+= (stringBuf[mark-4]-48) * 100;
1206:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
1207:main.c        **** 				}
1208:main.c        **** 				rprintf("freq = %d\n\r",freq);
1209:main.c        **** 			}
1210:main.c        **** 			else if(ind == 5)
1211:main.c        **** 			{
1212:main.c        **** 				trig = stringBuf[mark-2]; // default is $
1213:main.c        **** 				
1214:main.c        **** 				rprintf("trig = %c\n\r",trig);
1215:main.c        **** 			}
1216:main.c        **** 			else if(ind == 6)
1217:main.c        **** 			{
1218:main.c        **** 				frame = (stringBuf[mark-2]-48) + (stringBuf[mark-3]-48) * 10 + (stringBuf[mark-4]-48)*100;
1219:main.c        **** 				if(frame > 510){ frame = 510; } // up to 510 characters
1220:main.c        **** 				rprintf("frame = %d\n\r",frame);
1221:main.c        **** 			}
1222:main.c        **** 			else if(ind == 7)	// AD1 - 0.3
1223:main.c        **** 			{
1224:main.c        **** 				ad0_3 = stringBuf[mark-2]; // default is 'N'
1225:main.c        **** 				if(ad0_3 == 'Y'){ temp2++; }
1226:main.c        **** 				rprintf("ad0_3 = %c\n\r",ad0_3);
1227:main.c        **** 			}
1228:main.c        **** 			else if(ind == 8)	// AD2 - 0.2
1229:main.c        **** 			{
1230:main.c        **** 				ad0_2 = stringBuf[mark-2]; // default is 'N'
1231:main.c        **** 				if(ad0_2 == 'Y'){ temp2++; }
1232:main.c        **** 				rprintf("ad0_2 = %c\n\r",ad0_2);
1233:main.c        **** 			}
1234:main.c        **** 			else if(ind == 9)	// AD3 - 0.1
1235:main.c        **** 			{
1236:main.c        **** 				ad0_1 = stringBuf[mark-2]; // default is 'N'
1237:main.c        **** 				if(ad0_1 == 'Y'){ temp2++; }
1238:main.c        **** 				rprintf("ad0_1 = %c\n\r",ad0_1);
1239:main.c        **** 			}
1240:main.c        **** 			else if(ind == 10)	//AD4 - 0.4
1241:main.c        **** 			{
1242:main.c        **** 				ad0_4 = stringBuf[mark-2]; // default is 'N'
1243:main.c        **** 				if(ad0_4 == 'Y'){ temp2++; }
1244:main.c        **** 				rprintf("ad0_4 = %c\n\r",ad0_4);
1245:main.c        **** 			}
1246:main.c        **** 			else if(ind == 11)	//AD5 - 1.7
1247:main.c        **** 			{
1248:main.c        **** 				ad1_7 = stringBuf[mark-2]; // default is 'N'
1249:main.c        **** 				if(ad1_7 == 'Y'){ temp2++; }
1250:main.c        **** 				rprintf("ad1_7 = %c\n\r",ad1_7);
1251:main.c        **** 			}
1252:main.c        **** 			else if(ind == 12)	// AD6 - 1.6
1253:main.c        **** 			{
1254:main.c        **** 				ad1_6 = stringBuf[mark-2]; // default is 'N'
1255:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
1256:main.c        **** 				rprintf("ad1_6 = %c\n\r",ad1_6);
1257:main.c        **** 			}
1258:main.c        **** 			else if(ind == 13)	//AD7 - 1.2
1259:main.c        **** 			{
1260:main.c        **** 				ad1_2 = stringBuf[mark-2]; // default is 'N'
1261:main.c        **** 				if(ad1_2 == 'Y'){ temp2++; }
1262:main.c        **** 				rprintf("ad1_2 = %c\n\r",ad1_2);
1263:main.c        **** 			}
1264:main.c        **** 			else if(ind == 14)	//AD8 - 1.3
1265:main.c        **** 			{
1266:main.c        **** 				ad1_3 = stringBuf[mark-2]; // default is 'N'
1267:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
1268:main.c        **** 				rprintf("ad1_3 = %c\n\r",ad1_3);
1269:main.c        **** 			}
1270:main.c        **** 			else if(ind == 15)
1271:main.c        **** 			{
1272:main.c        **** 				safety = stringBuf[mark-2]; // default is 'Y'
1273:main.c        **** 				rprintf("safety = %c\n\r",safety);
1274:main.c        **** 			}
1275:main.c        **** 		}
1276:main.c        **** 	}
1277:main.c        **** 
1278:main.c        **** 	if(safety == 'Y')
1279:main.c        **** 	{
1280:main.c        **** 		if((temp2 ==10) && (freq > 150)){ freq = 150; }
1281:main.c        **** 		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
1282:main.c        **** 		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
1283:main.c        **** 		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
1284:main.c        **** 		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
1285:main.c        **** 		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
1286:main.c        **** 		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
1287:main.c        **** 		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
1288:main.c        **** 		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
1289:main.c        **** 		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
1290:main.c        **** 		else if((temp2 == 0)){ freq = 100; }
1291:main.c        **** 	}
1292:main.c        **** 	
1293:main.c        **** 	if(safety == 'T'){ test(); }
1294:main.c        **** 
1295:main.c        **** }
1296:main.c        **** 
1297:main.c        **** /***********************************************
1298:main.c        **** * Automatic UART mode
1299:main.c        **** * Each time the UART interrupt is triggered the
1300:main.c        **** * arriving character is read and added to the
1301:main.c        **** * data buffer
1302:main.c        **** ************************************************/
1303:main.c        **** void mode_0(void) // Auto UART mode
1304:main.c        **** {
1305:main.c        **** 	rprintf("MODE 0\n\r");
1306:main.c        **** 	setup_uart0(baud,1);
1307:main.c        **** 	stringSize = 512;
1308:main.c        **** 	mode_action();
1309:main.c        **** 	//rprintf("Exit mode 0\n\r");
1310:main.c        **** 
1311:main.c        **** }
1312:main.c        **** 
1313:main.c        **** /**********************************************
1314:main.c        **** * Triggered UART mode
1315:main.c        **** * Trigger is '$'
1316:main.c        **** * Logs '$' and next 99 characters or until CR/LF
1317:main.c        **** *
1318:main.c        **** ***********************************************/
1319:main.c        **** void mode_1(void)
1320:main.c        **** {
1321:main.c        **** 	rprintf("MODE 1\n\r");	
1322:main.c        **** 
1323:main.c        **** 	setup_uart0(baud,2);
1324:main.c        **** 	stringSize = frame + 2;
1325:main.c        **** 
1326:main.c        **** 	mode_action();
1327:main.c        **** }
1328:main.c        **** 
1329:main.c        **** /***************************************************
1330:main.c        **** * Timer Interrupt triggered ADC read mode
1331:main.c        **** * 'Frequency' for LOGCON.TXT determines frequency
1332:main.c        **** * 100 is roughly 1 trigger per second
1333:main.c        **** ***************************************************/
1334:main.c        **** void mode_2(void)
1335:main.c        **** {
1336:main.c        **** 	rprintf("MODE 2\n\r");	
1337:main.c        **** 	enableIRQ();
1338:main.c        **** 	// Timer0  interrupt is an IRQ interrupt
1339:main.c        **** 	VICIntSelect &= ~0x00000010;
1340:main.c        **** 	// Enable Timer0 interrupt
1341:main.c        **** 	VICIntEnable |= 0x00000010;
1342:main.c        **** 	// Use slot 2 for UART0 interrupt
1343:main.c        **** 	VICVectCntl2 = 0x24;
1344:main.c        **** 	// Set the address of ISR for slot 1
1345:main.c        **** 	VICVectAddr2 = (unsigned int)MODE2ISR;
1346:main.c        **** 
1347:main.c        **** 	T0TCR = 0x00000002;	// Reset counter and prescaler
1348:main.c        **** 	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
1349:main.c        **** 	T0MR0 = 58982400 / freq;
1350:main.c        **** 
1351:main.c        **** 	T0PR = 0x00000000;
1352:main.c        **** 
1353:main.c        **** 	T0TCR = 0x00000001; // enable timer
1354:main.c        **** 
1355:main.c        **** 	stringSize = 512;
1356:main.c        **** 	mode_action();
1357:main.c        **** }
1358:main.c        **** 
1359:main.c        **** /**********************************************
1360:main.c        **** * Triggered UART with ADC mode
1361:main.c        **** * Trigger is '$'
1362:main.c        **** * Logs '$' and next 99 characters or until CR/LF
1363:main.c        **** * Each secondary buffer write triggers an ADC read
1364:main.c        **** ***********************************************/
1365:main.c        **** void mode_3(void)
1366:main.c        **** {
1367:main.c        **** 	rprintf("MODE 3\n\r");	
1368:main.c        **** 
1369:main.c        **** 	setup_uart0(baud,2);
1370:main.c        **** 	stringSize = frame + 2;
1371:main.c        **** 	use_adc = TRUE;
1372:main.c        **** 	mode_action();
1373:main.c        **** }
1374:main.c        **** 
1375:main.c        **** /********************************************************
1376:main.c        **** * All of the non-Interrupt driven work, after initial
1377:main.c        **** * configuration, going on here.
1378:main.c        **** * Control is passed here after mode (0-2 above) related
1379:main.c        **** * initialization has occurred. Program execution, other
1380:main.c        **** * than Interrupt driven code, never leaves here. This 
1381:main.c        **** * function just writes to the microSD when the buffers 
1382:main.c        **** * are full. It also checks to make sure the 'stop'
1383:main.c        **** * button hasn't been pressed which writes all buffers
1384:main.c        **** * to the microSD, lights the STAT0 & STAT1 LEDs,
1385:main.c        **** * and then is locked into an endless loop.
1386:main.c        **** ********************************************************/
1387:main.c        **** void mode_action(void)
1388:main.c        **** {
1389:main.c        **** 	int j;
1390:main.c        **** 
1391:main.c        **** 	while(1)
1392:main.c        **** 	{
1393:main.c        **** 		// if the first data buffer is full, write it to the microSD
1394:main.c        **** 		if(log_array1 == 1)
1395:main.c        **** 		{
1396:main.c        **** 			stat(0,ON);
1397:main.c        **** 				
1398:main.c        **** 			if(fat_write_file(handle,(unsigned char *)RX_array1, stringSize) < 0)
1399:main.c        **** 			{
1400:main.c        **** 				while(1)
1401:main.c        **** 				{
1402:main.c        **** 					stat(0,ON);
1403:main.c        **** 					for(j = 0; j < 500000; j++)
1404:main.c        **** 					stat(0,OFF);
1405:main.c        **** 					stat(1,ON);
1406:main.c        **** 					for(j = 0; j < 500000; j++)
1407:main.c        **** 					stat(1,OFF);
1408:main.c        **** 				}
1409:main.c        **** 			}
1410:main.c        **** 			
1411:main.c        **** 			sd_raw_sync();
1412:main.c        **** 			stat(0,OFF);
1413:main.c        **** 			log_array1 = 0;
1414:main.c        **** 		}
1415:main.c        **** 
1416:main.c        **** 		// if the second data buffer is full, write it to the microSD
1417:main.c        **** 		if(log_array2 == 1)
1418:main.c        **** 		{
1419:main.c        **** 			stat(1,ON);
1420:main.c        **** 			
1421:main.c        **** 			if(fat_write_file(handle,(unsigned char *)RX_array2, stringSize) < 0)
1422:main.c        **** 			{
1423:main.c        **** 				while(1)
1424:main.c        **** 				{
1425:main.c        **** 					stat(0,ON);
1426:main.c        **** 					for(j = 0; j < 500000; j++)
1427:main.c        **** 					stat(0,OFF);
1428:main.c        **** 					stat(1,ON);
1429:main.c        **** 					for(j = 0; j < 500000; j++)
1430:main.c        **** 					stat(1,OFF);
1431:main.c        **** 				}
1432:main.c        **** 			}
1433:main.c        **** 			
1434:main.c        **** 			sd_raw_sync();
1435:main.c        **** 			stat(1,OFF);
1436:main.c        **** 			log_array2 = 0;
1437:main.c        **** 			if(use_adc == TRUE)
1438:main.c        **** 				LogADC();
1439:main.c        **** 		}
1440:main.c        **** 		
1441:main.c        **** 		// see if ADC data needs to be logged
1442:main.c        **** 		if(log_adc == 1)
1443:main.c        **** 		{
1444:main.c        **** 			stat(0,ON);
1445:main.c        **** 			
1446:main.c        **** 			if(fat_write_file(handle,(unsigned char *)ADC_array,ADCStringSize) < 0)
1447:main.c        **** 			{
1448:main.c        **** 				while(1)
1449:main.c        **** 				{
1450:main.c        **** 					stat(0,ON);
1451:main.c        **** 					for(j = 0; j < 500000; j++)
1452:main.c        **** 					stat(0,OFF);
1453:main.c        **** 					stat(1,ON);
1454:main.c        **** 					for(j = 0; j < 500000; j++)
1455:main.c        **** 					stat(1,OFF);
1456:main.c        **** 				}
1457:main.c        **** 			}
1458:main.c        **** 			sd_raw_sync();
1459:main.c        **** 			stat(0,OFF);
1460:main.c        **** 			log_adc = 0;
1461:main.c        **** 		}
1462:main.c        **** 
1463:main.c        **** 		// if the 'stop' button has been pressed then write everything to
1464:main.c        **** 		// the microSD, turn on the STAT0 & STAT1 LEDs, and lock up
1465:main.c        **** 		if((IOPIN0 & 0x00000008) == 0)
1466:main.c        **** 		{
1467:main.c        **** 			VICIntEnClr = 0xFFFFFFFF;
1468:main.c        **** 			// write whatever is left in the data buffer to the microSD
1469:main.c        **** 			if(RX_in < 512)
1470:main.c        **** 			{
1471:main.c        **** 				fat_write_file(handle, (unsigned char *)RX_array1, RX_in);
1472:main.c        **** 				sd_raw_sync();
1473:main.c        **** 			}
1474:main.c        **** 			else if(RX_in >= 512)
1475:main.c        **** 			{
1476:main.c        **** 				fat_write_file(handle, (unsigned char *)RX_array2, RX_in - 512);
1477:main.c        **** 				sd_raw_sync();
1478:main.c        **** 			}
1479:main.c        **** 			// turn on STAT0 & STAT1 and lock up in endless loop
1480:main.c        **** 			while(1)
1481:main.c        **** 			{
1482:main.c        **** 				stat(0,ON);
1483:main.c        **** 				for(j = 0; j < 500000; j++);
1484:main.c        **** 				stat(0,OFF);
1485:main.c        **** 				stat(1,ON);
1486:main.c        **** 				for(j = 0; j < 500000; j++);
1487:main.c        **** 				stat(1,OFF);
1488:main.c        **** 			}
1489:main.c        **** 		}
1490:main.c        **** 	}
1491:main.c        **** 
1492:main.c        **** }
1493:main.c        **** 
1494:main.c        **** void test(void)
1495:main.c        **** {
1496:main.c        **** 
1497:main.c        **** 	rprintf("\n\rLogomatic V2 Test Code:\n\r");
1498:main.c        **** 	rprintf("ADC Test will begin in 5 seconds, hit stop button to terminate the test.\r\n\n");
1499:main.c        **** 
1500:main.c        **** 	delay_ms(5000);
1501:main.c        **** 
1502:main.c        **** 	while((IOPIN0 & 0x00000008) == 0x00000008)
1503:main.c        **** 	{
1504:main.c        **** 		// Get AD1.3
1505:main.c        **** 		AD1CR = 0x0020FF08;
1506:main.c        **** 		AD_conversion(1);
1507:main.c        **** 
1508:main.c        **** 		// Get AD0.3
1509:main.c        **** 		AD0CR = 0x0020FF08;
1510:main.c        **** 		AD_conversion(0);
1511:main.c        **** 		
1512:main.c        **** 		// Get AD0.2
1513:main.c        **** 		AD0CR = 0x0020FF04;
1514:main.c        **** 		AD_conversion(0);
1515:main.c        **** 
1516:main.c        **** 		// Get AD0.1
1517:main.c        **** 		AD0CR = 0x0020FF02;
1518:main.c        **** 		AD_conversion(0);
1519:main.c        **** 
1520:main.c        **** 		// Get AD1.2
1521:main.c        **** 		AD1CR = 0x0020FF04;
1522:main.c        **** 		AD_conversion(1);
1523:main.c        **** 		
1524:main.c        **** 		// Get AD0.4
1525:main.c        **** 		AD0CR = 0x0020FF10;
1526:main.c        **** 		AD_conversion(0);
1527:main.c        **** 
1528:main.c        **** 		// Get AD1.7
1529:main.c        **** 		AD1CR = 0x0020FF80;
1530:main.c        **** 		AD_conversion(1);
1531:main.c        **** 
1532:main.c        **** 		// Get AD1.6
1533:main.c        **** 		AD1CR = 0x0020FF40;
1534:main.c        **** 		AD_conversion(1);
1535:main.c        **** 
1536:main.c        **** 		delay_ms(1000);
1537:main.c        **** 		rprintf("\n\r");
1538:main.c        **** 	}
1539:main.c        **** 
1540:main.c        **** 	rprintf("\n\rTest complete, locking up...\n\r");
1541:main.c        **** 	while(1);
1542:main.c        **** 		
1543:main.c        **** }
1544:main.c        **** 
1545:main.c        **** void AD_conversion(int regbank)
1546:main.c        **** {
 2033              		.loc 1 1546 0
 2034              		.cfi_startproc
 2035              		@ Function supports interworking.
 2036              		@ args = 0, pretend = 0, frame = 0
 2037              		@ frame_needed = 0, uses_anonymous_args = 0
 2038              	.LVL137:
1547:main.c        **** 	int temp = 0, temp2;
1548:main.c        **** 
1549:main.c        **** 	if(!regbank) // bank 0
 2039              		.loc 1 1549 0
 2040 108c 000050E3 		cmp	r0, #0
1546:main.c        **** 	int temp = 0, temp2;
 2041              		.loc 1 1546 0
 2042 1090 04E02DE5 		str	lr, [sp, #-4]!
 2043              	.LCFI7:
 2044              		.cfi_def_cfa_offset 4
 2045              		.cfi_offset 14, -4
 2046              		.loc 1 1549 0
 2047 1094 0C00001A 		bne	.L196
1550:main.c        **** 	{
1551:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 2048              		.loc 1 1551 0
 2049 1098 78309FE5 		ldr	r3, .L203
 2050 109c 002093E5 		ldr	r2, [r3, #0]
 2051 10a0 012482E3 		orr	r2, r2, #16777216
 2052 10a4 002083E5 		str	r2, [r3, #0]
 2053              	.LVL138:
 2054              	.L197:
1552:main.c        **** 		while((temp & 0x80000000) == 0)
1553:main.c        **** 		{
1554:main.c        **** 			temp = AD0DR;
 2055              		.loc 1 1554 0
 2056 10a8 042093E5 		ldr	r2, [r3, #4]
 2057              	.LVL139:
1552:main.c        **** 		while((temp & 0x80000000) == 0)
 2058              		.loc 1 1552 0
 2059 10ac 000052E3 		cmp	r2, #0
 2060 10b0 FCFFFFAA 		bge	.L197
 2061              	.LVL140:
1555:main.c        **** 		}
1556:main.c        **** 		temp &= 0x0000FFC0;
 2062              		.loc 1 1556 0
 2063 10b4 60109FE5 		ldr	r1, .L203+4
 2064 10b8 011002E0 		and	r1, r2, r1
 2065              	.LVL141:
1557:main.c        **** 		temp2 = temp / 0x00000040;
 2066              		.loc 1 1557 0
 2067 10bc 4113A0E1 		mov	r1, r1, asr #6
 2068              	.LVL142:
1558:main.c        **** 
1559:main.c        **** 		AD0CR = 0x00000000;
 2069              		.loc 1 1559 0
 2070 10c0 0020A0E3 		mov	r2, #0
 2071              	.LVL143:
 2072 10c4 4C309FE5 		ldr	r3, .L203
 2073 10c8 0B0000EA 		b	.L202
 2074              	.LVL144:
 2075              	.L196:
1560:main.c        **** 	}
1561:main.c        **** 	else	    // bank 1
1562:main.c        **** 	{
1563:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 2076              		.loc 1 1563 0
 2077 10cc 4C309FE5 		ldr	r3, .L203+8
 2078 10d0 002093E5 		ldr	r2, [r3, #0]
 2079 10d4 012482E3 		orr	r2, r2, #16777216
 2080 10d8 002083E5 		str	r2, [r3, #0]
 2081              	.LVL145:
 2082              	.L199:
1564:main.c        **** 		while((temp & 0x80000000) == 0)
1565:main.c        **** 		{
1566:main.c        **** 			temp = AD1DR;
 2083              		.loc 1 1566 0
 2084 10dc 042093E5 		ldr	r2, [r3, #4]
 2085              	.LVL146:
1564:main.c        **** 		while((temp & 0x80000000) == 0)
 2086              		.loc 1 1564 0
 2087 10e0 000052E3 		cmp	r2, #0
 2088 10e4 FCFFFFAA 		bge	.L199
 2089              	.LVL147:
1567:main.c        **** 		}
1568:main.c        **** 		temp &= 0x0000FFC0;
 2090              		.loc 1 1568 0
 2091 10e8 2C109FE5 		ldr	r1, .L203+4
1569:main.c        **** 		temp2 = temp / 0x00000040;
1570:main.c        **** 
1571:main.c        **** 		AD1CR = 0x00000000;
 2092              		.loc 1 1571 0
 2093 10ec 2C309FE5 		ldr	r3, .L203+8
1568:main.c        **** 		temp2 = temp / 0x00000040;
 2094              		.loc 1 1568 0
 2095 10f0 011002E0 		and	r1, r2, r1
 2096              	.LVL148:
1569:main.c        **** 		temp2 = temp / 0x00000040;
 2097              		.loc 1 1569 0
 2098 10f4 4113A0E1 		mov	r1, r1, asr #6
 2099              	.LVL149:
 2100              		.loc 1 1571 0
 2101 10f8 0020A0E3 		mov	r2, #0
 2102              	.LVL150:
 2103              	.L202:
 2104 10fc 002083E5 		str	r2, [r3, #0]
1572:main.c        **** 	}
1573:main.c        **** 
1574:main.c        **** 	rprintf("%d", temp2);
 2105              		.loc 1 1574 0
 2106 1100 1C009FE5 		ldr	r0, .L203+12
 2107              	.LVL151:
 2108 1104 FEFFFFEB 		bl	rprintf
 2109              	.LVL152:
1575:main.c        **** 	rprintf("   ");
 2110              		.loc 1 1575 0
 2111 1108 18009FE5 		ldr	r0, .L203+16
 2112 110c FEFFFFEB 		bl	rprintf
 2113              	.LVL153:
1576:main.c        **** 	
1577:main.c        **** }
 2114              		.loc 1 1577 0
 2115 1110 04E09DE4 		ldr	lr, [sp], #4
 2116 1114 1EFF2FE1 		bx	lr
 2117              	.L204:
 2118              		.align	2
 2119              	.L203:
 2120 1118 004003E0 		.word	-536657920
 2121 111c C0FF0000 		.word	65472
 2122 1120 000006E0 		.word	-536477696
 2123 1124 00000000 		.word	.LC0
 2124 1128 03000000 		.word	.LC1
 2125              		.cfi_endproc
 2126              	.LFE18:
 2128              		.align	2
 2129              		.global	fat_initialize
 2131              	fat_initialize:
 2132              	.LFB19:
1578:main.c        **** 
1579:main.c        **** void fat_initialize(void)
1580:main.c        **** {
 2133              		.loc 1 1580 0
 2134              		.cfi_startproc
 2135              		@ Function supports interworking.
 2136              		@ args = 0, pretend = 0, frame = 0
 2137              		@ frame_needed = 0, uses_anonymous_args = 0
 2138 112c 04E02DE5 		str	lr, [sp, #-4]!
 2139              	.LCFI8:
 2140              		.cfi_def_cfa_offset 4
 2141              		.cfi_offset 14, -4
1581:main.c        **** 	if(!sd_raw_init())
 2142              		.loc 1 1581 0
 2143 1130 FEFFFFEB 		bl	sd_raw_init
 2144              	.LVL154:
 2145 1134 000050E3 		cmp	r0, #0
 2146 1138 0200001A 		bne	.L206
1582:main.c        **** 	{
1583:main.c        **** 		rprintf("SD Init Error\n\r");
 2147              		.loc 1 1583 0
 2148 113c 1C009FE5 		ldr	r0, .L212
 2149 1140 FEFFFFEB 		bl	rprintf
 2150              	.LVL155:
 2151              	.L207:
 2152 1144 FEFFFFEA 		b	.L207
 2153              	.L206:
1584:main.c        **** 		while(1);
1585:main.c        **** 	}
1586:main.c        **** 
1587:main.c        **** 	if(openroot())
 2154              		.loc 1 1587 0
 2155 1148 FEFFFFEB 		bl	openroot
 2156              	.LVL156:
 2157 114c 000050E3 		cmp	r0, #0
1588:main.c        **** 	{ 
1589:main.c        **** 		rprintf("SD OpenRoot Error\n\r");
 2158              		.loc 1 1589 0
 2159 1150 0C009F15 		ldrne	r0, .L212+4
 2160 1154 FEFFFF1B 		blne	rprintf
 2161              	.LVL157:
 2162              	.L205:
1590:main.c        **** 	}
1591:main.c        **** }
 2163              		.loc 1 1591 0
 2164 1158 04E09DE4 		ldr	lr, [sp], #4
 2165 115c 1EFF2FE1 		bx	lr
 2166              	.L213:
 2167              		.align	2
 2168              	.L212:
 2169 1160 07000000 		.word	.LC2
 2170 1164 17000000 		.word	.LC3
 2171              		.cfi_endproc
 2172              	.LFE19:
 2174              		.align	2
 2175              		.global	delay_ms
 2177              	delay_ms:
 2178              	.LFB20:
1592:main.c        **** 
1593:main.c        **** void delay_ms(int count)
1594:main.c        **** {
 2179              		.loc 1 1594 0
 2180              		.cfi_startproc
 2181              		@ Function supports interworking.
 2182              		@ args = 0, pretend = 0, frame = 0
 2183              		@ frame_needed = 0, uses_anonymous_args = 0
 2184              		@ link register save eliminated.
 2185              	.LVL158:
1595:main.c        **** 	int i;
1596:main.c        **** 	count *= 10000;
 2186              		.loc 1 1596 0
 2187 1168 1C309FE5 		ldr	r3, .L217
 2188 116c 930000E0 		mul	r0, r3, r0
 2189              	.LVL159:
1597:main.c        **** 	for(i = 0; i < count; i++)
 2190              		.loc 1 1597 0
 2191 1170 0030A0E3 		mov	r3, #0
 2192 1174 010000EA 		b	.L215
 2193              	.LVL160:
 2194              	.L216:
1598:main.c        **** 		asm volatile ("nop");
 2195              		.loc 1 1598 0 discriminator 2
 2196              	@ 1598 "main.c" 1
 2197 1178 0000A0E1 		nop
 2198              	@ 0 "" 2
1597:main.c        **** 	for(i = 0; i < count; i++)
 2199              		.loc 1 1597 0 discriminator 2
 2200 117c 013083E2 		add	r3, r3, #1
 2201              	.LVL161:
 2202              	.L215:
1597:main.c        **** 	for(i = 0; i < count; i++)
 2203              		.loc 1 1597 0 is_stmt 0 discriminator 1
 2204 1180 000053E1 		cmp	r3, r0
 2205 1184 FBFFFFBA 		blt	.L216
1599:main.c        **** }
 2206              		.loc 1 1599 0 is_stmt 1
 2207 1188 1EFF2FE1 		bx	lr
 2208              	.L218:
 2209              		.align	2
 2210              	.L217:
 2211 118c 10270000 		.word	10000
 2212              		.cfi_endproc
 2213              	.LFE20:
 2215              		.align	2
 2216              		.global	test
 2218              	test:
 2219              	.LFB17:
1495:main.c        **** 
 2220              		.loc 1 1495 0
 2221              		.cfi_startproc
 2222              		@ Function supports interworking.
 2223              		@ args = 0, pretend = 0, frame = 0
 2224              		@ frame_needed = 0, uses_anonymous_args = 0
 2225 1190 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2226              	.LCFI9:
 2227              		.cfi_def_cfa_offset 24
 2228              		.cfi_offset 4, -24
 2229              		.cfi_offset 5, -20
 2230              		.cfi_offset 6, -16
 2231              		.cfi_offset 7, -12
 2232              		.cfi_offset 8, -8
 2233              		.cfi_offset 14, -4
1497:main.c        **** 	rprintf("ADC Test will begin in 5 seconds, hit stop button to terminate the test.\r\n\n");
 2234              		.loc 1 1497 0
 2235 1194 C0009FE5 		ldr	r0, .L223
 2236 1198 FEFFFFEB 		bl	rprintf
 2237              	.LVL162:
1498:main.c        **** 
 2238              		.loc 1 1498 0
 2239 119c BC009FE5 		ldr	r0, .L223+4
 2240 11a0 FEFFFFEB 		bl	rprintf
 2241              	.LVL163:
1500:main.c        **** 
 2242              		.loc 1 1500 0
 2243 11a4 B8009FE5 		ldr	r0, .L223+8
 2244 11a8 FEFFFFEB 		bl	delay_ms
 2245              	.LVL164:
1502:main.c        **** 	{
 2246              		.loc 1 1502 0
 2247 11ac B4809FE5 		ldr	r8, .L223+12
1505:main.c        **** 		AD_conversion(1);
 2248              		.loc 1 1505 0
 2249 11b0 B4409FE5 		ldr	r4, .L223+16
 2250 11b4 B4609FE5 		ldr	r6, .L223+20
1502:main.c        **** 	{
 2251              		.loc 1 1502 0
 2252 11b8 210000EA 		b	.L220
 2253              	.L221:
1509:main.c        **** 		AD_conversion(0);
 2254              		.loc 1 1509 0
 2255 11bc B0509FE5 		ldr	r5, .L223+24
1506:main.c        **** 
 2256              		.loc 1 1506 0
 2257 11c0 0100A0E3 		mov	r0, #1
1513:main.c        **** 		AD_conversion(0);
 2258              		.loc 1 1513 0
 2259 11c4 AC709FE5 		ldr	r7, .L223+28
1505:main.c        **** 		AD_conversion(1);
 2260              		.loc 1 1505 0
 2261 11c8 006084E5 		str	r6, [r4, #0]
1506:main.c        **** 
 2262              		.loc 1 1506 0
 2263 11cc FEFFFFEB 		bl	AD_conversion
 2264              	.LVL165:
1510:main.c        **** 		
 2265              		.loc 1 1510 0
 2266 11d0 0000A0E3 		mov	r0, #0
1509:main.c        **** 		AD_conversion(0);
 2267              		.loc 1 1509 0
 2268 11d4 006085E5 		str	r6, [r5, #0]
1510:main.c        **** 		
 2269              		.loc 1 1510 0
 2270 11d8 FEFFFFEB 		bl	AD_conversion
 2271              	.LVL166:
1514:main.c        **** 
 2272              		.loc 1 1514 0
 2273 11dc 0000A0E3 		mov	r0, #0
1513:main.c        **** 		AD_conversion(0);
 2274              		.loc 1 1513 0
 2275 11e0 007085E5 		str	r7, [r5, #0]
1514:main.c        **** 
 2276              		.loc 1 1514 0
 2277 11e4 FEFFFFEB 		bl	AD_conversion
 2278              	.LVL167:
1517:main.c        **** 		AD_conversion(0);
 2279              		.loc 1 1517 0
 2280 11e8 8C309FE5 		ldr	r3, .L223+32
1518:main.c        **** 
 2281              		.loc 1 1518 0
 2282 11ec 0000A0E3 		mov	r0, #0
1517:main.c        **** 		AD_conversion(0);
 2283              		.loc 1 1517 0
 2284 11f0 003085E5 		str	r3, [r5, #0]
1518:main.c        **** 
 2285              		.loc 1 1518 0
 2286 11f4 FEFFFFEB 		bl	AD_conversion
 2287              	.LVL168:
1522:main.c        **** 		
 2288              		.loc 1 1522 0
 2289 11f8 0100A0E3 		mov	r0, #1
1521:main.c        **** 		AD_conversion(1);
 2290              		.loc 1 1521 0
 2291 11fc 007084E5 		str	r7, [r4, #0]
1522:main.c        **** 		
 2292              		.loc 1 1522 0
 2293 1200 FEFFFFEB 		bl	AD_conversion
 2294              	.LVL169:
1525:main.c        **** 		AD_conversion(0);
 2295              		.loc 1 1525 0
 2296 1204 74309FE5 		ldr	r3, .L223+36
1526:main.c        **** 
 2297              		.loc 1 1526 0
 2298 1208 0000A0E3 		mov	r0, #0
1525:main.c        **** 		AD_conversion(0);
 2299              		.loc 1 1525 0
 2300 120c 003085E5 		str	r3, [r5, #0]
1526:main.c        **** 
 2301              		.loc 1 1526 0
 2302 1210 FEFFFFEB 		bl	AD_conversion
 2303              	.LVL170:
1529:main.c        **** 		AD_conversion(1);
 2304              		.loc 1 1529 0
 2305 1214 68309FE5 		ldr	r3, .L223+40
1530:main.c        **** 
 2306              		.loc 1 1530 0
 2307 1218 0100A0E3 		mov	r0, #1
1529:main.c        **** 		AD_conversion(1);
 2308              		.loc 1 1529 0
 2309 121c 003084E5 		str	r3, [r4, #0]
1530:main.c        **** 
 2310              		.loc 1 1530 0
 2311 1220 FEFFFFEB 		bl	AD_conversion
 2312              	.LVL171:
1533:main.c        **** 		AD_conversion(1);
 2313              		.loc 1 1533 0
 2314 1224 5C309FE5 		ldr	r3, .L223+44
1534:main.c        **** 
 2315              		.loc 1 1534 0
 2316 1228 0100A0E3 		mov	r0, #1
1533:main.c        **** 		AD_conversion(1);
 2317              		.loc 1 1533 0
 2318 122c 003084E5 		str	r3, [r4, #0]
1534:main.c        **** 
 2319              		.loc 1 1534 0
 2320 1230 FEFFFFEB 		bl	AD_conversion
 2321              	.LVL172:
1536:main.c        **** 		rprintf("\n\r");
 2322              		.loc 1 1536 0
 2323 1234 FA0FA0E3 		mov	r0, #1000
 2324 1238 FEFFFFEB 		bl	delay_ms
 2325              	.LVL173:
1537:main.c        **** 	}
 2326              		.loc 1 1537 0
 2327 123c 48009FE5 		ldr	r0, .L223+48
 2328 1240 FEFFFFEB 		bl	rprintf
 2329              	.LVL174:
 2330              	.L220:
1502:main.c        **** 	{
 2331              		.loc 1 1502 0 discriminator 1
 2332 1244 003098E5 		ldr	r3, [r8, #0]
 2333 1248 080013E3 		tst	r3, #8
 2334 124c DAFFFF1A 		bne	.L221
1540:main.c        **** 	while(1);
 2335              		.loc 1 1540 0
 2336 1250 38009FE5 		ldr	r0, .L223+52
 2337 1254 FEFFFFEB 		bl	rprintf
 2338              	.LVL175:
 2339              	.L222:
 2340 1258 FEFFFFEA 		b	.L222
 2341              	.L224:
 2342              		.align	2
 2343              	.L223:
 2344 125c 2B000000 		.word	.LC4
 2345 1260 47000000 		.word	.LC5
 2346 1264 88130000 		.word	5000
 2347 1268 008002E0 		.word	-536707072
 2348 126c 000006E0 		.word	-536477696
 2349 1270 08FF2000 		.word	2162440
 2350 1274 004003E0 		.word	-536657920
 2351 1278 04FF2000 		.word	2162436
 2352 127c 02FF2000 		.word	2162434
 2353 1280 10FF2000 		.word	2162448
 2354 1284 80FF2000 		.word	2162560
 2355 1288 40FF2000 		.word	2162496
 2356 128c 93000000 		.word	.LC6
 2357 1290 96000000 		.word	.LC7
 2358              		.cfi_endproc
 2359              	.LFE17:
 2361              		.align	2
 2362              		.global	Log_init
 2364              	Log_init:
 2365              	.LFB11:
1129:main.c        **** 	int x, mark = 0, ind = 0;
 2366              		.loc 1 1129 0
 2367              		.cfi_startproc
 2368              		@ Function supports interworking.
 2369              		@ args = 0, pretend = 0, frame = 0
 2370              		@ frame_needed = 0, uses_anonymous_args = 0
 2371              	.LVL176:
 2372 1294 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2373              	.LCFI10:
 2374              		.cfi_def_cfa_offset 36
 2375              		.cfi_offset 4, -36
 2376              		.cfi_offset 5, -32
 2377              		.cfi_offset 6, -28
 2378              		.cfi_offset 7, -24
 2379              		.cfi_offset 8, -20
 2380              		.cfi_offset 9, -16
 2381              		.cfi_offset 10, -12
 2382              		.cfi_offset 11, -8
 2383              		.cfi_offset 14, -4
1134:main.c        **** 	{
 2384              		.loc 1 1134 0
 2385 1298 08059FE5 		ldr	r0, .L293
 2386 129c FEFFFFEB 		bl	root_file_exists
 2387              	.LVL177:
 2388 12a0 000050E3 		cmp	r0, #0
 2389 12a4 00459FE5 		ldr	r4, .L293+4
1137:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
 2390              		.loc 1 1137 0
 2391 12a8 F8049FE5 		ldr	r0, .L293
1134:main.c        **** 	{
 2392              		.loc 1 1134 0
 2393 12ac 0C00000A 		beq	.L226
1137:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
 2394              		.loc 1 1137 0
 2395 12b0 FEFFFFEB 		bl	root_open
 2396              	.LVL178:
1138:main.c        **** 		stringBuf[stringSize] = '\0';
 2397              		.loc 1 1138 0
 2398 12b4 F4549FE5 		ldr	r5, .L293+8
 2399 12b8 022CA0E3 		mov	r2, #512
 2400 12bc 0510A0E1 		mov	r1, r5
1137:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
 2401              		.loc 1 1137 0
 2402 12c0 000084E5 		str	r0, [r4, #0]
1138:main.c        **** 		stringBuf[stringSize] = '\0';
 2403              		.loc 1 1138 0
 2404 12c4 FEFFFFEB 		bl	fat_read_file
 2405              	.LVL179:
 2406 12c8 E4349FE5 		ldr	r3, .L293+12
 2407 12cc 000083E5 		str	r0, [r3, #0]
1139:main.c        **** 		fat_close_file(fd);
 2408              		.loc 1 1139 0
 2409 12d0 0030A0E3 		mov	r3, #0
 2410 12d4 0030C5E7 		strb	r3, [r5, r0]
1140:main.c        **** 	}
 2411              		.loc 1 1140 0
 2412 12d8 000094E5 		ldr	r0, [r4, #0]
 2413 12dc FEFFFFEB 		bl	fat_close_file
 2414              	.LVL180:
 2415 12e0 1F0000EA 		b	.L227
 2416              	.L226:
1145:main.c        **** 		if(fd == NULL)
 2417              		.loc 1 1145 0
 2418 12e4 FEFFFFEB 		bl	root_open_new
 2419              	.LVL181:
1146:main.c        **** 		{
 2420              		.loc 1 1146 0
 2421 12e8 000050E3 		cmp	r0, #0
1145:main.c        **** 		if(fd == NULL)
 2422              		.loc 1 1145 0
 2423 12ec 0050A0E1 		mov	r5, r0
 2424 12f0 000084E5 		str	r0, [r4, #0]
1146:main.c        **** 		{
 2425              		.loc 1 1146 0
 2426 12f4 0E00001A 		bne	.L228
1148:main.c        **** 		 	while(1)
 2427              		.loc 1 1148 0
 2428 12f8 B8049FE5 		ldr	r0, .L293+16
 2429 12fc FEFFFFEB 		bl	rprintf
 2430              	.LVL182:
 2431              	.LBB40:
 2432              	.LBB41:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 2433              		.loc 1 1123 0
 2434 1300 0450A0E3 		mov	r5, #4
 2435 1304 B0449FE5 		ldr	r4, .L293+20
 2436 1308 0570A0E1 		mov	r7, r5
 2437              	.L229:
 2438              	.LVL183:
 2439              	.LBE41:
 2440              	.LBE40:
1152:main.c        **** 				stat(0,OFF);
 2441              		.loc 1 1152 0 discriminator 1
 2442 130c 3200A0E3 		mov	r0, #50
 2443              	.LBB43:
 2444              	.LBB44:
 2445              	.LBB45:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 2446              		.loc 1 1118 0 discriminator 1
 2447 1310 026BA0E3 		mov	r6, #2048
 2448              	.LBE45:
 2449              	.LBE44:
 2450              	.LBE43:
 2451              	.LBB48:
 2452              	.LBB42:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 2453              		.loc 1 1123 0 discriminator 1
 2454 1314 0C7084E5 		str	r7, [r4, #12]
 2455              	.LBE42:
 2456              	.LBE48:
1152:main.c        **** 				stat(0,OFF);
 2457              		.loc 1 1152 0 discriminator 1
 2458 1318 FEFFFFEB 		bl	delay_ms
 2459              	.LVL184:
 2460              	.LBB49:
 2461              	.LBB50:
1124:main.c        **** 	}
 2462              		.loc 1 1124 0 discriminator 1
 2463 131c 045084E5 		str	r5, [r4, #4]
 2464              	.LVL185:
 2465              	.LBE50:
 2466              	.LBE49:
1155:main.c        **** 				stat(1,OFF);
 2467              		.loc 1 1155 0 discriminator 1
 2468 1320 3200A0E3 		mov	r0, #50
 2469              	.LBB51:
 2470              	.LBB47:
 2471              	.LBB46:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 2472              		.loc 1 1118 0 discriminator 1
 2473 1324 0C6084E5 		str	r6, [r4, #12]
 2474              	.LBE46:
 2475              	.LBE47:
 2476              	.LBE51:
1155:main.c        **** 				stat(1,OFF);
 2477              		.loc 1 1155 0 discriminator 1
 2478 1328 FEFFFFEB 		bl	delay_ms
 2479              	.LVL186:
 2480              	.LBB52:
 2481              	.LBB53:
 2482              	.LBB54:
1119:main.c        **** 	}
 2483              		.loc 1 1119 0 discriminator 1
 2484 132c 046084E5 		str	r6, [r4, #4]
 2485 1330 F5FFFFEA 		b	.L229
 2486              	.LVL187:
 2487              	.L228:
 2488              	.LBE54:
 2489              	.LBE53:
 2490              	.LBE52:
1160:main.c        **** 		stringSize = strlen(stringBuf);
 2491              		.loc 1 1160 0
 2492 1334 84149FE5 		ldr	r1, .L293+24
 2493 1338 70049FE5 		ldr	r0, .L293+8
 2494 133c FEFFFFEB 		bl	strcpy
 2495              	.LVL188:
1161:main.c        **** 		fat_write_file(fd, (unsigned char*)stringBuf, stringSize);
 2496              		.loc 1 1161 0
 2497 1340 68049FE5 		ldr	r0, .L293+8
 2498 1344 FEFFFFEB 		bl	strlen
 2499              	.LVL189:
 2500 1348 64349FE5 		ldr	r3, .L293+12
 2501 134c 0020A0E1 		mov	r2, r0
 2502 1350 000083E5 		str	r0, [r3, #0]
1162:main.c        **** 		sd_raw_sync();
 2503              		.loc 1 1162 0
 2504 1354 54149FE5 		ldr	r1, .L293+8
 2505 1358 0500A0E1 		mov	r0, r5
 2506 135c FEFFFFEB 		bl	fat_write_file
 2507              	.LVL190:
1163:main.c        **** 	}
 2508              		.loc 1 1163 0
 2509 1360 FEFFFFEB 		bl	sd_raw_sync
 2510              	.LVL191:
 2511              	.L227:
1129:main.c        **** 	int x, mark = 0, ind = 0;
 2512              		.loc 1 1129 0 discriminator 1
 2513 1364 0080A0E3 		mov	r8, #0
 2514 1368 54649FE5 		ldr	r6, .L293+28
 2515 136c 0840A0E1 		mov	r4, r8
 2516 1370 0870A0E1 		mov	r7, r8
 2517 1374 08A0A0E1 		mov	sl, r8
1166:main.c        **** 	{
 2518              		.loc 1 1166 0 discriminator 1
 2519 1378 34B49FE5 		ldr	fp, .L293+12
1266:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
 2520              		.loc 1 1266 0 discriminator 1
 2521 137c 44549FE5 		ldr	r5, .L293+32
1219:main.c        **** 				rprintf("frame = %d\n\r",frame);
 2522              		.loc 1 1219 0 discriminator 1
 2523 1380 44949FE5 		ldr	r9, .L293+36
 2524 1384 B00000EA 		b	.L230
 2525              	.LVL192:
 2526              	.L267:
1169:main.c        **** 		{
 2527              		.loc 1 1169 0
 2528 1388 0130F6E5 		ldrb	r3, [r6, #1]!	@ zero_extendqisi2
 2529              	.LVL193:
 2530 138c 0A0053E3 		cmp	r3, #10
 2531 1390 AC00001A 		bne	.L231
 2532              	.LVL194:
1172:main.c        **** 			if(ind == 1)
 2533              		.loc 1 1172 0
 2534 1394 017087E2 		add	r7, r7, #1
 2535              	.LVL195:
1173:main.c        **** 			{
 2536              		.loc 1 1173 0
 2537 1398 010057E3 		cmp	r7, #1
 2538 139c 0600001A 		bne	.L232
1177:main.c        **** 				rprintf("mode = %d\n\r",mode);
 2539              		.loc 1 1177 0
 2540 13a0 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
 2541 13a4 24349FE5 		ldr	r3, .L293+40
 2542 13a8 301041E2 		sub	r1, r1, #48
 2543 13ac FF1001E2 		and	r1, r1, #255
 2544 13b0 0510C3E5 		strb	r1, [r3, #5]
1178:main.c        **** 			}
 2545              		.loc 1 1178 0
 2546 13b4 18049FE5 		ldr	r0, .L293+44
 2547 13b8 A10000EA 		b	.L288
 2548              	.L232:
1180:main.c        **** 			{
 2549              		.loc 1 1180 0
 2550 13bc 020057E3 		cmp	r7, #2
1183:main.c        **** 				rprintf("asc = %c\n\r",asc);
 2551              		.loc 1 1183 0
 2552 13c0 02105605 		ldreqb	r1, [r6, #-2]	@ zero_extendqisi2
1184:main.c        **** 			}
 2553              		.loc 1 1184 0
 2554 13c4 0C049F05 		ldreq	r0, .L293+48
1183:main.c        **** 				rprintf("asc = %c\n\r",asc);
 2555              		.loc 1 1183 0
 2556 13c8 0510C505 		streqb	r1, [r5, #5]
 2557 13cc 9C00000A 		beq	.L288
 2558              	.L233:
1186:main.c        **** 			{
 2559              		.loc 1 1186 0
 2560 13d0 030057E3 		cmp	r7, #3
 2561 13d4 1C00001A 		bne	.L234
1189:main.c        **** 				else if(stringBuf[mark-2] == '2'){ baud = 2400; }
 2562              		.loc 1 1189 0
 2563 13d8 023056E5 		ldrb	r3, [r6, #-2]	@ zero_extendqisi2
 2564 13dc 310053E3 		cmp	r3, #49
 2565 13e0 4B3EA003 		moveq	r3, #1200
 2566 13e4 1400000A 		beq	.L287
 2567              	.L235:
1190:main.c        **** 				else if(stringBuf[mark-2] == '3'){ baud = 4800; }
 2568              		.loc 1 1190 0
 2569 13e8 320053E3 		cmp	r3, #50
 2570 13ec 963EA003 		moveq	r3, #2400
 2571 13f0 1100000A 		beq	.L287
 2572              	.L237:
1191:main.c        **** 				else if(stringBuf[mark-2] == '4'){ baud = 9600; }
 2573              		.loc 1 1191 0
 2574 13f4 330053E3 		cmp	r3, #51
 2575 13f8 4B3DA003 		moveq	r3, #4800
 2576 13fc 0E00000A 		beq	.L287
 2577              	.L238:
1192:main.c        **** 				else if(stringBuf[mark-2] == '5'){ baud = 19200; }
 2578              		.loc 1 1192 0
 2579 1400 340053E3 		cmp	r3, #52
 2580 1404 963DA003 		moveq	r3, #9600
 2581 1408 0B00000A 		beq	.L287
 2582              	.L239:
1193:main.c        **** 				else if(stringBuf[mark-2] == '6'){ baud = 38400; }
 2583              		.loc 1 1193 0
 2584 140c 350053E3 		cmp	r3, #53
 2585 1410 4B3CA003 		moveq	r3, #19200
 2586 1414 0800000A 		beq	.L287
 2587              	.L240:
1194:main.c        **** 				else if(stringBuf[mark-2] == '7'){ baud = 57600; }
 2588              		.loc 1 1194 0
 2589 1418 360053E3 		cmp	r3, #54
 2590 141c 963CA003 		moveq	r3, #38400
 2591 1420 0500000A 		beq	.L287
 2592              	.L241:
1195:main.c        **** 				else if(stringBuf[mark-2] == '8'){ baud = 115200; }
 2593              		.loc 1 1195 0
 2594 1424 370053E3 		cmp	r3, #55
 2595 1428 E13CA003 		moveq	r3, #57600
 2596 142c 0200000A 		beq	.L287
 2597              	.L242:
1196:main.c        **** 
 2598              		.loc 1 1196 0
 2599 1430 380053E3 		cmp	r3, #56
 2600 1434 0100001A 		bne	.L236
1196:main.c        **** 
 2601              		.loc 1 1196 0 is_stmt 0 discriminator 1
 2602 1438 9C339FE5 		ldr	r3, .L293+52
 2603              	.L287:
 2604 143c 103085E5 		str	r3, [r5, #16]
 2605              	.L236:
1198:main.c        **** 			}
 2606              		.loc 1 1198 0 is_stmt 1
 2607 1440 98039FE5 		ldr	r0, .L293+56
 2608 1444 101095E5 		ldr	r1, [r5, #16]
 2609 1448 7D0000EA 		b	.L288
 2610              	.L234:
1200:main.c        **** 			{
 2611              		.loc 1 1200 0
 2612 144c 040057E3 		cmp	r7, #4
 2613 1450 1700001A 		bne	.L243
1202:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
 2614              		.loc 1 1202 0
 2615 1454 022056E5 		ldrb	r2, [r6, #-2]	@ zero_extendqisi2
 2616 1458 031056E5 		ldrb	r1, [r6, #-3]	@ zero_extendqisi2
 2617 145c 912323E0 		mla	r3, r1, r3, r2
1203:main.c        **** 				{
 2618              		.loc 1 1203 0
 2619 1460 042056E5 		ldrb	r2, [r6, #-4]	@ zero_extendqisi2
 2620 1464 301042E2 		sub	r1, r2, #48
1202:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
 2621              		.loc 1 1202 0
 2622 1468 213E43E2 		sub	r3, r3, #528
1203:main.c        **** 				{
 2623              		.loc 1 1203 0
 2624 146c 090051E3 		cmp	r1, #9
1202:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
 2625              		.loc 1 1202 0
 2626 1470 143085E5 		str	r3, [r5, #20]
1203:main.c        **** 				{
 2627              		.loc 1 1203 0
 2628 1474 0B00008A 		bhi	.L245
1205:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
 2629              		.loc 1 1205 0
 2630 1478 6410A0E3 		mov	r1, #100
 2631 147c 913222E0 		mla	r2, r1, r2, r3
1206:main.c        **** 				}
 2632              		.loc 1 1206 0
 2633 1480 053056E5 		ldrb	r3, [r6, #-5]	@ zero_extendqisi2
 2634 1484 301043E2 		sub	r1, r3, #48
 2635 1488 090051E3 		cmp	r1, #9
1205:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
 2636              		.loc 1 1205 0
 2637 148c 4B2D42E2 		sub	r2, r2, #4800
1206:main.c        **** 				}
 2638              		.loc 1 1206 0
 2639 1490 FA1FA093 		movls	r1, #1000
 2640 1494 91232390 		mlals	r3, r1, r3, r2
 2641 1498 BB3C4392 		subls	r3, r3, #47872
 2642 149c 80304392 		subls	r3, r3, #128
1205:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
 2643              		.loc 1 1205 0
 2644 14a0 142085E5 		str	r2, [r5, #20]
1206:main.c        **** 				}
 2645              		.loc 1 1206 0
 2646 14a4 14308595 		strls	r3, [r5, #20]
 2647              	.L245:
1208:main.c        **** 			}
 2648              		.loc 1 1208 0
 2649 14a8 34039FE5 		ldr	r0, .L293+60
 2650 14ac 141095E5 		ldr	r1, [r5, #20]
 2651 14b0 630000EA 		b	.L288
 2652              	.L243:
1210:main.c        **** 			{
 2653              		.loc 1 1210 0
 2654 14b4 050057E3 		cmp	r7, #5
1212:main.c        **** 				
 2655              		.loc 1 1212 0
 2656 14b8 02105605 		ldreqb	r1, [r6, #-2]	@ zero_extendqisi2
1214:main.c        **** 			}
 2657              		.loc 1 1214 0
 2658 14bc 24039F05 		ldreq	r0, .L293+64
1212:main.c        **** 				
 2659              		.loc 1 1212 0
 2660 14c0 0010C505 		streqb	r1, [r5, #0]
 2661 14c4 5E00000A 		beq	.L288
 2662              	.L247:
1216:main.c        **** 			{
 2663              		.loc 1 1216 0
 2664 14c8 060057E3 		cmp	r7, #6
 2665 14cc 0F00001A 		bne	.L248
1218:main.c        **** 				if(frame > 510){ frame = 510; } // up to 510 characters
 2666              		.loc 1 1218 0
 2667 14d0 022056E5 		ldrb	r2, [r6, #-2]	@ zero_extendqisi2
 2668 14d4 031056E5 		ldrb	r1, [r6, #-3]	@ zero_extendqisi2
 2669 14d8 532D42E2 		sub	r2, r2, #5312
 2670 14dc 102042E2 		sub	r2, r2, #16
 2671 14e0 932122E0 		mla	r2, r3, r1, r2
 2672 14e4 043056E5 		ldrb	r3, [r6, #-4]	@ zero_extendqisi2
 2673 14e8 6410A0E3 		mov	r1, #100
 2674 14ec 912323E0 		mla	r3, r1, r3, r2
 2675 14f0 0338A0E1 		mov	r3, r3, asl #16
1219:main.c        **** 				rprintf("frame = %d\n\r",frame);
 2676              		.loc 1 1219 0
 2677 14f4 430859E1 		cmp	r9, r3, asr #16
 2678 14f8 2328A0E1 		mov	r2, r3, lsr #16
1218:main.c        **** 				if(frame > 510){ frame = 510; } // up to 510 characters
 2679              		.loc 1 1218 0
 2680 14fc B220C5A1 		strgeh	r2, [r5, #2]	@ movhi
1219:main.c        **** 				rprintf("frame = %d\n\r",frame);
 2681              		.loc 1 1219 0
 2682 1500 B290C5B1 		strlth	r9, [r5, #2]	@ movhi
1220:main.c        **** 			}
 2683              		.loc 1 1220 0
 2684 1504 E0029FE5 		ldr	r0, .L293+68
 2685 1508 F210D5E1 		ldrsh	r1, [r5, #2]
 2686 150c 4C0000EA 		b	.L288
 2687              	.L248:
1222:main.c        **** 			{
 2688              		.loc 1 1222 0
 2689 1510 070057E3 		cmp	r7, #7
 2690 1514 0600001A 		bne	.L251
1224:main.c        **** 				if(ad0_3 == 'Y'){ temp2++; }
 2691              		.loc 1 1224 0
 2692 1518 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1225:main.c        **** 				rprintf("ad0_3 = %c\n\r",ad0_3);
 2693              		.loc 1 1225 0
 2694 151c 590051E3 		cmp	r1, #89
 2695 1520 01408402 		addeq	r4, r4, #1
 2696              	.LVL196:
1224:main.c        **** 				if(ad0_3 == 'Y'){ temp2++; }
 2697              		.loc 1 1224 0
 2698 1524 0410C5E5 		strb	r1, [r5, #4]
1225:main.c        **** 				rprintf("ad0_3 = %c\n\r",ad0_3);
 2699              		.loc 1 1225 0
 2700 1528 FF400402 		andeq	r4, r4, #255
 2701              	.LVL197:
1226:main.c        **** 			}
 2702              		.loc 1 1226 0
 2703 152c BC029FE5 		ldr	r0, .L293+72
 2704 1530 430000EA 		b	.L288
 2705              	.L251:
1228:main.c        **** 			{
 2706              		.loc 1 1228 0
 2707 1534 080057E3 		cmp	r7, #8
 2708 1538 0600001A 		bne	.L253
1230:main.c        **** 				if(ad0_2 == 'Y'){ temp2++; }
 2709              		.loc 1 1230 0
 2710 153c 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1231:main.c        **** 				rprintf("ad0_2 = %c\n\r",ad0_2);
 2711              		.loc 1 1231 0
 2712 1540 590051E3 		cmp	r1, #89
 2713 1544 01408402 		addeq	r4, r4, #1
 2714              	.LVL198:
1230:main.c        **** 				if(ad0_2 == 'Y'){ temp2++; }
 2715              		.loc 1 1230 0
 2716 1548 0610C5E5 		strb	r1, [r5, #6]
1231:main.c        **** 				rprintf("ad0_2 = %c\n\r",ad0_2);
 2717              		.loc 1 1231 0
 2718 154c FF400402 		andeq	r4, r4, #255
 2719              	.LVL199:
1232:main.c        **** 			}
 2720              		.loc 1 1232 0
 2721 1550 9C029FE5 		ldr	r0, .L293+76
 2722 1554 3A0000EA 		b	.L288
 2723              	.L253:
1234:main.c        **** 			{
 2724              		.loc 1 1234 0
 2725 1558 090057E3 		cmp	r7, #9
 2726 155c 0600001A 		bne	.L255
1236:main.c        **** 				if(ad0_1 == 'Y'){ temp2++; }
 2727              		.loc 1 1236 0
 2728 1560 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1237:main.c        **** 				rprintf("ad0_1 = %c\n\r",ad0_1);
 2729              		.loc 1 1237 0
 2730 1564 590051E3 		cmp	r1, #89
 2731 1568 01408402 		addeq	r4, r4, #1
 2732              	.LVL200:
1236:main.c        **** 				if(ad0_1 == 'Y'){ temp2++; }
 2733              		.loc 1 1236 0
 2734 156c 0710C5E5 		strb	r1, [r5, #7]
1237:main.c        **** 				rprintf("ad0_1 = %c\n\r",ad0_1);
 2735              		.loc 1 1237 0
 2736 1570 FF400402 		andeq	r4, r4, #255
 2737              	.LVL201:
1238:main.c        **** 			}
 2738              		.loc 1 1238 0
 2739 1574 7C029FE5 		ldr	r0, .L293+80
 2740 1578 310000EA 		b	.L288
 2741              	.L255:
1240:main.c        **** 			{
 2742              		.loc 1 1240 0
 2743 157c 0A0057E3 		cmp	r7, #10
 2744 1580 0600001A 		bne	.L257
1242:main.c        **** 				if(ad0_4 == 'Y'){ temp2++; }
 2745              		.loc 1 1242 0
 2746 1584 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1243:main.c        **** 				rprintf("ad0_4 = %c\n\r",ad0_4);
 2747              		.loc 1 1243 0
 2748 1588 590051E3 		cmp	r1, #89
 2749 158c 01408402 		addeq	r4, r4, #1
 2750              	.LVL202:
1242:main.c        **** 				if(ad0_4 == 'Y'){ temp2++; }
 2751              		.loc 1 1242 0
 2752 1590 0810C5E5 		strb	r1, [r5, #8]
1243:main.c        **** 				rprintf("ad0_4 = %c\n\r",ad0_4);
 2753              		.loc 1 1243 0
 2754 1594 FF400402 		andeq	r4, r4, #255
 2755              	.LVL203:
1244:main.c        **** 			}
 2756              		.loc 1 1244 0
 2757 1598 5C029FE5 		ldr	r0, .L293+84
 2758 159c 280000EA 		b	.L288
 2759              	.L257:
1246:main.c        **** 			{
 2760              		.loc 1 1246 0
 2761 15a0 0B0057E3 		cmp	r7, #11
 2762 15a4 0600001A 		bne	.L259
1248:main.c        **** 				if(ad1_7 == 'Y'){ temp2++; }
 2763              		.loc 1 1248 0
 2764 15a8 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1249:main.c        **** 				rprintf("ad1_7 = %c\n\r",ad1_7);
 2765              		.loc 1 1249 0
 2766 15ac 590051E3 		cmp	r1, #89
 2767 15b0 01408402 		addeq	r4, r4, #1
 2768              	.LVL204:
1248:main.c        **** 				if(ad1_7 == 'Y'){ temp2++; }
 2769              		.loc 1 1248 0
 2770 15b4 0910C5E5 		strb	r1, [r5, #9]
1249:main.c        **** 				rprintf("ad1_7 = %c\n\r",ad1_7);
 2771              		.loc 1 1249 0
 2772 15b8 FF400402 		andeq	r4, r4, #255
 2773              	.LVL205:
1250:main.c        **** 			}
 2774              		.loc 1 1250 0
 2775 15bc 3C029FE5 		ldr	r0, .L293+88
 2776 15c0 1F0000EA 		b	.L288
 2777              	.L259:
1252:main.c        **** 			{
 2778              		.loc 1 1252 0
 2779 15c4 0C0057E3 		cmp	r7, #12
 2780 15c8 0600001A 		bne	.L261
1254:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
 2781              		.loc 1 1254 0
 2782 15cc 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1255:main.c        **** 				rprintf("ad1_6 = %c\n\r",ad1_6);
 2783              		.loc 1 1255 0
 2784 15d0 590051E3 		cmp	r1, #89
 2785 15d4 01408402 		addeq	r4, r4, #1
 2786              	.LVL206:
1254:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
 2787              		.loc 1 1254 0
 2788 15d8 0A10C5E5 		strb	r1, [r5, #10]
1255:main.c        **** 				rprintf("ad1_6 = %c\n\r",ad1_6);
 2789              		.loc 1 1255 0
 2790 15dc FF400402 		andeq	r4, r4, #255
 2791              	.LVL207:
1256:main.c        **** 			}
 2792              		.loc 1 1256 0
 2793 15e0 1C029FE5 		ldr	r0, .L293+92
 2794 15e4 160000EA 		b	.L288
 2795              	.L261:
1258:main.c        **** 			{
 2796              		.loc 1 1258 0
 2797 15e8 0D0057E3 		cmp	r7, #13
 2798 15ec 0600001A 		bne	.L263
1260:main.c        **** 				if(ad1_2 == 'Y'){ temp2++; }
 2799              		.loc 1 1260 0
 2800 15f0 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1261:main.c        **** 				rprintf("ad1_2 = %c\n\r",ad1_2);
 2801              		.loc 1 1261 0
 2802 15f4 590051E3 		cmp	r1, #89
 2803 15f8 01408402 		addeq	r4, r4, #1
 2804              	.LVL208:
1260:main.c        **** 				if(ad1_2 == 'Y'){ temp2++; }
 2805              		.loc 1 1260 0
 2806 15fc 0B10C5E5 		strb	r1, [r5, #11]
1261:main.c        **** 				rprintf("ad1_2 = %c\n\r",ad1_2);
 2807              		.loc 1 1261 0
 2808 1600 FF400402 		andeq	r4, r4, #255
 2809              	.LVL209:
1262:main.c        **** 			}
 2810              		.loc 1 1262 0
 2811 1604 FC019FE5 		ldr	r0, .L293+96
 2812 1608 0D0000EA 		b	.L288
 2813              	.L263:
1264:main.c        **** 			{
 2814              		.loc 1 1264 0
 2815 160c 0E0057E3 		cmp	r7, #14
 2816 1610 0600001A 		bne	.L265
1266:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
 2817              		.loc 1 1266 0
 2818 1614 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1267:main.c        **** 				rprintf("ad1_3 = %c\n\r",ad1_3);
 2819              		.loc 1 1267 0
 2820 1618 590051E3 		cmp	r1, #89
 2821 161c 01408402 		addeq	r4, r4, #1
 2822              	.LVL210:
1266:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
 2823              		.loc 1 1266 0
 2824 1620 0C10C5E5 		strb	r1, [r5, #12]
1267:main.c        **** 				rprintf("ad1_3 = %c\n\r",ad1_3);
 2825              		.loc 1 1267 0
 2826 1624 FF400402 		andeq	r4, r4, #255
 2827              	.LVL211:
1268:main.c        **** 			}
 2828              		.loc 1 1268 0
 2829 1628 DC019FE5 		ldr	r0, .L293+100
 2830 162c 040000EA 		b	.L288
 2831              	.L265:
1270:main.c        **** 			{
 2832              		.loc 1 1270 0
 2833 1630 0F0057E3 		cmp	r7, #15
 2834 1634 0300001A 		bne	.L231
1272:main.c        **** 				rprintf("safety = %c\n\r",safety);
 2835              		.loc 1 1272 0
 2836 1638 028056E5 		ldrb	r8, [r6, #-2]	@ zero_extendqisi2
 2837              	.LVL212:
1273:main.c        **** 			}
 2838              		.loc 1 1273 0
 2839 163c CC019FE5 		ldr	r0, .L293+104
 2840 1640 0810A0E1 		mov	r1, r8
 2841              	.LVL213:
 2842              	.L288:
 2843 1644 FEFFFFEB 		bl	rprintf
 2844              	.LVL214:
 2845              	.L231:
1166:main.c        **** 	{
 2846              		.loc 1 1166 0
 2847 1648 01A08AE2 		add	sl, sl, #1
 2848              	.LVL215:
 2849              	.L230:
1166:main.c        **** 	{
 2850              		.loc 1 1166 0 is_stmt 0 discriminator 1
 2851 164c 00309BE5 		ldr	r3, [fp, #0]
 2852 1650 03005AE1 		cmp	sl, r3
 2853 1654 4BFFFFBA 		blt	.L267
1278:main.c        **** 	{
 2854              		.loc 1 1278 0 is_stmt 1
 2855 1658 590058E3 		cmp	r8, #89
 2856 165c 4D00001A 		bne	.L268
1280:main.c        **** 		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
 2857              		.loc 1 1280 0
 2858 1660 0A0054E3 		cmp	r4, #10
 2859 1664 0500001A 		bne	.L269
1280:main.c        **** 		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
 2860              		.loc 1 1280 0 is_stmt 0 discriminator 1
 2861 1668 58319FE5 		ldr	r3, .L293+32
 2862 166c 142093E5 		ldr	r2, [r3, #20]
 2863 1670 960052E3 		cmp	r2, #150
 2864 1674 9620A0C3 		movgt	r2, #150
 2865 1678 070000CA 		bgt	.L289
 2866 167c 470000EA 		b	.L225
 2867              	.L269:
1281:main.c        **** 		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
 2868              		.loc 1 1281 0 is_stmt 1
 2869 1680 090054E3 		cmp	r4, #9
 2870 1684 0600001A 		bne	.L272
1281:main.c        **** 		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
 2871              		.loc 1 1281 0 is_stmt 0 discriminator 1
 2872 1688 38319FE5 		ldr	r3, .L293+32
 2873 168c 142093E5 		ldr	r2, [r3, #20]
 2874 1690 A60052E3 		cmp	r2, #166
 2875 1694 410000DA 		ble	.L225
 2876 1698 A620A0E3 		mov	r2, #166
 2877              	.L289:
 2878 169c 142083E5 		str	r2, [r3, #20]
 2879 16a0 3E0000EA 		b	.L225
 2880              	.L272:
1282:main.c        **** 		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
 2881              		.loc 1 1282 0 is_stmt 1
 2882 16a4 080054E3 		cmp	r4, #8
 2883 16a8 0500001A 		bne	.L273
1282:main.c        **** 		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
 2884              		.loc 1 1282 0 is_stmt 0 discriminator 1
 2885 16ac 14319FE5 		ldr	r3, .L293+32
 2886 16b0 142093E5 		ldr	r2, [r3, #20]
 2887 16b4 BB0052E3 		cmp	r2, #187
 2888 16b8 BB20A0C3 		movgt	r2, #187
 2889 16bc F6FFFFCA 		bgt	.L289
 2890 16c0 360000EA 		b	.L225
 2891              	.L273:
1283:main.c        **** 		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
 2892              		.loc 1 1283 0 is_stmt 1
 2893 16c4 070054E3 		cmp	r4, #7
 2894 16c8 0500001A 		bne	.L275
1283:main.c        **** 		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
 2895              		.loc 1 1283 0 is_stmt 0 discriminator 1
 2896 16cc F4309FE5 		ldr	r3, .L293+32
 2897 16d0 142093E5 		ldr	r2, [r3, #20]
 2898 16d4 D60052E3 		cmp	r2, #214
 2899 16d8 D620A0C3 		movgt	r2, #214
 2900 16dc EEFFFFCA 		bgt	.L289
 2901 16e0 2E0000EA 		b	.L225
 2902              	.L275:
1284:main.c        **** 		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
 2903              		.loc 1 1284 0 is_stmt 1
 2904 16e4 060054E3 		cmp	r4, #6
 2905 16e8 0500001A 		bne	.L270
1284:main.c        **** 		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
 2906              		.loc 1 1284 0 is_stmt 0 discriminator 1
 2907 16ec D4309FE5 		ldr	r3, .L293+32
 2908 16f0 142093E5 		ldr	r2, [r3, #20]
 2909 16f4 FA0052E3 		cmp	r2, #250
 2910 16f8 FA20A0C3 		movgt	r2, #250
 2911 16fc E6FFFFCA 		bgt	.L289
 2912 1700 260000EA 		b	.L225
 2913              	.L270:
1285:main.c        **** 		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
 2914              		.loc 1 1285 0 is_stmt 1
 2915 1704 050054E3 		cmp	r4, #5
 2916 1708 0500001A 		bne	.L278
1285:main.c        **** 		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
 2917              		.loc 1 1285 0 is_stmt 0 discriminator 1
 2918 170c B4309FE5 		ldr	r3, .L293+32
 2919 1710 142093E5 		ldr	r2, [r3, #20]
 2920 1714 4B0F52E3 		cmp	r2, #300
 2921 1718 4B2FA0C3 		movgt	r2, #300
 2922 171c DEFFFFCA 		bgt	.L289
 2923 1720 1E0000EA 		b	.L225
 2924              	.L278:
1286:main.c        **** 		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
 2925              		.loc 1 1286 0 is_stmt 1
 2926 1724 040054E3 		cmp	r4, #4
1286:main.c        **** 		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
 2927              		.loc 1 1286 0 is_stmt 0 discriminator 1
 2928 1728 98309F05 		ldreq	r3, .L293+32
 2929 172c E0209F05 		ldreq	r2, .L293+108
 2930 1730 0F00000A 		beq	.L291
 2931              	.L274:
1287:main.c        **** 		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
 2932              		.loc 1 1287 0 is_stmt 1
 2933 1734 030054E3 		cmp	r4, #3
 2934 1738 0500001A 		bne	.L276
1287:main.c        **** 		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
 2935              		.loc 1 1287 0 is_stmt 0 discriminator 1
 2936 173c 84309FE5 		ldr	r3, .L293+32
 2937 1740 142093E5 		ldr	r2, [r3, #20]
 2938 1744 7D0F52E3 		cmp	r2, #500
 2939 1748 7D2FA0C3 		movgt	r2, #500
 2940 174c D2FFFFCA 		bgt	.L289
 2941 1750 120000EA 		b	.L225
 2942              	.L276:
1288:main.c        **** 		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
 2943              		.loc 1 1288 0 is_stmt 1
 2944 1754 020054E3 		cmp	r4, #2
1288:main.c        **** 		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
 2945              		.loc 1 1288 0 is_stmt 0 discriminator 1
 2946 1758 68309F05 		ldreq	r3, .L293+32
 2947 175c B4209F05 		ldreq	r2, .L293+112
 2948 1760 0300000A 		beq	.L291
 2949              	.L277:
1289:main.c        **** 		else if((temp2 == 0)){ freq = 100; }
 2950              		.loc 1 1289 0 is_stmt 1
 2951 1764 010054E3 		cmp	r4, #1
 2952 1768 0500001A 		bne	.L279
1289:main.c        **** 		else if((temp2 == 0)){ freq = 100; }
 2953              		.loc 1 1289 0 is_stmt 0 discriminator 1
 2954 176c 54309FE5 		ldr	r3, .L293+32
 2955 1770 A4209FE5 		ldr	r2, .L293+116
 2956              	.L291:
 2957 1774 141093E5 		ldr	r1, [r3, #20]
 2958 1778 020051E1 		cmp	r1, r2
 2959 177c 070000DA 		ble	.L225
 2960 1780 C5FFFFEA 		b	.L289
 2961              	.L279:
1290:main.c        **** 	}
 2962              		.loc 1 1290 0 is_stmt 1
 2963 1784 000054E3 		cmp	r4, #0
 2964 1788 0400001A 		bne	.L225
1290:main.c        **** 	}
 2965              		.loc 1 1290 0 is_stmt 0 discriminator 1
 2966 178c 6420A0E3 		mov	r2, #100
 2967 1790 30309FE5 		ldr	r3, .L293+32
 2968 1794 C0FFFFEA 		b	.L289
 2969              	.L268:
1293:main.c        **** 
 2970              		.loc 1 1293 0 is_stmt 1
 2971 1798 540058E3 		cmp	r8, #84
1293:main.c        **** 
 2972              		.loc 1 1293 0 is_stmt 0 discriminator 1
 2973 179c FEFFFF0B 		bleq	test
 2974              	.LVL216:
 2975              	.L225:
1295:main.c        **** 
 2976              		.loc 1 1295 0 is_stmt 1
 2977 17a0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2978 17a4 1EFF2FE1 		bx	lr
 2979              	.L294:
 2980              		.align	2
 2981              	.L293:
 2982 17a8 B7000000 		.word	.LC8
 2983 17ac 00000000 		.word	fd
 2984 17b0 00000000 		.word	stringBuf
 2985 17b4 00000000 		.word	stringSize
 2986 17b8 C2000000 		.word	.LC9
 2987 17bc 008002E0 		.word	-536707072
 2988 17c0 ED000000 		.word	.LC10
 2989 17c4 FFFFFFFF 		.word	stringBuf-1
 2990 17c8 00000000 		.word	.LANCHOR1
 2991 17cc FE010000 		.word	510
 2992 17d0 00000000 		.word	.LANCHOR0
 2993 17d4 AE010000 		.word	.LC11
 2994 17d8 BA010000 		.word	.LC12
 2995 17dc 00C20100 		.word	115200
 2996 17e0 C5010000 		.word	.LC13
 2997 17e4 D1010000 		.word	.LC14
 2998 17e8 DD010000 		.word	.LC15
 2999 17ec E9010000 		.word	.LC16
 3000 17f0 F6010000 		.word	.LC17
 3001 17f4 03020000 		.word	.LC18
 3002 17f8 10020000 		.word	.LC19
 3003 17fc 1D020000 		.word	.LC20
 3004 1800 2A020000 		.word	.LC21
 3005 1804 37020000 		.word	.LC22
 3006 1808 44020000 		.word	.LC23
 3007 180c 51020000 		.word	.LC24
 3008 1810 5E020000 		.word	.LC25
 3009 1814 77010000 		.word	375
 3010 1818 EE020000 		.word	750
 3011 181c DC050000 		.word	1500
 3012              		.cfi_endproc
 3013              	.LFE11:
 3015              		.align	2
 3016              		.global	GetADCValue
 3018              	GetADCValue:
 3019              	.LFB22:
1600:main.c        **** 
1601:main.c        **** /********************** LogADC *****************************
1602:main.c        **** *  Called each time GPS data is logged to generate ADC data
1603:main.c        **** * and log it
1604:main.c        **** ************************************************************/
1605:main.c        **** void LogADC(void)
1606:main.c        **** {
1607:main.c        **** 	
1608:main.c        **** 	// reset TMR0 interrupt
1609:main.c        **** 	T0IR = 1;
1610:main.c        **** 	
1611:main.c        **** 	// reset ADC log buffer pointer to beginning
1612:main.c        **** 	ADC_in = 0;
1613:main.c        **** 	
1614:main.c        **** 	// get the time
1615:main.c        **** 	GetTime();
1616:main.c        **** 	ADC_array[ADC_in] = time_buffer[0];
1617:main.c        **** 	ADC_in++; //1
1618:main.c        **** 	ADC_array[ADC_in] = time_buffer[1];
1619:main.c        **** 	ADC_in++; //2
1620:main.c        **** 	ADC_array[ADC_in] = time_buffer[2];
1621:main.c        **** 	ADC_in++; //3
1622:main.c        **** 	ADC_array[ADC_in] = time_buffer[3];
1623:main.c        **** 	ADC_in++; //4
1624:main.c        **** 	ADC_array[ADC_in] = time_buffer[4];
1625:main.c        **** 	ADC_in++; //5
1626:main.c        **** 	ADC_array[ADC_in] = time_buffer[5];
1627:main.c        **** 	ADC_in++; //6
1628:main.c        **** 	ADC_array[ADC_in] = time_buffer[6];
1629:main.c        **** 	ADC_in++; //7
1630:main.c        **** 	ADC_array[ADC_in] = time_buffer[7];
1631:main.c        **** 	ADC_in++; //8
1632:main.c        **** 	ADC_array[ADC_in] = ',';
1633:main.c        **** 	ADC_in++; //9
1634:main.c        **** 
1635:main.c        **** 	//ADC_1 - ad0_3
1636:main.c        **** 	if(ad0_3 == 'Y')
1637:main.c        **** 		GetADCValue(ADC_1);
1638:main.c        **** 		
1639:main.c        **** 	// ADC_2 - ad0_2
1640:main.c        **** 	if(ad0_2 == 'Y')
1641:main.c        **** 		GetADCValue(ADC_2);
1642:main.c        **** 	
1643:main.c        **** 	// ADC_3 - ad0_1
1644:main.c        **** 	if(ad0_1 == 'Y')
1645:main.c        **** 		GetADCValue(ADC_3);
1646:main.c        **** 	
1647:main.c        **** 	// ADC_4 - ad0_4
1648:main.c        **** 	if(ad0_4 == 'Y')
1649:main.c        **** 		GetADCValue(ADC_4);
1650:main.c        **** 	
1651:main.c        **** 	// ADC_5 - ad1_7
1652:main.c        **** 	if(ad1_7 == 'Y')
1653:main.c        **** 		GetADCValue(ADC_5);
1654:main.c        **** 		
1655:main.c        **** 	// ADC_6 - ad1_6
1656:main.c        **** 	if(ad1_6 == 'Y')
1657:main.c        **** 		GetADCValue(ADC_6);
1658:main.c        **** 		
1659:main.c        **** 	// ADC_7 - ad1_2
1660:main.c        **** 	if(ad1_2 == 'Y')
1661:main.c        **** 		GetADCValue(ADC_7);
1662:main.c        **** 		
1663:main.c        **** 	// ADC_8 - ad1_3
1664:main.c        **** 	if(ad1_3 == 'Y')
1665:main.c        **** 		GetADCValue(ADC_8);
1666:main.c        **** 		
1667:main.c        **** 	// if no ADC pins were chosen then write that
1668:main.c        **** 	// if ADC pins were chosen there is a trailing ',' that should be
1669:main.c        **** 	// removed
1670:main.c        **** 	if(ADC_in == 9)	// no ADC pins were selected for reading
1671:main.c        **** 	{
1672:main.c        **** 		// write a warning message (ADC + GPS was chosen but not used)
1673:main.c        **** 		ADC_array[ADC_in] = 'N';
1674:main.c        **** 		ADC_in++;
1675:main.c        **** 		ADC_array[ADC_in] = 'O';
1676:main.c        **** 		ADC_in++;
1677:main.c        **** 		ADC_array[ADC_in] = ' ';
1678:main.c        **** 		ADC_in++;
1679:main.c        **** 		ADC_array[ADC_in] = 'A';
1680:main.c        **** 		ADC_in++;
1681:main.c        **** 		ADC_array[ADC_in] = 'D';
1682:main.c        **** 		ADC_in++;
1683:main.c        **** 		ADC_array[ADC_in] = 'C';
1684:main.c        **** 		ADC_in++;
1685:main.c        **** 	}
1686:main.c        **** 	else
1687:main.c        **** 	{
1688:main.c        **** 		ADC_in--;	// back up over trailing ','
1689:main.c        **** 	}
1690:main.c        **** 		
1691:main.c        **** 	// add CR/LF and string terminator
1692:main.c        **** 	ADC_array[ADC_in] = 13;
1693:main.c        **** 	ADC_in++;
1694:main.c        **** 	ADC_array[ADC_in] = 10;
1695:main.c        **** 	ADC_in++;
1696:main.c        **** 			
1697:main.c        **** 	VICVectAddr= 0;
1698:main.c        **** 	
1699:main.c        **** 	// set microSD write size
1700:main.c        **** 	ADCStringSize = ADC_in;
1701:main.c        **** 	// set ADC logging flag
1702:main.c        **** 	log_adc = 1;
1703:main.c        **** }
1704:main.c        **** 
1705:main.c        **** /****************************** GetADCValue ******************************
1706:main.c        **** *	Retrieves an ADC value for the ADC pin in 'adc.'
1707:main.c        **** *************************************************************************/
1708:main.c        **** void GetADCValue(int adc)
1709:main.c        **** {
 3020              		.loc 1 1709 0
 3021              		.cfi_startproc
 3022              		@ Function supports interworking.
 3023              		@ args = 0, pretend = 0, frame = 4
 3024              		@ frame_needed = 0, uses_anonymous_args = 0
 3025              	.LVL217:
 3026 1820 11402DE9 		stmfd	sp!, {r0, r4, lr}
 3027              	.LCFI11:
 3028              		.cfi_def_cfa_offset 12
 3029              		.cfi_offset 0, -12
 3030              		.cfi_offset 4, -8
 3031              		.cfi_offset 14, -4
1710:main.c        **** 	int temp;	// holds 16-bit ADC value (includes some flag bits)
1711:main.c        **** 	int temp2;	// holds converted (necessary bit shift) ADC value
1712:main.c        **** 	char temp_buff[4];	// holds ascii ADC value - needed for int -> char conversion
1713:main.c        **** 	short a;	// used to convert ADC value for writing as text if NOT using ASCII
1714:main.c        **** 	
1715:main.c        **** 	/************************ ADxCR & ADxDR *******************************
1716:main.c        **** 	*   ADxCR is the ADC control register, LPC2148 has two ADxCRs
1717:main.c        **** 	*   AD0CR and AD1CR
1718:main.c        **** 	*   ADxDR is the ADC global data register
1719:main.c        **** 	*	ADxCR bits 0 to 7 are the pin select bits (zero based, so ADx.0
1720:main.c        **** 	*   would be 0000 0001 NOT 0000 0000)
1721:main.c        **** 	*   ADxCR bits 8 to 15 is the clock divisor (+1) and must produce
1722:main.c        **** 	*   a value <= 4.5Mhz
1723:main.c        **** 	*   ADxCR bit 16 is for burst (repeated conversions = 1, controlled
1724:main.c        **** 	*   conversions = 0)
1725:main.c        **** 	*   ADxCR bits 17 to 19 sets the number of 'clocks' used for ADC
1726:main.c        **** 	*   conversion 000 = 11 clocks = 10 bit ADC down to 111 =
1727:main.c        **** 	*   4 clocks = 3 bit ADC
1728:main.c        **** 	*   ADxCR bit 21 powers up the ADC (1 = power up, 0 = power down)
1729:main.c        **** 	*   ADxCR bits 24 to 27 are used in burst mode
1730:main.c        **** 	*   ADxCR all other bits are reserved
1731:main.c        **** 	*   ADxDR bits 6 to 15 are the ADC results
1732:main.c        **** 	*   ADxDR bits 24 to 26 are the channel the results came from
1733:main.c        **** 	*   ADxDR bit 30 indicates an overrun (a data value was overwritten by
1734:main.c        **** 	*     this ADC conversion)
1735:main.c        **** 	*   ADxDR bit 31 indicates that the ADC conversion is done
1736:main.c        **** 	*********************************************************************/
1737:main.c        **** 	
1738:main.c        **** 	temp = 0;	// initialize to zero so MSB can't possibly be set (breaks ADC read)
1739:main.c        **** 	
1740:main.c        **** 	switch (adc)
 3032              		.loc 1 1740 0
 3033 1824 010040E2 		sub	r0, r0, #1
 3034              	.LVL218:
 3035 1828 070050E3 		cmp	r0, #7
 3036 182c 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 3037 1830 640000EA 		b	.L296
 3038              	.L305:
 3039 1834 54180000 		.word	.L297
 3040 1838 80180000 		.word	.L298
 3041 183c AC180000 		.word	.L299
 3042 1840 D8180000 		.word	.L300
 3043 1844 0C190000 		.word	.L301
 3044 1848 38190000 		.word	.L302
 3045 184c 64190000 		.word	.L303
 3046 1850 90190000 		.word	.L304
 3047              	.L297:
1741:main.c        **** 	{
1742:main.c        **** 		// AD0.3
1743:main.c        **** 		case ADC_1:
1744:main.c        **** 			AD0CR = 0x00020FF08; // AD0.3 (0x00020FF00 = 
 3048              		.loc 1 1744 0
 3049 1854 FC329FE5 		ldr	r3, .L335
 3050 1858 FC229FE5 		ldr	r2, .L335+4
 3051 185c 002083E5 		str	r2, [r3, #0]
1745:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3052              		.loc 1 1745 0
 3053 1860 002093E5 		ldr	r2, [r3, #0]
 3054 1864 012482E3 		orr	r2, r2, #16777216
 3055 1868 002083E5 		str	r2, [r3, #0]
 3056 186c 0320A0E1 		mov	r2, r3
 3057              	.LVL219:
 3058              	.L306:
1746:main.c        **** 			while((temp & 0x80000000) == 0)	// wait for ADC to finish conversion
1747:main.c        **** 			{
1748:main.c        **** 				temp = AD0DR;
 3059              		.loc 1 1748 0
 3060 1870 043092E5 		ldr	r3, [r2, #4]
 3061              	.LVL220:
1746:main.c        **** 			while((temp & 0x80000000) == 0)	// wait for ADC to finish conversion
 3062              		.loc 1 1746 0
 3063 1874 000053E3 		cmp	r3, #0
 3064 1878 FCFFFFAA 		bge	.L306
 3065 187c 1F0000EA 		b	.L334
 3066              	.LVL221:
 3067              	.L298:
1749:main.c        **** 			}				
1750:main.c        **** 			AD0CR = 0x00000000;	// stop ADC conversion			
1751:main.c        **** 			break;
1752:main.c        **** 			
1753:main.c        **** 		// AD0.2	
1754:main.c        **** 		case ADC_2:
1755:main.c        **** 			AD0CR = 0x00020FF04; // AD0.2
 3068              		.loc 1 1755 0
 3069 1880 D0329FE5 		ldr	r3, .L335
 3070 1884 D4229FE5 		ldr	r2, .L335+8
 3071 1888 002083E5 		str	r2, [r3, #0]
1756:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3072              		.loc 1 1756 0
 3073 188c 002093E5 		ldr	r2, [r3, #0]
 3074 1890 012482E3 		orr	r2, r2, #16777216
 3075 1894 002083E5 		str	r2, [r3, #0]
 3076 1898 0320A0E1 		mov	r2, r3
 3077              	.LVL222:
 3078              	.L308:
1757:main.c        **** 			while((temp & 0x80000000) == 0)
1758:main.c        **** 			{
1759:main.c        **** 				temp = AD0DR;
 3079              		.loc 1 1759 0
 3080 189c 043092E5 		ldr	r3, [r2, #4]
 3081              	.LVL223:
1757:main.c        **** 			while((temp & 0x80000000) == 0)
 3082              		.loc 1 1757 0
 3083 18a0 000053E3 		cmp	r3, #0
 3084 18a4 FCFFFFAA 		bge	.L308
 3085 18a8 140000EA 		b	.L334
 3086              	.LVL224:
 3087              	.L299:
1760:main.c        **** 			}
1761:main.c        **** 			AD0CR = 0x00000000;		
1762:main.c        **** 		break;
1763:main.c        **** 		
1764:main.c        **** 		// AD0.1
1765:main.c        **** 		case ADC_3:
1766:main.c        **** 			AD0CR = 0x00020FF02; // AD0.1
 3088              		.loc 1 1766 0
 3089 18ac A4329FE5 		ldr	r3, .L335
 3090 18b0 AC229FE5 		ldr	r2, .L335+12
 3091 18b4 002083E5 		str	r2, [r3, #0]
1767:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3092              		.loc 1 1767 0
 3093 18b8 002093E5 		ldr	r2, [r3, #0]
 3094 18bc 012482E3 		orr	r2, r2, #16777216
 3095 18c0 002083E5 		str	r2, [r3, #0]
 3096 18c4 0320A0E1 		mov	r2, r3
 3097              	.LVL225:
 3098              	.L309:
1768:main.c        **** 			while((temp & 0x80000000) == 0)
1769:main.c        **** 			{
1770:main.c        **** 				temp = AD0DR;
 3099              		.loc 1 1770 0
 3100 18c8 043092E5 		ldr	r3, [r2, #4]
 3101              	.LVL226:
1768:main.c        **** 			while((temp & 0x80000000) == 0)
 3102              		.loc 1 1768 0
 3103 18cc 000053E3 		cmp	r3, #0
 3104 18d0 FCFFFFAA 		bge	.L309
 3105 18d4 090000EA 		b	.L334
 3106              	.LVL227:
 3107              	.L300:
1771:main.c        **** 			}
1772:main.c        **** 			AD0CR = 0x00000000;		
1773:main.c        **** 		break;
1774:main.c        **** 		
1775:main.c        **** 		// AD0.4
1776:main.c        **** 		case ADC_4:
1777:main.c        **** 			AD0CR = 0x00020FF10; // AD0.4
 3108              		.loc 1 1777 0
 3109 18d8 78329FE5 		ldr	r3, .L335
 3110 18dc 84229FE5 		ldr	r2, .L335+16
 3111 18e0 002083E5 		str	r2, [r3, #0]
1778:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3112              		.loc 1 1778 0
 3113 18e4 002093E5 		ldr	r2, [r3, #0]
 3114 18e8 012482E3 		orr	r2, r2, #16777216
 3115 18ec 002083E5 		str	r2, [r3, #0]
 3116 18f0 0320A0E1 		mov	r2, r3
 3117              	.LVL228:
 3118              	.L310:
1779:main.c        **** 			while((temp & 0x80000000) == 0)
1780:main.c        **** 			{
1781:main.c        **** 				temp = AD0DR;
 3119              		.loc 1 1781 0
 3120 18f4 043092E5 		ldr	r3, [r2, #4]
 3121              	.LVL229:
1779:main.c        **** 			while((temp & 0x80000000) == 0)
 3122              		.loc 1 1779 0
 3123 18f8 000053E3 		cmp	r3, #0
 3124 18fc FCFFFFAA 		bge	.L310
 3125              	.L334:
1782:main.c        **** 			}
1783:main.c        **** 			AD0CR = 0x00000000;		
 3126              		.loc 1 1783 0
 3127 1900 0010A0E3 		mov	r1, #0
 3128 1904 4C229FE5 		ldr	r2, .L335
 3129 1908 2C0000EA 		b	.L332
 3130              	.LVL230:
 3131              	.L301:
1784:main.c        **** 		break;
1785:main.c        **** 		
1786:main.c        **** 		// AD1.7
1787:main.c        **** 		case ADC_5:
1788:main.c        **** 			AD1CR = 0x00020FF80; // AD1.7
 3132              		.loc 1 1788 0
 3133 190c 58329FE5 		ldr	r3, .L335+20
 3134 1910 58229FE5 		ldr	r2, .L335+24
 3135 1914 002083E5 		str	r2, [r3, #0]
1789:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3136              		.loc 1 1789 0
 3137 1918 002093E5 		ldr	r2, [r3, #0]
 3138 191c 012482E3 		orr	r2, r2, #16777216
 3139 1920 002083E5 		str	r2, [r3, #0]
 3140 1924 0320A0E1 		mov	r2, r3
 3141              	.LVL231:
 3142              	.L311:
1790:main.c        **** 			while((temp & 0x80000000) == 0)
1791:main.c        **** 			{
1792:main.c        **** 				temp = AD1DR;
 3143              		.loc 1 1792 0
 3144 1928 043092E5 		ldr	r3, [r2, #4]
 3145              	.LVL232:
1790:main.c        **** 			while((temp & 0x80000000) == 0)
 3146              		.loc 1 1790 0
 3147 192c 000053E3 		cmp	r3, #0
 3148 1930 FCFFFFAA 		bge	.L311
 3149 1934 1F0000EA 		b	.L331
 3150              	.LVL233:
 3151              	.L302:
1793:main.c        **** 			}
1794:main.c        **** 			AD1CR = 0x00000000;		
1795:main.c        **** 		break;
1796:main.c        **** 		
1797:main.c        **** 		// AD1.6
1798:main.c        **** 		case ADC_6:
1799:main.c        **** 			AD1CR = 0x00020FF40; // AD1.6
 3152              		.loc 1 1799 0
 3153 1938 2C329FE5 		ldr	r3, .L335+20
 3154 193c 30229FE5 		ldr	r2, .L335+28
 3155 1940 002083E5 		str	r2, [r3, #0]
1800:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3156              		.loc 1 1800 0
 3157 1944 002093E5 		ldr	r2, [r3, #0]
 3158 1948 012482E3 		orr	r2, r2, #16777216
 3159 194c 002083E5 		str	r2, [r3, #0]
 3160 1950 0320A0E1 		mov	r2, r3
 3161              	.LVL234:
 3162              	.L312:
1801:main.c        **** 			while((temp & 0x80000000) == 0)
1802:main.c        **** 			{
1803:main.c        **** 				temp = AD1DR;
 3163              		.loc 1 1803 0
 3164 1954 043092E5 		ldr	r3, [r2, #4]
 3165              	.LVL235:
1801:main.c        **** 			while((temp & 0x80000000) == 0)
 3166              		.loc 1 1801 0
 3167 1958 000053E3 		cmp	r3, #0
 3168 195c FCFFFFAA 		bge	.L312
 3169 1960 140000EA 		b	.L331
 3170              	.LVL236:
 3171              	.L303:
1804:main.c        **** 			}
1805:main.c        **** 			AD1CR = 0x00000000;		
1806:main.c        **** 		break;
1807:main.c        **** 		
1808:main.c        **** 		// AD1.2
1809:main.c        **** 		case ADC_7:
1810:main.c        **** 			AD1CR = 0x00020FF04; // AD1.2
 3172              		.loc 1 1810 0
 3173 1964 00329FE5 		ldr	r3, .L335+20
 3174 1968 F0219FE5 		ldr	r2, .L335+8
 3175 196c 002083E5 		str	r2, [r3, #0]
1811:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3176              		.loc 1 1811 0
 3177 1970 002093E5 		ldr	r2, [r3, #0]
 3178 1974 012482E3 		orr	r2, r2, #16777216
 3179 1978 002083E5 		str	r2, [r3, #0]
 3180 197c 0320A0E1 		mov	r2, r3
 3181              	.LVL237:
 3182              	.L313:
1812:main.c        **** 			while((temp & 0x80000000) == 0)
1813:main.c        **** 			{
1814:main.c        **** 				temp = AD1DR;
 3183              		.loc 1 1814 0
 3184 1980 043092E5 		ldr	r3, [r2, #4]
 3185              	.LVL238:
1812:main.c        **** 			while((temp & 0x80000000) == 0)
 3186              		.loc 1 1812 0
 3187 1984 000053E3 		cmp	r3, #0
 3188 1988 FCFFFFAA 		bge	.L313
 3189 198c 090000EA 		b	.L331
 3190              	.LVL239:
 3191              	.L304:
1815:main.c        **** 			}
1816:main.c        **** 			AD1CR = 0x00000000;
1817:main.c        **** 		break;
1818:main.c        **** 		
1819:main.c        **** 		// AD1.3
1820:main.c        **** 		case ADC_8:
1821:main.c        **** 			AD1CR = 0x00020FF08; // AD1.3
 3192              		.loc 1 1821 0
 3193 1990 D4319FE5 		ldr	r3, .L335+20
 3194 1994 C0219FE5 		ldr	r2, .L335+4
 3195 1998 002083E5 		str	r2, [r3, #0]
1822:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3196              		.loc 1 1822 0
 3197 199c 002093E5 		ldr	r2, [r3, #0]
 3198 19a0 012482E3 		orr	r2, r2, #16777216
 3199 19a4 002083E5 		str	r2, [r3, #0]
 3200 19a8 0320A0E1 		mov	r2, r3
 3201              	.LVL240:
 3202              	.L314:
1823:main.c        **** 			while((temp & 0x80000000) == 0)
1824:main.c        **** 			{
1825:main.c        **** 				temp = AD1DR;
 3203              		.loc 1 1825 0
 3204 19ac 043092E5 		ldr	r3, [r2, #4]
 3205              	.LVL241:
1823:main.c        **** 			while((temp & 0x80000000) == 0)
 3206              		.loc 1 1823 0
 3207 19b0 000053E3 		cmp	r3, #0
 3208 19b4 FCFFFFAA 		bge	.L314
 3209              	.L331:
1826:main.c        **** 			}
1827:main.c        **** 			AD1CR = 0x00000000;	
 3210              		.loc 1 1827 0
 3211 19b8 AC219FE5 		ldr	r2, .L335+20
 3212 19bc 0010A0E3 		mov	r1, #0
 3213              	.L332:
 3214 19c0 001082E5 		str	r1, [r2, #0]
1828:main.c        **** 		break;
 3215              		.loc 1 1828 0
 3216 19c4 0F0000EA 		b	.L307
 3217              	.LVL242:
 3218              	.L296:
1829:main.c        **** 		
1830:main.c        **** 		// should never get here - logic error
1831:main.c        **** 		default:
1832:main.c        **** 			ADC_array[ADC_in] = 'e';
 3219              		.loc 1 1832 0
 3220 19c8 A8119FE5 		ldr	r1, .L335+32
 3221 19cc B630D1E1 		ldrh	r3, [r1, #6]
 3222 19d0 A4219FE5 		ldr	r2, .L335+36
 3223 19d4 0308A0E1 		mov	r0, r3, asl #16
 3224              	.LVL243:
 3225 19d8 65C0A0E3 		mov	ip, #101
 3226 19dc 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1833:main.c        **** 			ADC_in++;
 3227              		.loc 1 1833 0
 3228 19e0 01C083E2 		add	ip, r3, #1
1834:main.c        **** 			ADC_array[ADC_in] = 'r';
 3229              		.loc 1 1834 0
 3230 19e4 0CC8A0E1 		mov	ip, ip, asl #16
 3231 19e8 7200A0E3 		mov	r0, #114
 3232 19ec 4C08C2E7 		strb	r0, [r2, ip, asr #16]
1835:main.c        **** 			ADC_in++;
 3233              		.loc 1 1835 0
 3234 19f0 02C083E2 		add	ip, r3, #2
1836:main.c        **** 			ADC_array[ADC_in] = 'r';
 3235              		.loc 1 1836 0
 3236 19f4 0CC8A0E1 		mov	ip, ip, asl #16
1837:main.c        **** 			ADC_in++;
 3237              		.loc 1 1837 0
 3238 19f8 033083E2 		add	r3, r3, #3
1836:main.c        **** 			ADC_array[ADC_in] = 'r';
 3239              		.loc 1 1836 0
 3240 19fc 4C08C2E7 		strb	r0, [r2, ip, asr #16]
 3241              		.loc 1 1837 0
 3242 1a00 B630C1E1 		strh	r3, [r1, #6]	@ movhi
 3243 1a04 510000EA 		b	.L295
 3244              	.LVL244:
 3245              	.L307:
1838:main.c        **** 			return;
1839:main.c        **** 		break;
1840:main.c        **** 	}
1841:main.c        **** 	
1842:main.c        **** 	//	convert ADC value - bit shift required (some bits are flags, not part
1843:main.c        **** 	//  of actual ADC value) 15:6 create the 10 bit ADC value
1844:main.c        **** 	temp &= 0x0000FFC0;	// strip all bits except 15:6
 3246              		.loc 1 1844 0
 3247 1a08 70019FE5 		ldr	r0, .L335+40
 3248 1a0c 000003E0 		and	r0, r3, r0
 3249              	.LVL245:
1845:main.c        **** 	temp2 = temp / 0x00000040; // shift bit right 6 places
1846:main.c        **** 
1847:main.c        **** 	// convert value to characters
1848:main.c        **** 	
1849:main.c        **** 	if(asc == 'Y' || asc ==',')
 3250              		.loc 1 1849 0
 3251 1a10 6C319FE5 		ldr	r3, .L335+44
 3252 1a14 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 3253 1a18 590053E3 		cmp	r3, #89
 3254 1a1c 2C005313 		cmpne	r3, #44
1845:main.c        **** 	temp2 = temp / 0x00000040; // shift bit right 6 places
 3255              		.loc 1 1845 0
 3256 1a20 4003A0E1 		mov	r0, r0, asr #6
 3257              	.LVL246:
 3258              		.loc 1 1849 0
 3259 1a24 3C00001A 		bne	.L316
1850:main.c        **** 	{
1851:main.c        **** 		itoa(temp2, 10, temp_buff);
 3260              		.loc 1 1851 0
 3261 1a28 0A10A0E3 		mov	r1, #10
 3262 1a2c 0D20A0E1 		mov	r2, sp
 3263 1a30 FEFFFFEB 		bl	itoa
 3264              	.LVL247:
1852:main.c        **** 		if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 3265              		.loc 1 1852 0
 3266 1a34 0010DDE5 		ldrb	r1, [sp, #0]	@ zero_extendqisi2
 3267 1a38 303041E2 		sub	r3, r1, #48
 3268 1a3c 090053E3 		cmp	r3, #9
 3269 1a40 0600008A 		bhi	.L317
1853:main.c        **** 		{
1854:main.c        **** 			ADC_array[ADC_in] = temp_buff[0];
 3270              		.loc 1 1854 0
 3271 1a44 2C319FE5 		ldr	r3, .L335+32
 3272 1a48 B620D3E1 		ldrh	r2, [r3, #6]
 3273 1a4c 28019FE5 		ldr	r0, .L335+36
 3274 1a50 02C8A0E1 		mov	ip, r2, asl #16
1855:main.c        **** 			ADC_in++;
 3275              		.loc 1 1855 0
 3276 1a54 012082E2 		add	r2, r2, #1
1854:main.c        **** 			ADC_in++;
 3277              		.loc 1 1854 0
 3278 1a58 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3279              		.loc 1 1855 0
 3280 1a5c B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3281              	.L317:
1856:main.c        **** 		}
1857:main.c        **** 		if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 3282              		.loc 1 1857 0
 3283 1a60 0110DDE5 		ldrb	r1, [sp, #1]	@ zero_extendqisi2
 3284 1a64 303041E2 		sub	r3, r1, #48
 3285 1a68 090053E3 		cmp	r3, #9
 3286 1a6c 0600008A 		bhi	.L318
1858:main.c        **** 		{
1859:main.c        **** 			ADC_array[ADC_in] = temp_buff[1];
 3287              		.loc 1 1859 0
 3288 1a70 00319FE5 		ldr	r3, .L335+32
 3289 1a74 B620D3E1 		ldrh	r2, [r3, #6]
 3290 1a78 FC009FE5 		ldr	r0, .L335+36
 3291 1a7c 02C8A0E1 		mov	ip, r2, asl #16
1860:main.c        **** 			ADC_in++;
 3292              		.loc 1 1860 0
 3293 1a80 012082E2 		add	r2, r2, #1
1859:main.c        **** 			ADC_in++;
 3294              		.loc 1 1859 0
 3295 1a84 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3296              		.loc 1 1860 0
 3297 1a88 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3298              	.L318:
1861:main.c        **** 		}
1862:main.c        **** 		if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 3299              		.loc 1 1862 0
 3300 1a8c 0210DDE5 		ldrb	r1, [sp, #2]	@ zero_extendqisi2
 3301 1a90 303041E2 		sub	r3, r1, #48
 3302 1a94 090053E3 		cmp	r3, #9
 3303 1a98 0600008A 		bhi	.L319
1863:main.c        **** 		{
1864:main.c        **** 			ADC_array[ADC_in] = temp_buff[2];
 3304              		.loc 1 1864 0
 3305 1a9c D4309FE5 		ldr	r3, .L335+32
 3306 1aa0 B620D3E1 		ldrh	r2, [r3, #6]
 3307 1aa4 D0009FE5 		ldr	r0, .L335+36
 3308 1aa8 02C8A0E1 		mov	ip, r2, asl #16
1865:main.c        **** 			ADC_in++;
 3309              		.loc 1 1865 0
 3310 1aac 012082E2 		add	r2, r2, #1
1864:main.c        **** 			ADC_in++;
 3311              		.loc 1 1864 0
 3312 1ab0 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3313              		.loc 1 1865 0
 3314 1ab4 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3315              	.L319:
1866:main.c        **** 		}
1867:main.c        **** 		if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 3316              		.loc 1 1867 0
 3317 1ab8 0310DDE5 		ldrb	r1, [sp, #3]	@ zero_extendqisi2
 3318 1abc 303041E2 		sub	r3, r1, #48
 3319 1ac0 090053E3 		cmp	r3, #9
 3320 1ac4 0600008A 		bhi	.L320
1868:main.c        **** 		{
1869:main.c        **** 			ADC_array[ADC_in] = temp_buff[3];
 3321              		.loc 1 1869 0
 3322 1ac8 A8309FE5 		ldr	r3, .L335+32
 3323 1acc B620D3E1 		ldrh	r2, [r3, #6]
 3324 1ad0 A4009FE5 		ldr	r0, .L335+36
 3325 1ad4 02C8A0E1 		mov	ip, r2, asl #16
1870:main.c        **** 			ADC_in++;
 3326              		.loc 1 1870 0
 3327 1ad8 012082E2 		add	r2, r2, #1
1869:main.c        **** 			ADC_in++;
 3328              		.loc 1 1869 0
 3329 1adc 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3330              		.loc 1 1870 0
 3331 1ae0 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3332              	.L320:
1871:main.c        **** 		}
1872:main.c        **** 
1873:main.c        **** 		if(asc == ',')
 3333              		.loc 1 1873 0
 3334 1ae4 98309FE5 		ldr	r3, .L335+44
 3335 1ae8 0500D3E5 		ldrb	r0, [r3, #5]	@ zero_extendqisi2
 3336 1aec 84309FE5 		ldr	r3, .L335+32
1874:main.c        **** 		{
1875:main.c        **** 			ADC_array[ADC_in] = ',';
 3337              		.loc 1 1875 0
 3338 1af0 B620D3E1 		ldrh	r2, [r3, #6]
1873:main.c        **** 		{
 3339              		.loc 1 1873 0
 3340 1af4 2C0050E3 		cmp	r0, #44
 3341 1af8 7C109FE5 		ldr	r1, .L335+36
 3342              		.loc 1 1875 0
 3343 1afc 02C8A001 		moveq	ip, r2, asl #16
1876:main.c        **** 			ADC_in++;
1877:main.c        **** 		}
1878:main.c        **** 		else
1879:main.c        **** 		{
1880:main.c        **** 			ADC_array[ADC_in] = 0;
 3344              		.loc 1 1880 0
 3345 1b00 0208A011 		movne	r0, r2, asl #16
 3346 1b04 00C0A013 		movne	ip, #0
1881:main.c        **** 			ADC_in++;
 3347              		.loc 1 1881 0
 3348 1b08 012082E2 		add	r2, r2, #1
1875:main.c        **** 			ADC_in++;
 3349              		.loc 1 1875 0
 3350 1b0c 4C08C107 		streqb	r0, [r1, ip, asr #16]
1880:main.c        **** 			ADC_in++;
 3351              		.loc 1 1880 0
 3352 1b10 40C8C117 		strneb	ip, [r1, r0, asr #16]
 3353              		.loc 1 1881 0
 3354 1b14 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3355 1b18 0C0000EA 		b	.L295
 3356              	.LVL248:
 3357              	.L316:
1882:main.c        **** 		}
1883:main.c        **** 	}
1884:main.c        **** 	else if(asc == 'N')
 3358              		.loc 1 1884 0
 3359 1b1c 4E0053E3 		cmp	r3, #78
 3360 1b20 0A00001A 		bne	.L295
 3361              	.LVL249:
1885:main.c        **** 	{
1886:main.c        **** 		a = ((short)temp2 & 0xFF00) / 0x00000100;
1887:main.c        **** 		ADC_array[ADC_in] = (char)a;
 3362              		.loc 1 1887 0
 3363 1b24 4C209FE5 		ldr	r2, .L335+32
 3364 1b28 B630D2E1 		ldrh	r3, [r2, #6]
 3365 1b2c 48109FE5 		ldr	r1, .L335+36
 3366 1b30 03C8A0E1 		mov	ip, r3, asl #16
1886:main.c        **** 		ADC_array[ADC_in] = (char)a;
 3367              		.loc 1 1886 0
 3368 1b34 2044A0E1 		mov	r4, r0, lsr #8
 3369              		.loc 1 1887 0
 3370 1b38 4C48C1E7 		strb	r4, [r1, ip, asr #16]
1888:main.c        **** 		ADC_in++;
 3371              		.loc 1 1888 0
 3372 1b3c 01C083E2 		add	ip, r3, #1
1889:main.c        **** 		ADC_array[ADC_in] = (char)temp2 & 0xFF;
 3373              		.loc 1 1889 0
 3374 1b40 0CC8A0E1 		mov	ip, ip, asl #16
1890:main.c        **** 		ADC_in++;
 3375              		.loc 1 1890 0
 3376 1b44 023083E2 		add	r3, r3, #2
1889:main.c        **** 		ADC_array[ADC_in] = (char)temp2 & 0xFF;
 3377              		.loc 1 1889 0
 3378 1b48 4C08C1E7 		strb	r0, [r1, ip, asr #16]
 3379              		.loc 1 1890 0
 3380 1b4c B630C2E1 		strh	r3, [r2, #6]	@ movhi
 3381              	.LVL250:
 3382              	.L295:
1891:main.c        **** 	}
1892:main.c        **** }
 3383              		.loc 1 1892 0
 3384 1b50 1840BDE8 		ldmfd	sp!, {r3, r4, lr}
 3385 1b54 1EFF2FE1 		bx	lr
 3386              	.L336:
 3387              		.align	2
 3388              	.L335:
 3389 1b58 004003E0 		.word	-536657920
 3390 1b5c 08FF2000 		.word	2162440
 3391 1b60 04FF2000 		.word	2162436
 3392 1b64 02FF2000 		.word	2162434
 3393 1b68 10FF2000 		.word	2162448
 3394 1b6c 000006E0 		.word	-536477696
 3395 1b70 80FF2000 		.word	2162560
 3396 1b74 40FF2000 		.word	2162496
 3397 1b78 00000000 		.word	.LANCHOR0
 3398 1b7c 00000000 		.word	ADC_array
 3399 1b80 C0FF0000 		.word	65472
 3400 1b84 00000000 		.word	.LANCHOR1
 3401              		.cfi_endproc
 3402              	.LFE22:
 3404              		.align	2
 3405              		.global	InitializeTime
 3407              	InitializeTime:
 3408              	.LFB23:
1893:main.c        **** 
1894:main.c        **** void InitializeTime(void)
1895:main.c        **** {
 3409              		.loc 1 1895 0
 3410              		.cfi_startproc
 3411              		@ Function supports interworking.
 3412              		@ args = 0, pretend = 0, frame = 0
 3413              		@ frame_needed = 0, uses_anonymous_args = 0
 3414              		@ link register save eliminated.
1896:main.c        **** 	CCR = 0x02;	// set current time
 3415              		.loc 1 1896 0
 3416 1b88 20309FE5 		ldr	r3, .L338
 3417 1b8c 0220A0E3 		mov	r2, #2
 3418 1b90 0820C3E5 		strb	r2, [r3, #8]
1897:main.c        **** 	SEC = 0;
 3419              		.loc 1 1897 0
 3420 1b94 0020A0E3 		mov	r2, #0
 3421 1b98 2020C3E5 		strb	r2, [r3, #32]
1898:main.c        **** 	MIN = 0;
 3422              		.loc 1 1898 0
 3423 1b9c 2420C3E5 		strb	r2, [r3, #36]
1899:main.c        **** 	HOUR = 0;
 3424              		.loc 1 1899 0
 3425 1ba0 2820C3E5 		strb	r2, [r3, #40]
1900:main.c        **** 	CCR = 0x11;
 3426              		.loc 1 1900 0
 3427 1ba4 1120A0E3 		mov	r2, #17
 3428 1ba8 0820C3E5 		strb	r2, [r3, #8]
 3429 1bac 1EFF2FE1 		bx	lr
 3430              	.L339:
 3431              		.align	2
 3432              	.L338:
 3433 1bb0 004002E0 		.word	-536723456
 3434              		.cfi_endproc
 3435              	.LFE23:
 3437              		.align	2
 3438              		.global	GetTime
 3440              	GetTime:
 3441              	.LFB24:
1901:main.c        **** }
1902:main.c        **** 
1903:main.c        **** void GetTime(void)
1904:main.c        **** {
 3442              		.loc 1 1904 0
 3443              		.cfi_startproc
 3444              		@ Function supports interworking.
 3445              		@ args = 0, pretend = 0, frame = 0
 3446              		@ frame_needed = 0, uses_anonymous_args = 0
 3447 1bb4 01402DE9 		stmfd	sp!, {r0, lr}
 3448              	.LCFI12:
 3449              		.cfi_def_cfa_offset 8
 3450              		.cfi_offset 0, -8
 3451              		.cfi_offset 14, -4
1905:main.c        **** 	hours = HOUR;
 3452              		.loc 1 1905 0
 3453 1bb8 44109FE5 		ldr	r1, .L341
 3454 1bbc 2820D1E5 		ldrb	r2, [r1, #40]	@ zero_extendqisi2
 3455 1bc0 40309FE5 		ldr	r3, .L341+4
 3456 1bc4 FF2002E2 		and	r2, r2, #255
 3457 1bc8 002083E5 		str	r2, [r3, #0]
1906:main.c        **** 	minutes = MIN;
 3458              		.loc 1 1906 0
 3459 1bcc 2430D1E5 		ldrb	r3, [r1, #36]	@ zero_extendqisi2
 3460 1bd0 34009FE5 		ldr	r0, .L341+8
 3461 1bd4 FF3003E2 		and	r3, r3, #255
 3462 1bd8 003080E5 		str	r3, [r0, #0]
1907:main.c        **** 	seconds = SEC;
 3463              		.loc 1 1907 0
 3464 1bdc 2010D1E5 		ldrb	r1, [r1, #32]	@ zero_extendqisi2
 3465 1be0 28009FE5 		ldr	r0, .L341+12
 3466 1be4 FF1001E2 		and	r1, r1, #255
 3467 1be8 001080E5 		str	r1, [r0, #0]
1908:main.c        **** 	sprintf(time_buffer,"%02d:%02d:%02d", hours, minutes, seconds);
 3468              		.loc 1 1908 0
 3469 1bec 00108DE5 		str	r1, [sp, #0]
 3470 1bf0 1C009FE5 		ldr	r0, .L341+16
 3471 1bf4 1C109FE5 		ldr	r1, .L341+20
 3472 1bf8 FEFFFFEB 		bl	sprintf
 3473              	.LVL251:
1909:main.c        **** }
 3474              		.loc 1 1909 0
 3475 1bfc 0840BDE8 		ldmfd	sp!, {r3, lr}
 3476 1c00 1EFF2FE1 		bx	lr
 3477              	.L342:
 3478              		.align	2
 3479              	.L341:
 3480 1c04 004002E0 		.word	-536723456
 3481 1c08 00000000 		.word	hours
 3482 1c0c 00000000 		.word	minutes
 3483 1c10 00000000 		.word	seconds
 3484 1c14 00000000 		.word	time_buffer
 3485 1c18 6C020000 		.word	.LC26
 3486              		.cfi_endproc
 3487              	.LFE24:
 3489              		.align	2
 3490              		.global	LogADC
 3492              	LogADC:
 3493              	.LFB21:
1606:main.c        **** 	
 3494              		.loc 1 1606 0
 3495              		.cfi_startproc
 3496              		@ Function supports interworking.
 3497              		@ args = 0, pretend = 0, frame = 0
 3498              		@ frame_needed = 0, uses_anonymous_args = 0
1609:main.c        **** 	
 3499              		.loc 1 1609 0
 3500 1c1c 04329FE5 		ldr	r3, .L355
1606:main.c        **** 	
 3501              		.loc 1 1606 0
 3502 1c20 30402DE9 		stmfd	sp!, {r4, r5, lr}
 3503              	.LCFI13:
 3504              		.cfi_def_cfa_offset 12
 3505              		.cfi_offset 4, -12
 3506              		.cfi_offset 5, -8
 3507              		.cfi_offset 14, -4
1612:main.c        **** 	
 3508              		.loc 1 1612 0
 3509 1c24 00429FE5 		ldr	r4, .L355+4
1609:main.c        **** 	
 3510              		.loc 1 1609 0
 3511 1c28 0150A0E3 		mov	r5, #1
 3512 1c2c 005083E5 		str	r5, [r3, #0]
1612:main.c        **** 	
 3513              		.loc 1 1612 0
 3514 1c30 0030A0E3 		mov	r3, #0
 3515 1c34 B630C4E1 		strh	r3, [r4, #6]	@ movhi
1615:main.c        **** 	ADC_array[ADC_in] = time_buffer[0];
 3516              		.loc 1 1615 0
 3517 1c38 FEFFFFEB 		bl	GetTime
 3518              	.LVL252:
1616:main.c        **** 	ADC_in++; //1
 3519              		.loc 1 1616 0
 3520 1c3c EC119FE5 		ldr	r1, .L355+8
 3521 1c40 B630D4E1 		ldrh	r3, [r4, #6]
 3522 1c44 E8219FE5 		ldr	r2, .L355+12
 3523 1c48 00C0D1E5 		ldrb	ip, [r1, #0]	@ zero_extendqisi2
 3524 1c4c 0308A0E1 		mov	r0, r3, asl #16
 3525 1c50 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1618:main.c        **** 	ADC_in++; //2
 3526              		.loc 1 1618 0
 3527 1c54 01C0D1E5 		ldrb	ip, [r1, #1]	@ zero_extendqisi2
1617:main.c        **** 	ADC_array[ADC_in] = time_buffer[1];
 3528              		.loc 1 1617 0
 3529 1c58 050083E0 		add	r0, r3, r5
1618:main.c        **** 	ADC_in++; //2
 3530              		.loc 1 1618 0
 3531 1c5c 0008A0E1 		mov	r0, r0, asl #16
 3532 1c60 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1620:main.c        **** 	ADC_in++; //3
 3533              		.loc 1 1620 0
 3534 1c64 02C0D1E5 		ldrb	ip, [r1, #2]	@ zero_extendqisi2
1619:main.c        **** 	ADC_array[ADC_in] = time_buffer[2];
 3535              		.loc 1 1619 0
 3536 1c68 020083E2 		add	r0, r3, #2
1620:main.c        **** 	ADC_in++; //3
 3537              		.loc 1 1620 0
 3538 1c6c 0008A0E1 		mov	r0, r0, asl #16
 3539 1c70 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1622:main.c        **** 	ADC_in++; //4
 3540              		.loc 1 1622 0
 3541 1c74 03C0D1E5 		ldrb	ip, [r1, #3]	@ zero_extendqisi2
1621:main.c        **** 	ADC_array[ADC_in] = time_buffer[3];
 3542              		.loc 1 1621 0
 3543 1c78 030083E2 		add	r0, r3, #3
1622:main.c        **** 	ADC_in++; //4
 3544              		.loc 1 1622 0
 3545 1c7c 0008A0E1 		mov	r0, r0, asl #16
 3546 1c80 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1624:main.c        **** 	ADC_in++; //5
 3547              		.loc 1 1624 0
 3548 1c84 04C0D1E5 		ldrb	ip, [r1, #4]	@ zero_extendqisi2
1623:main.c        **** 	ADC_array[ADC_in] = time_buffer[4];
 3549              		.loc 1 1623 0
 3550 1c88 040083E2 		add	r0, r3, #4
1624:main.c        **** 	ADC_in++; //5
 3551              		.loc 1 1624 0
 3552 1c8c 0008A0E1 		mov	r0, r0, asl #16
 3553 1c90 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1626:main.c        **** 	ADC_in++; //6
 3554              		.loc 1 1626 0
 3555 1c94 05C0D1E5 		ldrb	ip, [r1, #5]	@ zero_extendqisi2
1625:main.c        **** 	ADC_array[ADC_in] = time_buffer[5];
 3556              		.loc 1 1625 0
 3557 1c98 050083E2 		add	r0, r3, #5
1626:main.c        **** 	ADC_in++; //6
 3558              		.loc 1 1626 0
 3559 1c9c 0008A0E1 		mov	r0, r0, asl #16
 3560 1ca0 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1627:main.c        **** 	ADC_array[ADC_in] = time_buffer[6];
 3561              		.loc 1 1627 0
 3562 1ca4 060083E2 		add	r0, r3, #6
1628:main.c        **** 	ADC_in++; //7
 3563              		.loc 1 1628 0
 3564 1ca8 06C0D1E5 		ldrb	ip, [r1, #6]	@ zero_extendqisi2
 3565 1cac 0008A0E1 		mov	r0, r0, asl #16
 3566 1cb0 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1630:main.c        **** 	ADC_in++; //8
 3567              		.loc 1 1630 0
 3568 1cb4 0710D1E5 		ldrb	r1, [r1, #7]	@ zero_extendqisi2
1629:main.c        **** 	ADC_array[ADC_in] = time_buffer[7];
 3569              		.loc 1 1629 0
 3570 1cb8 070083E2 		add	r0, r3, #7
1630:main.c        **** 	ADC_in++; //8
 3571              		.loc 1 1630 0
 3572 1cbc 0008A0E1 		mov	r0, r0, asl #16
 3573 1cc0 4018C2E7 		strb	r1, [r2, r0, asr #16]
1631:main.c        **** 	ADC_array[ADC_in] = ',';
 3574              		.loc 1 1631 0
 3575 1cc4 081083E2 		add	r1, r3, #8
1633:main.c        **** 
 3576              		.loc 1 1633 0
 3577 1cc8 093083E2 		add	r3, r3, #9
 3578 1ccc B630C4E1 		strh	r3, [r4, #6]	@ movhi
1636:main.c        **** 		GetADCValue(ADC_1);
 3579              		.loc 1 1636 0
 3580 1cd0 60419FE5 		ldr	r4, .L355+16
 3581 1cd4 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
1632:main.c        **** 	ADC_in++; //9
 3582              		.loc 1 1632 0
 3583 1cd8 0118A0E1 		mov	r1, r1, asl #16
 3584 1cdc 2C00A0E3 		mov	r0, #44
1636:main.c        **** 		GetADCValue(ADC_1);
 3585              		.loc 1 1636 0
 3586 1ce0 590053E3 		cmp	r3, #89
1632:main.c        **** 	ADC_in++; //9
 3587              		.loc 1 1632 0
 3588 1ce4 4108C2E7 		strb	r0, [r2, r1, asr #16]
1636:main.c        **** 		GetADCValue(ADC_1);
 3589              		.loc 1 1636 0
1637:main.c        **** 		
 3590              		.loc 1 1637 0
 3591 1ce8 0500A001 		moveq	r0, r5
 3592 1cec FEFFFF0B 		bleq	GetADCValue
 3593              	.LVL253:
 3594              	.L344:
1640:main.c        **** 		GetADCValue(ADC_2);
 3595              		.loc 1 1640 0
 3596 1cf0 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3597 1cf4 590053E3 		cmp	r3, #89
1641:main.c        **** 	
 3598              		.loc 1 1641 0
 3599 1cf8 0200A003 		moveq	r0, #2
 3600 1cfc FEFFFF0B 		bleq	GetADCValue
 3601              	.LVL254:
 3602              	.L345:
1644:main.c        **** 		GetADCValue(ADC_3);
 3603              		.loc 1 1644 0
 3604 1d00 0730D4E5 		ldrb	r3, [r4, #7]	@ zero_extendqisi2
 3605 1d04 590053E3 		cmp	r3, #89
1645:main.c        **** 	
 3606              		.loc 1 1645 0
 3607 1d08 0300A003 		moveq	r0, #3
 3608 1d0c FEFFFF0B 		bleq	GetADCValue
 3609              	.LVL255:
 3610              	.L346:
1648:main.c        **** 		GetADCValue(ADC_4);
 3611              		.loc 1 1648 0
 3612 1d10 20419FE5 		ldr	r4, .L355+16
 3613 1d14 0830D4E5 		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 3614 1d18 590053E3 		cmp	r3, #89
1649:main.c        **** 	
 3615              		.loc 1 1649 0
 3616 1d1c 0400A003 		moveq	r0, #4
 3617 1d20 FEFFFF0B 		bleq	GetADCValue
 3618              	.LVL256:
 3619              	.L347:
1652:main.c        **** 		GetADCValue(ADC_5);
 3620              		.loc 1 1652 0
 3621 1d24 0930D4E5 		ldrb	r3, [r4, #9]	@ zero_extendqisi2
 3622 1d28 590053E3 		cmp	r3, #89
1653:main.c        **** 		
 3623              		.loc 1 1653 0
 3624 1d2c 0500A003 		moveq	r0, #5
 3625 1d30 FEFFFF0B 		bleq	GetADCValue
 3626              	.LVL257:
 3627              	.L348:
1656:main.c        **** 		GetADCValue(ADC_6);
 3628              		.loc 1 1656 0
 3629 1d34 0A30D4E5 		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 3630 1d38 590053E3 		cmp	r3, #89
1657:main.c        **** 		
 3631              		.loc 1 1657 0
 3632 1d3c 0600A003 		moveq	r0, #6
 3633 1d40 FEFFFF0B 		bleq	GetADCValue
 3634              	.LVL258:
 3635              	.L349:
1660:main.c        **** 		GetADCValue(ADC_7);
 3636              		.loc 1 1660 0
 3637 1d44 EC309FE5 		ldr	r3, .L355+16
 3638 1d48 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 3639 1d4c 590052E3 		cmp	r2, #89
 3640 1d50 0340A0E1 		mov	r4, r3
1661:main.c        **** 		
 3641              		.loc 1 1661 0
 3642 1d54 0700A003 		moveq	r0, #7
 3643 1d58 FEFFFF0B 		bleq	GetADCValue
 3644              	.LVL259:
 3645              	.L350:
1664:main.c        **** 		GetADCValue(ADC_8);
 3646              		.loc 1 1664 0
 3647 1d5c 0C30D4E5 		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 3648 1d60 590053E3 		cmp	r3, #89
1665:main.c        **** 		
 3649              		.loc 1 1665 0
 3650 1d64 0800A003 		moveq	r0, #8
 3651 1d68 FEFFFF0B 		bleq	GetADCValue
 3652              	.LVL260:
 3653              	.L351:
1670:main.c        **** 	{
 3654              		.loc 1 1670 0
 3655 1d6c B8209FE5 		ldr	r2, .L355+4
 3656 1d70 F610D2E1 		ldrsh	r1, [r2, #6]
 3657 1d74 B630D2E1 		ldrh	r3, [r2, #6]
 3658 1d78 090051E3 		cmp	r1, #9
1688:main.c        **** 	}
 3659              		.loc 1 1688 0
 3660 1d7c 01304312 		subne	r3, r3, #1
1670:main.c        **** 	{
 3661              		.loc 1 1670 0
 3662 1d80 0E00001A 		bne	.L354
1673:main.c        **** 		ADC_in++;
 3663              		.loc 1 1673 0
 3664 1d84 A8309FE5 		ldr	r3, .L355+12
 3665 1d88 4E10A0E3 		mov	r1, #78
 3666 1d8c 0910C3E5 		strb	r1, [r3, #9]
1675:main.c        **** 		ADC_in++;
 3667              		.loc 1 1675 0
 3668 1d90 4F10A0E3 		mov	r1, #79
 3669 1d94 0A10C3E5 		strb	r1, [r3, #10]
1677:main.c        **** 		ADC_in++;
 3670              		.loc 1 1677 0
 3671 1d98 2010A0E3 		mov	r1, #32
 3672 1d9c 0B10C3E5 		strb	r1, [r3, #11]
1679:main.c        **** 		ADC_in++;
 3673              		.loc 1 1679 0
 3674 1da0 4110A0E3 		mov	r1, #65
 3675 1da4 0C10C3E5 		strb	r1, [r3, #12]
1681:main.c        **** 		ADC_in++;
 3676              		.loc 1 1681 0
 3677 1da8 4410A0E3 		mov	r1, #68
 3678 1dac 0D10C3E5 		strb	r1, [r3, #13]
1683:main.c        **** 		ADC_in++;
 3679              		.loc 1 1683 0
 3680 1db0 4310A0E3 		mov	r1, #67
 3681 1db4 0E10C3E5 		strb	r1, [r3, #14]
1684:main.c        **** 	}
 3682              		.loc 1 1684 0
 3683 1db8 0F30A0E3 		mov	r3, #15
 3684 1dbc FFFFFFEA 		b	.L354
 3685              	.L354:
1688:main.c        **** 	}
 3686              		.loc 1 1688 0
 3687 1dc0 B630C2E1 		strh	r3, [r2, #6]	@ movhi
1692:main.c        **** 	ADC_in++;
 3688              		.loc 1 1692 0
 3689 1dc4 60309FE5 		ldr	r3, .L355+4
 3690 1dc8 B620D3E1 		ldrh	r2, [r3, #6]
 3691 1dcc 60109FE5 		ldr	r1, .L355+12
 3692 1dd0 0208A0E1 		mov	r0, r2, asl #16
 3693 1dd4 0DC0A0E3 		mov	ip, #13
 3694 1dd8 40C8C1E7 		strb	ip, [r1, r0, asr #16]
1693:main.c        **** 	ADC_array[ADC_in] = 10;
 3695              		.loc 1 1693 0
 3696 1ddc 010082E2 		add	r0, r2, #1
1695:main.c        **** 			
 3697              		.loc 1 1695 0
 3698 1de0 022082E2 		add	r2, r2, #2
1694:main.c        **** 	ADC_in++;
 3699              		.loc 1 1694 0
 3700 1de4 0008A0E1 		mov	r0, r0, asl #16
 3701 1de8 0AC0A0E3 		mov	ip, #10
1695:main.c        **** 			
 3702              		.loc 1 1695 0
 3703 1dec 0228A0E1 		mov	r2, r2, asl #16
1694:main.c        **** 	ADC_in++;
 3704              		.loc 1 1694 0
 3705 1df0 40C8C1E7 		strb	ip, [r1, r0, asr #16]
1695:main.c        **** 			
 3706              		.loc 1 1695 0
 3707 1df4 2228A0E1 		mov	r2, r2, lsr #16
1697:main.c        **** 	
 3708              		.loc 1 1697 0
 3709 1df8 0010E0E3 		mvn	r1, #0
 3710 1dfc 0000A0E3 		mov	r0, #0
1695:main.c        **** 			
 3711              		.loc 1 1695 0
 3712 1e00 B620C3E1 		strh	r2, [r3, #6]	@ movhi
1697:main.c        **** 	
 3713              		.loc 1 1697 0
 3714 1e04 CF0F01E5 		str	r0, [r1, #-4047]
1700:main.c        **** 	// set ADC logging flag
 3715              		.loc 1 1700 0
 3716 1e08 0228A0E1 		mov	r2, r2, asl #16
 3717 1e0c 28109FE5 		ldr	r1, .L355+20
 3718 1e10 4228A0E1 		mov	r2, r2, asr #16
 3719 1e14 002081E5 		str	r2, [r1, #0]
1702:main.c        **** }
 3720              		.loc 1 1702 0
 3721 1e18 0120A0E3 		mov	r2, #1
 3722 1e1c 0820C3E5 		strb	r2, [r3, #8]
1703:main.c        **** 
 3723              		.loc 1 1703 0
 3724 1e20 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 3725 1e24 1EFF2FE1 		bx	lr
 3726              	.L356:
 3727              		.align	2
 3728              	.L355:
 3729 1e28 004000E0 		.word	-536854528
 3730 1e2c 00000000 		.word	.LANCHOR0
 3731 1e30 00000000 		.word	time_buffer
 3732 1e34 00000000 		.word	ADC_array
 3733 1e38 00000000 		.word	.LANCHOR1
 3734 1e3c 00000000 		.word	ADCStringSize
 3735              		.cfi_endproc
 3736              	.LFE21:
 3738              		.align	2
 3739              		.global	mode_action
 3741              	mode_action:
 3742              	.LFB16:
1388:main.c        **** 	int j;
 3743              		.loc 1 1388 0
 3744              		.cfi_startproc
 3745              		@ Function supports interworking.
 3746              		@ args = 0, pretend = 0, frame = 0
 3747              		@ frame_needed = 0, uses_anonymous_args = 0
 3748 1e40 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 3749              	.LCFI14:
 3750              		.cfi_def_cfa_offset 20
 3751              		.cfi_offset 4, -20
 3752              		.cfi_offset 5, -16
 3753              		.cfi_offset 6, -12
 3754              		.cfi_offset 7, -8
 3755              		.cfi_offset 14, -4
1394:main.c        **** 		{
 3756              		.loc 1 1394 0
 3757 1e44 D4519FE5 		ldr	r5, .L391
 3758              	.LBB143:
 3759              	.LBB144:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3760              		.loc 1 1123 0
 3761 1e48 D4419FE5 		ldr	r4, .L391+4
 3762              	.LBE144:
 3763              	.LBE143:
1398:main.c        **** 			{
 3764              		.loc 1 1398 0
 3765 1e4c D4619FE5 		ldr	r6, .L391+8
 3766              	.L375:
1394:main.c        **** 		{
 3767              		.loc 1 1394 0
 3768 1e50 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 3769 1e54 010053E3 		cmp	r3, #1
 3770 1e58 1A00001A 		bne	.L358
 3771              	.LVL261:
1398:main.c        **** 			{
 3772              		.loc 1 1398 0
 3773 1e5c C8319FE5 		ldr	r3, .L391+12
 3774              	.LBB146:
 3775              	.LBB145:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3776              		.loc 1 1123 0
 3777 1e60 0470A0E3 		mov	r7, #4
 3778 1e64 0C7084E5 		str	r7, [r4, #12]
 3779              	.LBE145:
 3780              	.LBE146:
1398:main.c        **** 			{
 3781              		.loc 1 1398 0
 3782 1e68 000096E5 		ldr	r0, [r6, #0]
 3783 1e6c BC119FE5 		ldr	r1, .L391+16
 3784 1e70 002093E5 		ldr	r2, [r3, #0]
 3785 1e74 FEFFFFEB 		bl	fat_write_file
 3786              	.LVL262:
 3787 1e78 000050E3 		cmp	r0, #0
 3788 1e7c 0D0000AA 		bge	.L359
 3789              	.LBB147:
 3790              	.LBB148:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3791              		.loc 1 1123 0
 3792 1e80 9C319FE5 		ldr	r3, .L391+4
 3793              	.LBE148:
 3794              	.LBE147:
 3795              	.LBB150:
 3796              	.LBB151:
 3797              	.LBB152:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3798              		.loc 1 1118 0
 3799 1e84 020BA0E3 		mov	r0, #2048
 3800 1e88 0310A0E1 		mov	r1, r3
 3801              	.L386:
 3802              	.LVL263:
 3803              	.LBE152:
 3804              	.LBE151:
 3805              	.LBE150:
 3806              	.LBB155:
 3807              	.LBB149:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3808              		.loc 1 1123 0
 3809 1e8c 0C7083E5 		str	r7, [r3, #12]
 3810              	.LVL264:
 3811 1e90 9C219FE5 		ldr	r2, .L391+20
 3812              	.LVL265:
 3813              	.L360:
 3814              	.LBE149:
 3815              	.LBE155:
1403:main.c        **** 					stat(0,OFF);
 3816              		.loc 1 1403 0
 3817 1e94 012052E2 		subs	r2, r2, #1
 3818              	.LBB156:
 3819              	.LBB157:
1124:main.c        **** 	}
 3820              		.loc 1 1124 0
 3821 1e98 047081E5 		str	r7, [r1, #4]
 3822              	.LBE157:
 3823              	.LBE156:
1403:main.c        **** 					stat(0,OFF);
 3824              		.loc 1 1403 0
 3825 1e9c FCFFFF1A 		bne	.L360
 3826              	.LVL266:
 3827              	.LBB158:
 3828              	.LBB154:
 3829              	.LBB153:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3830              		.loc 1 1118 0
 3831 1ea0 0C0081E5 		str	r0, [r1, #12]
 3832              	.LVL267:
 3833 1ea4 88219FE5 		ldr	r2, .L391+20
 3834              	.LVL268:
 3835              	.L361:
 3836              	.LBE153:
 3837              	.LBE154:
 3838              	.LBE158:
1406:main.c        **** 					stat(1,OFF);
 3839              		.loc 1 1406 0
 3840 1ea8 012052E2 		subs	r2, r2, #1
 3841              	.LBB159:
 3842              	.LBB160:
 3843              	.LBB161:
1119:main.c        **** 	}
 3844              		.loc 1 1119 0
 3845 1eac 040083E5 		str	r0, [r3, #4]
 3846              	.LBE161:
 3847              	.LBE160:
 3848              	.LBE159:
1406:main.c        **** 					stat(1,OFF);
 3849              		.loc 1 1406 0
 3850 1eb0 FCFFFF1A 		bne	.L361
 3851 1eb4 F4FFFFEA 		b	.L386
 3852              	.LVL269:
 3853              	.L359:
1411:main.c        **** 			stat(0,OFF);
 3854              		.loc 1 1411 0
 3855 1eb8 FEFFFFEB 		bl	sd_raw_sync
 3856              	.LVL270:
1413:main.c        **** 		}
 3857              		.loc 1 1413 0
 3858 1ebc 0030A0E3 		mov	r3, #0
 3859              	.LBB162:
 3860              	.LBB163:
1124:main.c        **** 	}
 3861              		.loc 1 1124 0
 3862 1ec0 047084E5 		str	r7, [r4, #4]
 3863              	.LBE163:
 3864              	.LBE162:
1413:main.c        **** 		}
 3865              		.loc 1 1413 0
 3866 1ec4 0230C5E5 		strb	r3, [r5, #2]
 3867              	.LVL271:
 3868              	.L358:
1417:main.c        **** 		{
 3869              		.loc 1 1417 0
 3870 1ec8 0330D5E5 		ldrb	r3, [r5, #3]	@ zero_extendqisi2
 3871 1ecc 010053E3 		cmp	r3, #1
 3872 1ed0 1D00001A 		bne	.L364
 3873              	.LVL272:
1421:main.c        **** 			{
 3874              		.loc 1 1421 0
 3875 1ed4 50319FE5 		ldr	r3, .L391+12
 3876              	.LBB164:
 3877              	.LBB165:
 3878              	.LBB166:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3879              		.loc 1 1118 0
 3880 1ed8 027BA0E3 		mov	r7, #2048
 3881 1edc 0C7084E5 		str	r7, [r4, #12]
 3882              	.LBE166:
 3883              	.LBE165:
 3884              	.LBE164:
1421:main.c        **** 			{
 3885              		.loc 1 1421 0
 3886 1ee0 000096E5 		ldr	r0, [r6, #0]
 3887 1ee4 4C119FE5 		ldr	r1, .L391+24
 3888 1ee8 002093E5 		ldr	r2, [r3, #0]
 3889 1eec FEFFFFEB 		bl	fat_write_file
 3890              	.LVL273:
 3891 1ef0 000050E3 		cmp	r0, #0
 3892 1ef4 0D0000AA 		bge	.L365
 3893              	.LBB167:
 3894              	.LBB168:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3895              		.loc 1 1123 0
 3896 1ef8 24319FE5 		ldr	r3, .L391+4
 3897 1efc 0410A0E3 		mov	r1, #4
 3898 1f00 0300A0E1 		mov	r0, r3
 3899              	.L387:
 3900              	.LVL274:
 3901 1f04 0C1083E5 		str	r1, [r3, #12]
 3902              	.LVL275:
 3903 1f08 24219FE5 		ldr	r2, .L391+20
 3904              	.LVL276:
 3905              	.L366:
 3906              	.LBE168:
 3907              	.LBE167:
1426:main.c        **** 					stat(0,OFF);
 3908              		.loc 1 1426 0
 3909 1f0c 012052E2 		subs	r2, r2, #1
 3910              	.LBB169:
 3911              	.LBB170:
1124:main.c        **** 	}
 3912              		.loc 1 1124 0
 3913 1f10 041080E5 		str	r1, [r0, #4]
 3914              	.LBE170:
 3915              	.LBE169:
1426:main.c        **** 					stat(0,OFF);
 3916              		.loc 1 1426 0
 3917 1f14 FCFFFF1A 		bne	.L366
 3918              	.LVL277:
 3919              	.LBB171:
 3920              	.LBB172:
 3921              	.LBB173:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3922              		.loc 1 1118 0
 3923 1f18 0C7080E5 		str	r7, [r0, #12]
 3924              	.LVL278:
 3925 1f1c 10219FE5 		ldr	r2, .L391+20
 3926              	.LVL279:
 3927              	.L367:
 3928              	.LBE173:
 3929              	.LBE172:
 3930              	.LBE171:
1429:main.c        **** 					stat(1,OFF);
 3931              		.loc 1 1429 0
 3932 1f20 012052E2 		subs	r2, r2, #1
 3933              	.LBB174:
 3934              	.LBB175:
 3935              	.LBB176:
1119:main.c        **** 	}
 3936              		.loc 1 1119 0
 3937 1f24 047083E5 		str	r7, [r3, #4]
 3938              	.LBE176:
 3939              	.LBE175:
 3940              	.LBE174:
1429:main.c        **** 					stat(1,OFF);
 3941              		.loc 1 1429 0
 3942 1f28 FCFFFF1A 		bne	.L367
 3943 1f2c F4FFFFEA 		b	.L387
 3944              	.LVL280:
 3945              	.L365:
1434:main.c        **** 			stat(1,OFF);
 3946              		.loc 1 1434 0
 3947 1f30 FEFFFFEB 		bl	sd_raw_sync
 3948              	.LVL281:
1436:main.c        **** 			if(use_adc == TRUE)
 3949              		.loc 1 1436 0
 3950 1f34 0030A0E3 		mov	r3, #0
 3951              	.LBB177:
 3952              	.LBB178:
 3953              	.LBB179:
1119:main.c        **** 	}
 3954              		.loc 1 1119 0
 3955 1f38 047084E5 		str	r7, [r4, #4]
 3956              	.LBE179:
 3957              	.LBE178:
 3958              	.LBE177:
1436:main.c        **** 			if(use_adc == TRUE)
 3959              		.loc 1 1436 0
 3960 1f3c 0330C5E5 		strb	r3, [r5, #3]
1437:main.c        **** 				LogADC();
 3961              		.loc 1 1437 0
 3962 1f40 0C3095E5 		ldr	r3, [r5, #12]
 3963 1f44 010053E3 		cmp	r3, #1
1438:main.c        **** 		}
 3964              		.loc 1 1438 0
 3965 1f48 FEFFFF0B 		bleq	LogADC
 3966              	.LVL282:
 3967              	.L364:
1442:main.c        **** 		{
 3968              		.loc 1 1442 0
 3969 1f4c 0830D5E5 		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 3970 1f50 010053E3 		cmp	r3, #1
 3971 1f54 1A00001A 		bne	.L370
 3972              	.LVL283:
1446:main.c        **** 			{
 3973              		.loc 1 1446 0
 3974 1f58 DC309FE5 		ldr	r3, .L391+28
 3975              	.LBB180:
 3976              	.LBB181:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3977              		.loc 1 1123 0
 3978 1f5c 0470A0E3 		mov	r7, #4
 3979 1f60 0C7084E5 		str	r7, [r4, #12]
 3980              	.LBE181:
 3981              	.LBE180:
1446:main.c        **** 			{
 3982              		.loc 1 1446 0
 3983 1f64 000096E5 		ldr	r0, [r6, #0]
 3984 1f68 D0109FE5 		ldr	r1, .L391+32
 3985 1f6c 002093E5 		ldr	r2, [r3, #0]
 3986 1f70 FEFFFFEB 		bl	fat_write_file
 3987              	.LVL284:
 3988 1f74 000050E3 		cmp	r0, #0
 3989 1f78 0D0000AA 		bge	.L371
 3990              	.LBB182:
 3991              	.LBB183:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3992              		.loc 1 1123 0
 3993 1f7c A0309FE5 		ldr	r3, .L391+4
 3994              	.LBE183:
 3995              	.LBE182:
 3996              	.LBB185:
 3997              	.LBB186:
 3998              	.LBB187:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3999              		.loc 1 1118 0
 4000 1f80 020BA0E3 		mov	r0, #2048
 4001 1f84 0310A0E1 		mov	r1, r3
 4002              	.L388:
 4003              	.LVL285:
 4004              	.LBE187:
 4005              	.LBE186:
 4006              	.LBE185:
 4007              	.LBB190:
 4008              	.LBB184:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4009              		.loc 1 1123 0
 4010 1f88 0C7083E5 		str	r7, [r3, #12]
 4011              	.LVL286:
 4012 1f8c A0209FE5 		ldr	r2, .L391+20
 4013              	.LVL287:
 4014              	.L372:
 4015              	.LBE184:
 4016              	.LBE190:
1451:main.c        **** 					stat(0,OFF);
 4017              		.loc 1 1451 0
 4018 1f90 012052E2 		subs	r2, r2, #1
 4019              	.LBB191:
 4020              	.LBB192:
1124:main.c        **** 	}
 4021              		.loc 1 1124 0
 4022 1f94 047081E5 		str	r7, [r1, #4]
 4023              	.LBE192:
 4024              	.LBE191:
1451:main.c        **** 					stat(0,OFF);
 4025              		.loc 1 1451 0
 4026 1f98 FCFFFF1A 		bne	.L372
 4027              	.LVL288:
 4028              	.LBB193:
 4029              	.LBB189:
 4030              	.LBB188:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4031              		.loc 1 1118 0
 4032 1f9c 0C0081E5 		str	r0, [r1, #12]
 4033              	.LVL289:
 4034 1fa0 8C209FE5 		ldr	r2, .L391+20
 4035              	.LVL290:
 4036              	.L373:
 4037              	.LBE188:
 4038              	.LBE189:
 4039              	.LBE193:
1454:main.c        **** 					stat(1,OFF);
 4040              		.loc 1 1454 0
 4041 1fa4 012052E2 		subs	r2, r2, #1
 4042              	.LBB194:
 4043              	.LBB195:
 4044              	.LBB196:
1119:main.c        **** 	}
 4045              		.loc 1 1119 0
 4046 1fa8 040083E5 		str	r0, [r3, #4]
 4047              	.LBE196:
 4048              	.LBE195:
 4049              	.LBE194:
1454:main.c        **** 					stat(1,OFF);
 4050              		.loc 1 1454 0
 4051 1fac FCFFFF1A 		bne	.L373
 4052 1fb0 F4FFFFEA 		b	.L388
 4053              	.LVL291:
 4054              	.L371:
1458:main.c        **** 			stat(0,OFF);
 4055              		.loc 1 1458 0
 4056 1fb4 FEFFFFEB 		bl	sd_raw_sync
 4057              	.LVL292:
1460:main.c        **** 		}
 4058              		.loc 1 1460 0
 4059 1fb8 0030A0E3 		mov	r3, #0
 4060              	.LBB197:
 4061              	.LBB198:
1124:main.c        **** 	}
 4062              		.loc 1 1124 0
 4063 1fbc 047084E5 		str	r7, [r4, #4]
 4064              	.LBE198:
 4065              	.LBE197:
1460:main.c        **** 		}
 4066              		.loc 1 1460 0
 4067 1fc0 0830C5E5 		strb	r3, [r5, #8]
 4068              	.LVL293:
 4069              	.L370:
1465:main.c        **** 		{
 4070              		.loc 1 1465 0
 4071 1fc4 003094E5 		ldr	r3, [r4, #0]
 4072 1fc8 080013E3 		tst	r3, #8
 4073 1fcc 9FFFFF1A 		bne	.L375
1467:main.c        **** 			// write whatever is left in the data buffer to the microSD
 4074              		.loc 1 1467 0
 4075 1fd0 0030E0E3 		mvn	r3, #0
 4076 1fd4 EB3F03E5 		str	r3, [r3, #-4075]
1469:main.c        **** 			{
 4077              		.loc 1 1469 0
 4078 1fd8 40309FE5 		ldr	r3, .L391
 4079 1fdc F020D3E1 		ldrsh	r2, [r3, #0]
 4080 1fe0 40309FE5 		ldr	r3, .L391+8
 4081 1fe4 020C52E3 		cmp	r2, #512
1471:main.c        **** 				sd_raw_sync();
 4082              		.loc 1 1471 0
 4083 1fe8 000093E5 		ldr	r0, [r3, #0]
 4084 1fec 3C109FB5 		ldrlt	r1, .L391+16
1476:main.c        **** 				sd_raw_sync();
 4085              		.loc 1 1476 0
 4086 1ff0 40109FA5 		ldrge	r1, .L391+24
 4087 1ff4 022C42A2 		subge	r2, r2, #512
 4088 1ff8 FEFFFFEB 		bl	fat_write_file
 4089              	.LVL294:
1477:main.c        **** 			}
 4090              		.loc 1 1477 0
 4091 1ffc FEFFFFEB 		bl	sd_raw_sync
 4092              	.LVL295:
 4093              	.LBB199:
 4094              	.LBB200:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4095              		.loc 1 1123 0
 4096 2000 1C309FE5 		ldr	r3, .L391+4
 4097 2004 0410A0E3 		mov	r1, #4
 4098              	.LBE200:
 4099              	.LBE199:
 4100              	.LBB202:
 4101              	.LBB203:
 4102              	.LBB204:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4103              		.loc 1 1118 0
 4104 2008 022BA0E3 		mov	r2, #2048
 4105              	.L389:
 4106              	.LVL296:
 4107              	.LBE204:
 4108              	.LBE203:
 4109              	.LBE202:
 4110              	.LBB207:
 4111              	.LBB201:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4112              		.loc 1 1123 0
 4113 200c 0C1083E5 		str	r1, [r3, #12]
 4114              	.LVL297:
 4115              	.LBE201:
 4116              	.LBE207:
 4117              	.LBB208:
 4118              	.LBB209:
1124:main.c        **** 	}
 4119              		.loc 1 1124 0
 4120 2010 041083E5 		str	r1, [r3, #4]
 4121              	.LVL298:
 4122              	.LBE209:
 4123              	.LBE208:
 4124              	.LBB210:
 4125              	.LBB206:
 4126              	.LBB205:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4127              		.loc 1 1118 0
 4128 2014 0C2083E5 		str	r2, [r3, #12]
 4129              	.LVL299:
 4130              	.LBE205:
 4131              	.LBE206:
 4132              	.LBE210:
 4133              	.LBB211:
 4134              	.LBB212:
 4135              	.LBB213:
1119:main.c        **** 	}
 4136              		.loc 1 1119 0
 4137 2018 042083E5 		str	r2, [r3, #4]
 4138 201c FAFFFFEA 		b	.L389
 4139              	.L392:
 4140              		.align	2
 4141              	.L391:
 4142 2020 00000000 		.word	.LANCHOR0
 4143 2024 008002E0 		.word	-536707072
 4144 2028 00000000 		.word	handle
 4145 202c 00000000 		.word	stringSize
 4146 2030 00000000 		.word	RX_array1
 4147 2034 20A10700 		.word	500000
 4148 2038 00000000 		.word	RX_array2
 4149 203c 00000000 		.word	ADCStringSize
 4150 2040 00000000 		.word	ADC_array
 4151              	.LBE213:
 4152              	.LBE212:
 4153              	.LBE211:
 4154              		.cfi_endproc
 4155              	.LFE16:
 4157              		.align	2
 4158              		.global	mode_3
 4160              	mode_3:
 4161              	.LFB15:
1366:main.c        **** 	rprintf("MODE 3\n\r");	
 4162              		.loc 1 1366 0
 4163              		.cfi_startproc
 4164              		@ Function supports interworking.
 4165              		@ args = 0, pretend = 0, frame = 0
 4166              		@ frame_needed = 0, uses_anonymous_args = 0
 4167 2044 10402DE9 		stmfd	sp!, {r4, lr}
 4168              	.LCFI15:
 4169              		.cfi_def_cfa_offset 8
 4170              		.cfi_offset 4, -8
 4171              		.cfi_offset 14, -4
1369:main.c        **** 	stringSize = frame + 2;
 4172              		.loc 1 1369 0
 4173 2048 30409FE5 		ldr	r4, .L394
1367:main.c        **** 
 4174              		.loc 1 1367 0
 4175 204c 30009FE5 		ldr	r0, .L394+4
 4176 2050 FEFFFFEB 		bl	rprintf
 4177              	.LVL300:
1369:main.c        **** 	stringSize = frame + 2;
 4178              		.loc 1 1369 0
 4179 2054 100094E5 		ldr	r0, [r4, #16]
 4180 2058 0210A0E3 		mov	r1, #2
 4181 205c FEFFFFEB 		bl	setup_uart0
 4182              	.LVL301:
1370:main.c        **** 	use_adc = TRUE;
 4183              		.loc 1 1370 0
 4184 2060 F220D4E1 		ldrsh	r2, [r4, #2]
 4185 2064 1C309FE5 		ldr	r3, .L394+8
 4186 2068 022082E2 		add	r2, r2, #2
 4187 206c 002083E5 		str	r2, [r3, #0]
1371:main.c        **** 	mode_action();
 4188              		.loc 1 1371 0
 4189 2070 14309FE5 		ldr	r3, .L394+12
 4190 2074 0120A0E3 		mov	r2, #1
 4191 2078 0C2083E5 		str	r2, [r3, #12]
1372:main.c        **** }
 4192              		.loc 1 1372 0
 4193 207c FEFFFFEB 		bl	mode_action
 4194              	.LVL302:
 4195              	.L395:
 4196              		.align	2
 4197              	.L394:
 4198 2080 00000000 		.word	.LANCHOR1
 4199 2084 7B020000 		.word	.LC27
 4200 2088 00000000 		.word	stringSize
 4201 208c 00000000 		.word	.LANCHOR0
 4202              		.cfi_endproc
 4203              	.LFE15:
 4205              		.global	__divsi3
 4206              		.align	2
 4207              		.global	mode_2
 4209              	mode_2:
 4210              	.LFB14:
1335:main.c        **** 	rprintf("MODE 2\n\r");	
 4211              		.loc 1 1335 0
 4212              		.cfi_startproc
 4213              		@ Function supports interworking.
 4214              		@ args = 0, pretend = 0, frame = 0
 4215              		@ frame_needed = 0, uses_anonymous_args = 0
 4216 2090 10402DE9 		stmfd	sp!, {r4, lr}
 4217              	.LCFI16:
 4218              		.cfi_def_cfa_offset 8
 4219              		.cfi_offset 4, -8
 4220              		.cfi_offset 14, -4
1336:main.c        **** 	enableIRQ();
 4221              		.loc 1 1336 0
 4222 2094 78009FE5 		ldr	r0, .L397
 4223 2098 FEFFFFEB 		bl	rprintf
 4224              	.LVL303:
1337:main.c        **** 	// Timer0  interrupt is an IRQ interrupt
 4225              		.loc 1 1337 0
 4226 209c FEFFFFEB 		bl	enableIRQ
 4227              	.LVL304:
1339:main.c        **** 	// Enable Timer0 interrupt
 4228              		.loc 1 1339 0
 4229 20a0 0030E0E3 		mvn	r3, #0
 4230 20a4 F32F13E5 		ldr	r2, [r3, #-4083]
 4231 20a8 1020C2E3 		bic	r2, r2, #16
 4232 20ac F32F03E5 		str	r2, [r3, #-4083]
1341:main.c        **** 	// Use slot 2 for UART0 interrupt
 4233              		.loc 1 1341 0
 4234 20b0 EF2F13E5 		ldr	r2, [r3, #-4079]
 4235 20b4 102082E3 		orr	r2, r2, #16
 4236 20b8 EF2F03E5 		str	r2, [r3, #-4079]
1343:main.c        **** 	// Set the address of ISR for slot 1
 4237              		.loc 1 1343 0
 4238 20bc 2420A0E3 		mov	r2, #36
 4239 20c0 F72D03E5 		str	r2, [r3, #-3575]
1345:main.c        **** 
 4240              		.loc 1 1345 0
 4241 20c4 4C209FE5 		ldr	r2, .L397+4
1347:main.c        **** 	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
 4242              		.loc 1 1347 0
 4243 20c8 4C409FE5 		ldr	r4, .L397+8
1345:main.c        **** 
 4244              		.loc 1 1345 0
 4245 20cc F72E03E5 		str	r2, [r3, #-3831]
1347:main.c        **** 	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
 4246              		.loc 1 1347 0
 4247 20d0 0230A0E3 		mov	r3, #2
 4248 20d4 043084E5 		str	r3, [r4, #4]
1348:main.c        **** 	T0MR0 = 58982400 / freq;
 4249              		.loc 1 1348 0
 4250 20d8 0330A0E3 		mov	r3, #3
 4251 20dc 143084E5 		str	r3, [r4, #20]
1349:main.c        **** 
 4252              		.loc 1 1349 0
 4253 20e0 38309FE5 		ldr	r3, .L397+12
 4254 20e4 E107A0E3 		mov	r0, #58982400
 4255 20e8 141093E5 		ldr	r1, [r3, #20]
 4256 20ec FEFFFFEB 		bl	__divsi3
 4257              	.LVL305:
1351:main.c        **** 
 4258              		.loc 1 1351 0
 4259 20f0 0030A0E3 		mov	r3, #0
1349:main.c        **** 
 4260              		.loc 1 1349 0
 4261 20f4 180084E5 		str	r0, [r4, #24]
1351:main.c        **** 
 4262              		.loc 1 1351 0
 4263 20f8 0C3084E5 		str	r3, [r4, #12]
1353:main.c        **** 
 4264              		.loc 1 1353 0
 4265 20fc 0130A0E3 		mov	r3, #1
 4266 2100 043084E5 		str	r3, [r4, #4]
1355:main.c        **** 	mode_action();
 4267              		.loc 1 1355 0
 4268 2104 18309FE5 		ldr	r3, .L397+16
 4269 2108 022CA0E3 		mov	r2, #512
 4270 210c 002083E5 		str	r2, [r3, #0]
1356:main.c        **** }
 4271              		.loc 1 1356 0
 4272 2110 FEFFFFEB 		bl	mode_action
 4273              	.LVL306:
 4274              	.L398:
 4275              		.align	2
 4276              	.L397:
 4277 2114 84020000 		.word	.LC28
 4278 2118 00000000 		.word	MODE2ISR
 4279 211c 004000E0 		.word	-536854528
 4280 2120 00000000 		.word	.LANCHOR1
 4281 2124 00000000 		.word	stringSize
 4282              		.cfi_endproc
 4283              	.LFE14:
 4285              		.align	2
 4286              		.global	mode_1
 4288              	mode_1:
 4289              	.LFB13:
1320:main.c        **** 	rprintf("MODE 1\n\r");	
 4290              		.loc 1 1320 0
 4291              		.cfi_startproc
 4292              		@ Function supports interworking.
 4293              		@ args = 0, pretend = 0, frame = 0
 4294              		@ frame_needed = 0, uses_anonymous_args = 0
 4295 2128 10402DE9 		stmfd	sp!, {r4, lr}
 4296              	.LCFI17:
 4297              		.cfi_def_cfa_offset 8
 4298              		.cfi_offset 4, -8
 4299              		.cfi_offset 14, -4
1323:main.c        **** 	stringSize = frame + 2;
 4300              		.loc 1 1323 0
 4301 212c 24409FE5 		ldr	r4, .L400
1321:main.c        **** 
 4302              		.loc 1 1321 0
 4303 2130 24009FE5 		ldr	r0, .L400+4
 4304 2134 FEFFFFEB 		bl	rprintf
 4305              	.LVL307:
1323:main.c        **** 	stringSize = frame + 2;
 4306              		.loc 1 1323 0
 4307 2138 100094E5 		ldr	r0, [r4, #16]
 4308 213c 0210A0E3 		mov	r1, #2
 4309 2140 FEFFFFEB 		bl	setup_uart0
 4310              	.LVL308:
1324:main.c        **** 
 4311              		.loc 1 1324 0
 4312 2144 F220D4E1 		ldrsh	r2, [r4, #2]
 4313 2148 10309FE5 		ldr	r3, .L400+8
 4314 214c 022082E2 		add	r2, r2, #2
 4315 2150 002083E5 		str	r2, [r3, #0]
1326:main.c        **** }
 4316              		.loc 1 1326 0
 4317 2154 FEFFFFEB 		bl	mode_action
 4318              	.LVL309:
 4319              	.L401:
 4320              		.align	2
 4321              	.L400:
 4322 2158 00000000 		.word	.LANCHOR1
 4323 215c 8D020000 		.word	.LC29
 4324 2160 00000000 		.word	stringSize
 4325              		.cfi_endproc
 4326              	.LFE13:
 4328              		.align	2
 4329              		.global	mode_0
 4331              	mode_0:
 4332              	.LFB12:
1304:main.c        **** 	rprintf("MODE 0\n\r");
 4333              		.loc 1 1304 0
 4334              		.cfi_startproc
 4335              		@ Function supports interworking.
 4336              		@ args = 0, pretend = 0, frame = 0
 4337              		@ frame_needed = 0, uses_anonymous_args = 0
 4338 2164 04E02DE5 		str	lr, [sp, #-4]!
 4339              	.LCFI18:
 4340              		.cfi_def_cfa_offset 4
 4341              		.cfi_offset 14, -4
1305:main.c        **** 	setup_uart0(baud,1);
 4342              		.loc 1 1305 0
 4343 2168 20009FE5 		ldr	r0, .L403
 4344 216c FEFFFFEB 		bl	rprintf
 4345              	.LVL310:
1306:main.c        **** 	stringSize = 512;
 4346              		.loc 1 1306 0
 4347 2170 1C309FE5 		ldr	r3, .L403+4
 4348 2174 0110A0E3 		mov	r1, #1
 4349 2178 100093E5 		ldr	r0, [r3, #16]
 4350 217c FEFFFFEB 		bl	setup_uart0
 4351              	.LVL311:
1307:main.c        **** 	mode_action();
 4352              		.loc 1 1307 0
 4353 2180 10309FE5 		ldr	r3, .L403+8
 4354 2184 022CA0E3 		mov	r2, #512
 4355 2188 002083E5 		str	r2, [r3, #0]
1308:main.c        **** 	//rprintf("Exit mode 0\n\r");
 4356              		.loc 1 1308 0
 4357 218c FEFFFFEB 		bl	mode_action
 4358              	.LVL312:
 4359              	.L404:
 4360              		.align	2
 4361              	.L403:
 4362 2190 96020000 		.word	.LC30
 4363 2194 00000000 		.word	.LANCHOR1
 4364 2198 00000000 		.word	stringSize
 4365              		.cfi_endproc
 4366              	.LFE12:
 4368              		.section	.text.startup,"ax",%progbits
 4369              		.align	2
 4370              		.global	main
 4372              	main:
 4373              	.LFB0:
 154:main.c        **** 	int i;
 4374              		.loc 1 154 0
 4375              		.cfi_startproc
 4376              		@ Function supports interworking.
 4377              		@ args = 0, pretend = 0, frame = 44
 4378              		@ frame_needed = 0, uses_anonymous_args = 0
 4379              	.LVL313:
 4380 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 4381              	.LCFI19:
 4382              		.cfi_def_cfa_offset 24
 4383              		.cfi_offset 4, -24
 4384              		.cfi_offset 5, -20
 4385              		.cfi_offset 6, -16
 4386              		.cfi_offset 7, -12
 4387              		.cfi_offset 8, -8
 4388              		.cfi_offset 14, -4
 4389 0004 2CD04DE2 		sub	sp, sp, #44
 4390              	.LCFI20:
 4391              		.cfi_def_cfa_offset 68
 159:main.c        **** 	
 4392              		.loc 1 159 0
 4393 0008 FEFFFFEB 		bl	enableFIQ
 4394              	.LVL314:
 161:main.c        **** 	
 4395              		.loc 1 161 0
 4396 000c FEFFFFEB 		bl	Initialize
 4397              	.LVL315:
 163:main.c        **** 	
 4398              		.loc 1 163 0
 4399 0010 FEFFFFEB 		bl	InitializeTime
 4400              	.LVL316:
 165:main.c        **** 
 4401              		.loc 1 165 0
 4402 0014 960DA0E3 		mov	r0, #9600
 4403 0018 0010A0E3 		mov	r1, #0
 4404 001c FEFFFFEB 		bl	setup_uart0
 4405              	.LVL317:
 167:main.c        **** 
 4406              		.loc 1 167 0
 4407 0020 FEFFFFEB 		bl	fat_initialize
 4408              	.LVL318:
 4409              	.LBB289:
 4410              	.LBB290:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4411              		.loc 1 1123 0
 4412 0024 0460A0E3 		mov	r6, #4
 4413 0028 00429FE5 		ldr	r4, .L427
 4414              	.LBE290:
 4415              	.LBE289:
 167:main.c        **** 
 4416              		.loc 1 167 0
 4417 002c 0550A0E3 		mov	r5, #5
 4418              	.LBB293:
 4419              	.LBB291:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4420              		.loc 1 1123 0
 4421 0030 0680A0E1 		mov	r8, r6
 4422              	.LVL319:
 4423              	.L406:
 4424              	.LBE291:
 4425              	.LBE293:
 174:main.c        **** 		stat(0,OFF);
 4426              		.loc 1 174 0
 4427 0034 3200A0E3 		mov	r0, #50
 4428              	.LBB294:
 4429              	.LBB295:
 4430              	.LBB296:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4431              		.loc 1 1118 0
 4432 0038 027BA0E3 		mov	r7, #2048
 4433              	.LBE296:
 4434              	.LBE295:
 4435              	.LBE294:
 4436              	.LBB299:
 4437              	.LBB292:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4438              		.loc 1 1123 0
 4439 003c 0C8084E5 		str	r8, [r4, #12]
 4440              	.LBE292:
 4441              	.LBE299:
 174:main.c        **** 		stat(0,OFF);
 4442              		.loc 1 174 0
 4443 0040 FEFFFFEB 		bl	delay_ms
 4444              	.LVL320:
 4445              	.LBB300:
 4446              	.LBB301:
1124:main.c        **** 	}
 4447              		.loc 1 1124 0
 4448 0044 046084E5 		str	r6, [r4, #4]
 4449              	.LVL321:
 4450              	.LBE301:
 4451              	.LBE300:
 177:main.c        **** 		stat(1,OFF);
 4452              		.loc 1 177 0
 4453 0048 3200A0E3 		mov	r0, #50
 4454              	.LBB302:
 4455              	.LBB298:
 4456              	.LBB297:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4457              		.loc 1 1118 0
 4458 004c 0C7084E5 		str	r7, [r4, #12]
 4459              	.LBE297:
 4460              	.LBE298:
 4461              	.LBE302:
 177:main.c        **** 		stat(1,OFF);
 4462              		.loc 1 177 0
 4463 0050 FEFFFFEB 		bl	delay_ms
 4464              	.LVL322:
 171:main.c        **** 	{
 4465              		.loc 1 171 0
 4466 0054 015055E2 		subs	r5, r5, #1
 4467              	.LBB303:
 4468              	.LBB304:
 4469              	.LBB305:
1119:main.c        **** 	}
 4470              		.loc 1 1119 0
 4471 0058 047084E5 		str	r7, [r4, #4]
 4472              	.LBE305:
 4473              	.LBE304:
 4474              	.LBE303:
 171:main.c        **** 	{
 4475              		.loc 1 171 0
 4476 005c F4FFFF1A 		bne	.L406
 184:main.c        **** 	while(root_file_exists(name))
 4477              		.loc 1 184 0
 4478 0060 0C508DE2 		add	r5, sp, #12
 181:main.c        **** 
 4479              		.loc 1 181 0
 4480 0064 FEFFFFEB 		bl	Log_init
 4481              	.LVL323:
 184:main.c        **** 	while(root_file_exists(name))
 4482              		.loc 1 184 0
 4483 0068 0500A0E1 		mov	r0, r5
 4484 006c C0119FE5 		ldr	r1, .L427+4
 4485 0070 0120A0E3 		mov	r2, #1
 4486 0074 FEFFFFEB 		bl	string_printf
 4487              	.LVL324:
 183:main.c        **** 	string_printf(name,"LOG%02d.txt",count);
 4488              		.loc 1 183 0
 4489 0078 0140A0E3 		mov	r4, #1
 185:main.c        **** 	{
 4490              		.loc 1 185 0
 4491 007c 150000EA 		b	.L407
 4492              	.LVL325:
 4493              	.L410:
 187:main.c        **** 		if(count == 250) 
 4494              		.loc 1 187 0
 4495 0080 014084E2 		add	r4, r4, #1
 4496              	.LVL326:
 188:main.c        **** 		{
 4497              		.loc 1 188 0
 4498 0084 FA0054E3 		cmp	r4, #250
 4499 0088 0E00001A 		bne	.L408
 190:main.c        **** 			while(1)
 4500              		.loc 1 190 0
 4501 008c A4019FE5 		ldr	r0, .L427+8
 4502 0090 FEFFFFEB 		bl	rprintf
 4503              	.LVL327:
 4504              	.LBB306:
 4505              	.LBB307:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4506              		.loc 1 1123 0
 4507 0094 0450A0E3 		mov	r5, #4
 4508 0098 90419FE5 		ldr	r4, .L427
 4509              	.LVL328:
 4510 009c 0570A0E1 		mov	r7, r5
 4511              	.L409:
 4512              	.LVL329:
 4513              	.LBE307:
 4514              	.LBE306:
 4515              	.LBB309:
 4516              	.LBB310:
 4517              	.LBB311:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4518              		.loc 1 1118 0 discriminator 1
 4519 00a0 026BA0E3 		mov	r6, #2048
 4520              	.LBE311:
 4521              	.LBE310:
 4522              	.LBE309:
 4523              	.LBB314:
 4524              	.LBB308:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4525              		.loc 1 1123 0 discriminator 1
 4526 00a4 0C7084E5 		str	r7, [r4, #12]
 4527              	.LVL330:
 4528              	.LBE308:
 4529              	.LBE314:
 195:main.c        **** 				stat(0,OFF);
 4530              		.loc 1 195 0 discriminator 1
 4531 00a8 FA0FA0E3 		mov	r0, #1000
 4532              	.LBB315:
 4533              	.LBB313:
 4534              	.LBB312:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4535              		.loc 1 1118 0 discriminator 1
 4536 00ac 0C6084E5 		str	r6, [r4, #12]
 4537              	.LBE312:
 4538              	.LBE313:
 4539              	.LBE315:
 195:main.c        **** 				stat(0,OFF);
 4540              		.loc 1 195 0 discriminator 1
 4541 00b0 FEFFFFEB 		bl	delay_ms
 4542              	.LVL331:
 4543              	.LBB316:
 4544              	.LBB317:
1124:main.c        **** 	}
 4545              		.loc 1 1124 0 discriminator 1
 4546 00b4 045084E5 		str	r5, [r4, #4]
 4547              	.LVL332:
 4548              	.LBE317:
 4549              	.LBE316:
 198:main.c        **** 			}
 4550              		.loc 1 198 0 discriminator 1
 4551 00b8 FA0FA0E3 		mov	r0, #1000
 4552              	.LBB318:
 4553              	.LBB319:
 4554              	.LBB320:
1119:main.c        **** 	}
 4555              		.loc 1 1119 0 discriminator 1
 4556 00bc 046084E5 		str	r6, [r4, #4]
 4557              	.LBE320:
 4558              	.LBE319:
 4559              	.LBE318:
 198:main.c        **** 			}
 4560              		.loc 1 198 0 discriminator 1
 4561 00c0 FEFFFFEB 		bl	delay_ms
 4562              	.LVL333:
 4563 00c4 F5FFFFEA 		b	.L409
 4564              	.LVL334:
 4565              	.L408:
 202:main.c        **** 	}
 4566              		.loc 1 202 0
 4567 00c8 0500A0E1 		mov	r0, r5
 4568 00cc 60119FE5 		ldr	r1, .L427+4
 4569 00d0 0420A0E1 		mov	r2, r4
 4570 00d4 FEFFFFEB 		bl	string_printf
 4571              	.LVL335:
 4572              	.L407:
 185:main.c        **** 	{
 4573              		.loc 1 185 0 discriminator 1
 4574 00d8 0500A0E1 		mov	r0, r5
 4575 00dc FEFFFFEB 		bl	root_file_exists
 4576              	.LVL336:
 4577 00e0 000050E3 		cmp	r0, #0
 4578 00e4 E5FFFF1A 		bne	.L410
 205:main.c        **** 		
 4579              		.loc 1 205 0
 4580 00e8 0500A0E1 		mov	r0, r5
 4581 00ec FEFFFFEB 		bl	root_open_new
 4582              	.LVL337:
 4583 00f0 44619FE5 		ldr	r6, .L427+12
 4584 00f4 000086E5 		str	r0, [r6, #0]
 208:main.c        **** 		
 4585              		.loc 1 208 0
 4586 00f8 FEFFFFEB 		bl	sd_raw_sync
 4587              	.LVL338:
 211:main.c        **** 	{
 4588              		.loc 1 211 0
 4589 00fc 3C319FE5 		ldr	r3, .L427+16
 4590 0100 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 4591 0104 023043E2 		sub	r3, r3, #2
 4592 0108 010053E3 		cmp	r3, #1
 4593 010c 2B00008A 		bhi	.L411
 4594              	.LBB321:
 214:main.c        **** 		mybuf[1] = ad0_2;
 4595              		.loc 1 214 0
 4596 0110 2C319FE5 		ldr	r3, .L427+20
 4597 0114 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 4598 0118 0020CDE5 		strb	r2, [sp, #0]
 215:main.c        **** 		mybuf[2] = ad0_1;
 4599              		.loc 1 215 0
 4600 011c 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4601 0120 0120CDE5 		strb	r2, [sp, #1]
 216:main.c        **** 		mybuf[3] = ad0_4;
 4602              		.loc 1 216 0
 4603 0124 0720D3E5 		ldrb	r2, [r3, #7]	@ zero_extendqisi2
 4604 0128 0220CDE5 		strb	r2, [sp, #2]
 217:main.c        **** 		mybuf[4] = ad1_7;
 4605              		.loc 1 217 0
 4606 012c 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 4607 0130 0320CDE5 		strb	r2, [sp, #3]
 218:main.c        **** 		mybuf[5] = ad1_6;
 4608              		.loc 1 218 0
 4609 0134 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 4610 0138 0420CDE5 		strb	r2, [sp, #4]
 219:main.c        **** 		mybuf[6] = ad1_2;
 4611              		.loc 1 219 0
 4612 013c 0A20D3E5 		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 4613 0140 0520CDE5 		strb	r2, [sp, #5]
 220:main.c        **** 		mybuf[7] = ad1_3;
 4614              		.loc 1 220 0
 4615 0144 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 221:main.c        **** 		mybuf[8] = 13;
 4616              		.loc 1 221 0
 4617 0148 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 4618              	.LBB322:
 4619              	.LBB323:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4620              		.loc 1 1123 0
 4621 014c DC409FE5 		ldr	r4, .L427
 4622              	.LVL339:
 4623              	.LBE323:
 4624              	.LBE322:
 220:main.c        **** 		mybuf[7] = ad1_3;
 4625              		.loc 1 220 0
 4626 0150 0620CDE5 		strb	r2, [sp, #6]
 221:main.c        **** 		mybuf[8] = 13;
 4627              		.loc 1 221 0
 4628 0154 0730CDE5 		strb	r3, [sp, #7]
 223:main.c        **** 	
 4629              		.loc 1 223 0
 4630 0158 0A20A0E3 		mov	r2, #10
 222:main.c        **** 		mybuf[9] = 10;	
 4631              		.loc 1 222 0
 4632 015c 0D30A0E3 		mov	r3, #13
 4633              	.LBB326:
 4634              	.LBB324:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4635              		.loc 1 1123 0
 4636 0160 0450A0E3 		mov	r5, #4
 4637              	.LBE324:
 4638              	.LBE326:
 222:main.c        **** 		mybuf[9] = 10;	
 4639              		.loc 1 222 0
 4640 0164 0830CDE5 		strb	r3, [sp, #8]
 223:main.c        **** 	
 4641              		.loc 1 223 0
 4642 0168 0920CDE5 		strb	r2, [sp, #9]
 4643              	.LVL340:
 227:main.c        **** 		{
 4644              		.loc 1 227 0
 4645 016c 000096E5 		ldr	r0, [r6, #0]
 4646              	.LBB327:
 4647              	.LBB325:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4648              		.loc 1 1123 0
 4649 0170 0C5084E5 		str	r5, [r4, #12]
 4650              	.LBE325:
 4651              	.LBE327:
 227:main.c        **** 		{
 4652              		.loc 1 227 0
 4653 0174 0D10A0E1 		mov	r1, sp
 4654 0178 FEFFFFEB 		bl	fat_write_file
 4655              	.LVL341:
 4656 017c 000050E3 		cmp	r0, #0
 4657 0180 0C0000AA 		bge	.L412
 4658 0184 0420A0E1 		mov	r2, r4
 4659              	.LBB328:
 4660              	.LBB329:
 4661              	.LBB330:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4662              		.loc 1 1118 0
 4663 0188 021BA0E3 		mov	r1, #2048
 4664              	.L426:
 4665              	.LVL342:
 4666              	.LBE330:
 4667              	.LBE329:
 4668              	.LBE328:
 4669              	.LBB333:
 4670              	.LBB334:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4671              		.loc 1 1123 0
 4672 018c 0C5084E5 		str	r5, [r4, #12]
 4673              	.LVL343:
 4674 0190 B0309FE5 		ldr	r3, .L427+24
 4675              	.LVL344:
 4676              	.L413:
 4677              	.LBE334:
 4678              	.LBE333:
 4679              	.LBB335:
 232:main.c        **** 				stat(0,OFF);
 4680              		.loc 1 232 0
 4681 0194 013053E2 		subs	r3, r3, #1
 4682              	.LBB336:
 4683              	.LBB337:
1124:main.c        **** 	}
 4684              		.loc 1 1124 0
 4685 0198 045082E5 		str	r5, [r2, #4]
 4686              	.LBE337:
 4687              	.LBE336:
 232:main.c        **** 				stat(0,OFF);
 4688              		.loc 1 232 0
 4689 019c FCFFFF1A 		bne	.L413
 4690              	.LVL345:
 4691              	.LBE335:
 4692              	.LBB338:
 4693              	.LBB332:
 4694              	.LBB331:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4695              		.loc 1 1118 0
 4696 01a0 0C1082E5 		str	r1, [r2, #12]
 4697              	.LVL346:
 4698 01a4 9C309FE5 		ldr	r3, .L427+24
 4699              	.LVL347:
 4700              	.L414:
 4701              	.LBE331:
 4702              	.LBE332:
 4703              	.LBE338:
 4704              	.LBB339:
 235:main.c        **** 				stat(1,OFF);
 4705              		.loc 1 235 0
 4706 01a8 013053E2 		subs	r3, r3, #1
 4707              	.LBB340:
 4708              	.LBB341:
 4709              	.LBB342:
1119:main.c        **** 	}
 4710              		.loc 1 1119 0
 4711 01ac 041084E5 		str	r1, [r4, #4]
 4712              	.LBE342:
 4713              	.LBE341:
 4714              	.LBE340:
 235:main.c        **** 				stat(1,OFF);
 4715              		.loc 1 235 0
 4716 01b0 FCFFFF1A 		bne	.L414
 4717 01b4 F4FFFFEA 		b	.L426
 4718              	.LVL348:
 4719              	.L412:
 4720              	.LBE339:
 240:main.c        **** 		stat(0,OFF);
 4721              		.loc 1 240 0
 4722 01b8 FEFFFFEB 		bl	sd_raw_sync
 4723              	.LVL349:
 4724              	.LBB343:
 4725              	.LBB344:
1124:main.c        **** 	}
 4726              		.loc 1 1124 0
 4727 01bc 045084E5 		str	r5, [r4, #4]
 4728              	.LVL350:
 4729              	.L411:
 4730              	.LBE344:
 4731              	.LBE343:
 4732              	.LBE321:
 246:main.c        **** 	{
 4733              		.loc 1 246 0
 4734 01c0 78309FE5 		ldr	r3, .L427+16
 4735 01c4 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 4736 01c8 030051E3 		cmp	r1, #3
 4737 01cc 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 4738 01d0 070000EA 		b	.L416
 4739              	.L421:
 4740 01d4 E4010000 		.word	.L417
 4741 01d8 E8010000 		.word	.L418
 4742 01dc EC010000 		.word	.L419
 4743 01e0 F0010000 		.word	.L420
 4744              	.L417:
 249:main.c        **** 		break;
 4745              		.loc 1 249 0
 4746 01e4 FEFFFFEB 		bl	mode_0
 4747              	.LVL351:
 4748              	.L418:
 253:main.c        **** 		break;
 4749              		.loc 1 253 0
 4750 01e8 FEFFFFEB 		bl	mode_1
 4751              	.LVL352:
 4752              	.L419:
 257:main.c        **** 		break;
 4753              		.loc 1 257 0
 4754 01ec FEFFFFEB 		bl	mode_2
 4755              	.LVL353:
 4756              	.L420:
 261:main.c        **** 		break;
 4757              		.loc 1 261 0
 4758 01f0 FEFFFFEB 		bl	mode_3
 4759              	.LVL354:
 4760              	.L416:
 265:main.c        **** 		break;
 4761              		.loc 1 265 0
 4762 01f4 50009FE5 		ldr	r0, .L427+28
 4763 01f8 FEFFFFEB 		bl	rprintf
 4764              	.LVL355:
 4765              	.LBB345:
 4766              	.LBB346:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4767              		.loc 1 1123 0
 4768 01fc 0450A0E3 		mov	r5, #4
 4769 0200 28409FE5 		ldr	r4, .L427
 4770 0204 0570A0E1 		mov	r7, r5
 4771              	.L422:
 4772              	.LVL356:
 4773              	.LBE346:
 4774              	.LBE345:
 4775              	.LBB348:
 4776              	.LBB349:
 4777              	.LBB350:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4778              		.loc 1 1118 0 discriminator 1
 4779 0208 026BA0E3 		mov	r6, #2048
 4780              	.LBE350:
 4781              	.LBE349:
 4782              	.LBE348:
 4783              	.LBB353:
 4784              	.LBB347:
1123:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4785              		.loc 1 1123 0 discriminator 1
 4786 020c 0C7084E5 		str	r7, [r4, #12]
 4787              	.LVL357:
 4788              	.LBE347:
 4789              	.LBE353:
 273:main.c        **** 		stat(0,OFF);
 4790              		.loc 1 273 0 discriminator 1
 4791 0210 FA0FA0E3 		mov	r0, #1000
 4792              	.LBB354:
 4793              	.LBB352:
 4794              	.LBB351:
1118:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4795              		.loc 1 1118 0 discriminator 1
 4796 0214 0C6084E5 		str	r6, [r4, #12]
 4797              	.LBE351:
 4798              	.LBE352:
 4799              	.LBE354:
 273:main.c        **** 		stat(0,OFF);
 4800              		.loc 1 273 0 discriminator 1
 4801 0218 FEFFFFEB 		bl	delay_ms
 4802              	.LVL358:
 4803              	.LBB355:
 4804              	.LBB356:
1124:main.c        **** 	}
 4805              		.loc 1 1124 0 discriminator 1
 4806 021c 045084E5 		str	r5, [r4, #4]
 4807              	.LVL359:
 4808              	.LBE356:
 4809              	.LBE355:
 276:main.c        **** 	}
 4810              		.loc 1 276 0 discriminator 1
 4811 0220 FA0FA0E3 		mov	r0, #1000
 4812              	.LBB357:
 4813              	.LBB358:
 4814              	.LBB359:
1119:main.c        **** 	}
 4815              		.loc 1 1119 0 discriminator 1
 4816 0224 046084E5 		str	r6, [r4, #4]
 4817              	.LBE359:
 4818              	.LBE358:
 4819              	.LBE357:
 276:main.c        **** 	}
 4820              		.loc 1 276 0 discriminator 1
 4821 0228 FEFFFFEB 		bl	delay_ms
 4822              	.LVL360:
 4823 022c F5FFFFEA 		b	.L422
 4824              	.L428:
 4825              		.align	2
 4826              	.L427:
 4827 0230 008002E0 		.word	-536707072
 4828 0234 9F020000 		.word	.LC31
 4829 0238 AB020000 		.word	.LC32
 4830 023c 00000000 		.word	handle
 4831 0240 00000000 		.word	.LANCHOR0
 4832 0244 00000000 		.word	.LANCHOR1
 4833 0248 20A10700 		.word	500000
 4834 024c BC020000 		.word	.LC33
 4835              		.cfi_endproc
 4836              	.LFE0:
 4838              		.text
 4839              		.align	2
 4840              		.global	GetGPSDateTime
 4842              	GetGPSDateTime:
 4843              	.LFB25:
1910:main.c        **** 
1911:main.c        **** /********************** GetGPSDateTime *********************************
1912:main.c        **** *  Each time the UART interrupt receives a 10 or 13 (end of line - pick one)r
1913:main.c        **** * it will call this function to strip off the date & time from the NMEA
1914:main.c        **** * sentence.
1915:main.c        **** *  Consideration should be given to situations when the most frequent NMEA
1916:main.c        **** * sentence is placed across the first and second buffer. Easiest solution 
1917:main.c        **** * would be to verify NMEA sentence length and make sure counter (RX_in) is
1918:main.c        **** * past or at a full packet
1919:main.c        **** * ? knowing an end of NMEA sentence has just occurred
1920:main.c        **** * ? see which ADC buffer is in use
1921:main.c        **** * ? reverse through buffer to find '$' if not found, just return
1922:main.c        **** * ? otherwise see if it's GGA (time) or RMC (time, date, and active)
1923:main.c        **** * ? if not, then continue
1924:main.c        **** * ? if so, then if GGA just get time (2nd field, just after 1st comma)
1925:main.c        **** * ? if so, then if RMC get:
1926:main.c        **** * ?    - time (2nd field, just after 1st comma)
1927:main.c        **** * ?    - active (3rd field, just after 2nd comma)
1928:main.c        **** * ?    - date (10th field, just after 9th comma)
1929:main.c        **** ************************************************************************/
1930:main.c        **** void GetGPSDateTime(void)
1931:main.c        **** {
 4844              		.loc 1 1931 0
 4845              		.cfi_startproc
 4846              		@ Function supports interworking.
 4847              		@ args = 0, pretend = 0, frame = 0
 4848              		@ frame_needed = 0, uses_anonymous_args = 0
 4849              		@ link register save eliminated.
 4850 219c 1EFF2FE1 		bx	lr
 4851              		.cfi_endproc
 4852              	.LFE25:
 4854              		.comm	time_buffer,8,1
 4855              		.comm	seconds,4,4
 4856              		.comm	minutes,4,4
 4857              		.comm	hours,4,4
 4858              		.global	use_adc
 4859              		.global	log_gps
 4860              		.global	gps_valid
 4861              		.comm	stringBuf,256,1
 4862              		.comm	fd,4,4
 4863              		.comm	handle,4,4
 4864              		.comm	ADCStringSize,4,4
 4865              		.comm	stringSize,4,4
 4866              		.global	get_frame
 4867              		.global	log_adc
 4868              		.global	ADC_in
 4869              		.global	RX_in
 4870              		.global	log_array2
 4871              		.global	log_array1
 4872              		.comm	ADC_array,512,1
 4873              		.comm	RX_array2,512,1
 4874              		.comm	RX_array1,512,1
 4875              		.section	.rodata.str1.1,"aMS",%progbits,1
 4876              	.LC0:
 4877 0000 256400   		.ascii	"%d\000"
 4878              	.LC1:
 4879 0003 20202000 		.ascii	"   \000"
 4880              	.LC2:
 4881 0007 53442049 		.ascii	"SD Init Error\012\015\000"
 4881      6E697420 
 4881      4572726F 
 4881      720A0D00 
 4882              	.LC3:
 4883 0017 5344204F 		.ascii	"SD OpenRoot Error\012\015\000"
 4883      70656E52 
 4883      6F6F7420 
 4883      4572726F 
 4883      720A0D00 
 4884              	.LC4:
 4885 002b 0A0D4C6F 		.ascii	"\012\015Logomatic V2 Test Code:\012\015\000"
 4885      676F6D61 
 4885      74696320 
 4885      56322054 
 4885      65737420 
 4886              	.LC5:
 4887 0047 41444320 		.ascii	"ADC Test will begin in 5 seconds, hit stop button t"
 4887      54657374 
 4887      2077696C 
 4887      6C206265 
 4887      67696E20 
 4888 007a 6F207465 		.ascii	"o terminate the test.\015\012\012\000"
 4888      726D696E 
 4888      61746520 
 4888      74686520 
 4888      74657374 
 4889              	.LC6:
 4890 0093 0A0D00   		.ascii	"\012\015\000"
 4891              	.LC7:
 4892 0096 0A0D5465 		.ascii	"\012\015Test complete, locking up...\012\015\000"
 4892      73742063 
 4892      6F6D706C 
 4892      6574652C 
 4892      206C6F63 
 4893              	.LC8:
 4894 00b7 4C4F4743 		.ascii	"LOGCON.txt\000"
 4894      4F4E2E74 
 4894      787400
 4895              	.LC9:
 4896 00c2 4572726F 		.ascii	"Error creating LOGCON.txt, locking up...\012\015\000"
 4896      72206372 
 4896      65617469 
 4896      6E67204C 
 4896      4F47434F 
 4897              	.LC10:
 4898 00ed 4D4F4445 		.ascii	"MODE = 0\015\012ASCII = N\015\012Baud = 4\015\012Fr"
 4898      203D2030 
 4898      0D0A4153 
 4898      43494920 
 4898      3D204E0D 
 4899 010e 65717565 		.ascii	"equency = 100\015\012Trigger Character = $\015\012T"
 4899      6E637920 
 4899      3D203130 
 4899      300D0A54 
 4899      72696767 
 4900 0135 65787420 		.ascii	"ext Frame = 100\015\012AD0.3 = N\015\012AD0.2 = N\015"
 4900      4672616D 
 4900      65203D20 
 4900      3130300D 
 4900      0A414430 
 4901 015b 0A414430 		.ascii	"\012AD0.1 = N\015\012AD0.4 = N\015\012AD1.7 = N\015"
 4901      2E31203D 
 4901      204E0D0A 
 4901      4144302E 
 4901      34203D20 
 4902 017c 0A414431 		.ascii	"\012AD1.6 = N\015\012AD1.2 = N\015\012AD1.3 = N\015"
 4902      2E36203D 
 4902      204E0D0A 
 4902      4144312E 
 4902      32203D20 
 4903 019d 0A536166 		.ascii	"\012Saftey On = Y\015\012\000"
 4903      74657920 
 4903      4F6E203D 
 4903      20590D0A 
 4903      00
 4904              	.LC11:
 4905 01ae 6D6F6465 		.ascii	"mode = %d\012\015\000"
 4905      203D2025 
 4905      640A0D00 
 4906              	.LC12:
 4907 01ba 61736320 		.ascii	"asc = %c\012\015\000"
 4907      3D202563 
 4907      0A0D00
 4908              	.LC13:
 4909 01c5 62617564 		.ascii	"baud = %d\012\015\000"
 4909      203D2025 
 4909      640A0D00 
 4910              	.LC14:
 4911 01d1 66726571 		.ascii	"freq = %d\012\015\000"
 4911      203D2025 
 4911      640A0D00 
 4912              	.LC15:
 4913 01dd 74726967 		.ascii	"trig = %c\012\015\000"
 4913      203D2025 
 4913      630A0D00 
 4914              	.LC16:
 4915 01e9 6672616D 		.ascii	"frame = %d\012\015\000"
 4915      65203D20 
 4915      25640A0D 
 4915      00
 4916              	.LC17:
 4917 01f6 6164305F 		.ascii	"ad0_3 = %c\012\015\000"
 4917      33203D20 
 4917      25630A0D 
 4917      00
 4918              	.LC18:
 4919 0203 6164305F 		.ascii	"ad0_2 = %c\012\015\000"
 4919      32203D20 
 4919      25630A0D 
 4919      00
 4920              	.LC19:
 4921 0210 6164305F 		.ascii	"ad0_1 = %c\012\015\000"
 4921      31203D20 
 4921      25630A0D 
 4921      00
 4922              	.LC20:
 4923 021d 6164305F 		.ascii	"ad0_4 = %c\012\015\000"
 4923      34203D20 
 4923      25630A0D 
 4923      00
 4924              	.LC21:
 4925 022a 6164315F 		.ascii	"ad1_7 = %c\012\015\000"
 4925      37203D20 
 4925      25630A0D 
 4925      00
 4926              	.LC22:
 4927 0237 6164315F 		.ascii	"ad1_6 = %c\012\015\000"
 4927      36203D20 
 4927      25630A0D 
 4927      00
 4928              	.LC23:
 4929 0244 6164315F 		.ascii	"ad1_2 = %c\012\015\000"
 4929      32203D20 
 4929      25630A0D 
 4929      00
 4930              	.LC24:
 4931 0251 6164315F 		.ascii	"ad1_3 = %c\012\015\000"
 4931      33203D20 
 4931      25630A0D 
 4931      00
 4932              	.LC25:
 4933 025e 73616665 		.ascii	"safety = %c\012\015\000"
 4933      7479203D 
 4933      2025630A 
 4933      0D00
 4934              	.LC26:
 4935 026c 25303264 		.ascii	"%02d:%02d:%02d\000"
 4935      3A253032 
 4935      643A2530 
 4935      326400
 4936              	.LC27:
 4937 027b 4D4F4445 		.ascii	"MODE 3\012\015\000"
 4937      20330A0D 
 4937      00
 4938              	.LC28:
 4939 0284 4D4F4445 		.ascii	"MODE 2\012\015\000"
 4939      20320A0D 
 4939      00
 4940              	.LC29:
 4941 028d 4D4F4445 		.ascii	"MODE 1\012\015\000"
 4941      20310A0D 
 4941      00
 4942              	.LC30:
 4943 0296 4D4F4445 		.ascii	"MODE 0\012\015\000"
 4943      20300A0D 
 4943      00
 4944              	.LC31:
 4945 029f 4C4F4725 		.ascii	"LOG%02d.txt\000"
 4945      3032642E 
 4945      74787400 
 4946              	.LC32:
 4947 02ab 546F6F20 		.ascii	"Too Many Logs!\012\015\000"
 4947      4D616E79 
 4947      204C6F67 
 4947      73210A0D 
 4947      00
 4948              	.LC33:
 4949 02bc 4D6F6465 		.ascii	"Mode %d not valid.\012\015\000"
 4949      20256420 
 4949      6E6F7420 
 4949      76616C69 
 4949      642E0A0D 
 4950              		.data
 4951              		.align	2
 4952              		.set	.LANCHOR1,. + 0
 4955              	trig:
 4956 0000 24       		.byte	36
 4957 0001 00       		.space	1
 4960              	frame:
 4961 0002 6400     		.short	100
 4964              	ad0_3:
 4965 0004 4E       		.byte	78
 4968              	asc:
 4969 0005 4E       		.byte	78
 4972              	ad0_2:
 4973 0006 4E       		.byte	78
 4976              	ad0_1:
 4977 0007 4E       		.byte	78
 4980              	ad0_4:
 4981 0008 4E       		.byte	78
 4984              	ad1_7:
 4985 0009 4E       		.byte	78
 4988              	ad1_6:
 4989 000a 4E       		.byte	78
 4992              	ad1_2:
 4993 000b 4E       		.byte	78
 4996              	ad1_3:
 4997 000c 4E       		.byte	78
 4998 000d 000000   		.space	3
 5001              	baud:
 5002 0010 80250000 		.word	9600
 5005              	freq:
 5006 0014 64000000 		.word	100
 5007              		.bss
 5008              		.align	2
 5009              		.set	.LANCHOR0,. + 0
 5012              	RX_in:
 5013 0000 0000     		.space	2
 5016              	log_array1:
 5017 0002 00       		.space	1
 5020              	log_array2:
 5021 0003 00       		.space	1
 5024              	get_frame:
 5025 0004 00       		.space	1
 5028              	mode:
 5029 0005 00       		.space	1
 5032              	ADC_in:
 5033 0006 0000     		.space	2
 5036              	log_adc:
 5037 0008 00       		.space	1
 5038 0009 000000   		.space	3
 5041              	use_adc:
 5042 000c 00000000 		.space	4
 5045              	log_gps:
 5046 0010 00000000 		.space	4
 5049              	gps_valid:
 5050 0014 00000000 		.space	4
 5051              		.text
 5052              	.Letext0:
 5053              		.file 2 "/opt/local/lib/gcc/arm-elf/4.7.3/include/stddef.h"
 5054              		.file 3 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/stdint.h"
 5055              		.file 4 "../lib/rprintf.h"
 5056              		.file 5 "../LPCUSB/armVIC.h"
 5057              		.file 6 "../lib/sd_raw.h"
 5058              		.file 7 "../lib/rootdir.h"
 5059              		.file 8 "../lib/itoa.h"
 5060              		.file 9 "../lib/fat.h"
 5061              		.file 10 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/string.h"
 5062              		.file 11 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5      .text:0000000000000000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:7      .text:0000000000000000 UART0ISR
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:82     .text:0000000000000090 $d
                            *COM*:0000000000000200 RX_array1
                            *COM*:0000000000000200 RX_array2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:89     .text:00000000000000a0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:91     .text:00000000000000a0 UART0ISR_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:220    .text:00000000000001b8 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:228    .text:00000000000001cc $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:230    .text:00000000000001cc MODE2ISR
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1594   .text:0000000000000dd4 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1612   .text:0000000000000e10 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1615   .text:0000000000000e10 Initialize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1659   .text:0000000000000e68 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1666   .text:0000000000000e78 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1669   .text:0000000000000e78 feed
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1688   .text:0000000000000e90 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1692   .text:0000000000000e94 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1695   .text:0000000000000e94 FIQ_Routine
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1736   .text:0000000000000ebc $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1740   .text:0000000000000ec0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1743   .text:0000000000000ec0 SWI_Routine
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1760   .text:0000000000000ec4 UNDEF_Routine
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1789   .text:0000000000000edc $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1793   .text:0000000000000ee0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1796   .text:0000000000000ee0 setup_uart0
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1978   .text:0000000000001048 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1986   .text:000000000000105c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:1989   .text:000000000000105c stat
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2024   .text:0000000000001088 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2028   .text:000000000000108c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2031   .text:000000000000108c AD_conversion
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2120   .text:0000000000001118 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2128   .text:000000000000112c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2131   .text:000000000000112c fat_initialize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2169   .text:0000000000001160 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2174   .text:0000000000001168 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2177   .text:0000000000001168 delay_ms
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2211   .text:000000000000118c $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2215   .text:0000000000001190 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2218   .text:0000000000001190 test
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2344   .text:000000000000125c $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2361   .text:0000000000001294 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2364   .text:0000000000001294 Log_init
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:2982   .text:00000000000017a8 $d
                            *COM*:0000000000000004 fd
                            *COM*:0000000000000100 stringBuf
                            *COM*:0000000000000004 stringSize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3015   .text:0000000000001820 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3018   .text:0000000000001820 GetADCValue
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3039   .text:0000000000001834 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3049   .text:0000000000001854 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3389   .text:0000000000001b58 $d
                            *COM*:0000000000000200 ADC_array
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3404   .text:0000000000001b88 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3407   .text:0000000000001b88 InitializeTime
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3433   .text:0000000000001bb0 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3437   .text:0000000000001bb4 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3440   .text:0000000000001bb4 GetTime
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3480   .text:0000000000001c04 $d
                            *COM*:0000000000000004 hours
                            *COM*:0000000000000004 minutes
                            *COM*:0000000000000004 seconds
                            *COM*:0000000000000008 time_buffer
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3489   .text:0000000000001c1c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3492   .text:0000000000001c1c LogADC
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3729   .text:0000000000001e28 $d
                            *COM*:0000000000000004 ADCStringSize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3738   .text:0000000000001e40 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:3741   .text:0000000000001e40 mode_action
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4142   .text:0000000000002020 $d
                            *COM*:0000000000000004 handle
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4157   .text:0000000000002044 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4160   .text:0000000000002044 mode_3
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4198   .text:0000000000002080 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4206   .text:0000000000002090 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4209   .text:0000000000002090 mode_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4277   .text:0000000000002114 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4285   .text:0000000000002128 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4288   .text:0000000000002128 mode_1
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4322   .text:0000000000002158 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4328   .text:0000000000002164 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4331   .text:0000000000002164 mode_0
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4362   .text:0000000000002190 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4369   .text.startup:0000000000000000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4372   .text.startup:0000000000000000 main
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4740   .text.startup:00000000000001d4 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4746   .text.startup:00000000000001e4 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4827   .text.startup:0000000000000230 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4839   .text:000000000000219c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4842   .text:000000000000219c GetGPSDateTime
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5041   .bss:000000000000000c use_adc
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5045   .bss:0000000000000010 log_gps
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5049   .bss:0000000000000014 gps_valid
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5024   .bss:0000000000000004 get_frame
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5036   .bss:0000000000000008 log_adc
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5032   .bss:0000000000000006 ADC_in
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5012   .bss:0000000000000000 RX_in
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5020   .bss:0000000000000003 log_array2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5016   .bss:0000000000000002 log_array1
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4951   .data:0000000000000000 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4955   .data:0000000000000000 trig
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4960   .data:0000000000000002 frame
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4964   .data:0000000000000004 ad0_3
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4968   .data:0000000000000005 asc
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4972   .data:0000000000000006 ad0_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4976   .data:0000000000000007 ad0_1
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4980   .data:0000000000000008 ad0_4
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4984   .data:0000000000000009 ad1_7
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4988   .data:000000000000000a ad1_6
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4992   .data:000000000000000b ad1_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:4996   .data:000000000000000c ad1_3
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5001   .data:0000000000000010 baud
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5005   .data:0000000000000014 freq
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5008   .bss:0000000000000000 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccVYxUPK.s:5028   .bss:0000000000000005 mode
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
itoa
rprintf_devopen
putc_serial0
enableIRQ
rprintf
sd_raw_init
openroot
root_file_exists
root_open
fat_read_file
fat_close_file
root_open_new
strcpy
strlen
fat_write_file
sd_raw_sync
sprintf
__divsi3
enableFIQ
string_printf
