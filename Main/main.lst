   1              		.file	"main.c"
   2              		.text
   3              	.Ltext0:
   4              		.cfi_sections	.debug_frame
   5              		.align	2
   7              	UART0ISR:
   8              	.LFB3:
   9              		.file 1 "main.c"
   1:main.c        **** /*********************************************************************************
   2:main.c        ****  * Logomatic V2 Firmware
   3:main.c        ****  * Sparkfun Electronics 2008
   4:main.c        ****  * ******************************************************************************/
   5:main.c        **** 
   6:main.c        **** /*******************************************************
   7:main.c        ****  * 		     Header Files
   8:main.c        ****  ******************************************************/
   9:main.c        **** #include <stdio.h>
  10:main.c        **** #include <string.h>
  11:main.c        **** #include "LPC21xx.h"
  12:main.c        **** 
  13:main.c        **** //UART0 Debugging
  14:main.c        **** #include "serial.h"
  15:main.c        **** #include "rprintf.h"
  16:main.c        **** 
  17:main.c        **** //Needed for main function calls
  18:main.c        **** #include "main_msc.h"
  19:main.c        **** #include "fat.h"
  20:main.c        **** #include "armVIC.h"
  21:main.c        **** #include "itoa.h"
  22:main.c        **** #include "rootdir.h"
  23:main.c        **** #include "sd_raw.h"
  24:main.c        **** 
  25:main.c        **** /*********************************************************
  26:main.c        **** *               Program Change Ideas
  27:main.c        **** *  Need to log both GPS and ADC
  28:main.c        **** *  ADC1 = TMP36 (temperature)
  29:main.c        **** *  ADC2 = ADXL326-Xout
  30:main.c        **** *  ADC3 = ADXL326-Yout
  31:main.c        **** *  ADC4 = ADXL326-Zout
  32:main.c        **** *  UART0 (RX1 & TX1?) GPS @ 9600 TTL
  33:main.c        **** 
  34:main.c        **** *  Use UART0 character in Interrupt
  35:main.c        **** *  See if character is ASCII 10 or 13 (only test for one)
  36:main.c        **** *  which is the end of a NMEA sentence
  37:main.c        **** *  If so, trigger an ADC read?? Means an ADC read with 
  38:main.c        **** *  EVERY NMEA sentence (way too often) but otherwise need
  39:main.c        **** *  to scan buffer for NMEA sentence type and trigger off
  40:main.c        **** *  one known to only happen 1/sec (1hz)??
  41:main.c        **** 
  42:main.c        ****   - consider stripping date/time from GPS NMEA sentence
  43:main.c        ****   - and adding to beginning of each ADC logging?
  44:main.c        **** 
  45:main.c        **** *  Version 1 - scan/log ADC with each GPS NMEA sentence
  46:main.c        **** *  Version 2 - parse NMEA and only trigger ADC on one type
  47:main.c        **** **********************************************************/
  48:main.c        **** 
  49:main.c        **** 
  50:main.c        **** /*******************************************************
  51:main.c        ****  * 		     Global Variables
  52:main.c        ****  ******************************************************/
  53:main.c        **** 
  54:main.c        **** #define ON	1
  55:main.c        **** #define OFF	0
  56:main.c        **** #define TRUE 1
  57:main.c        **** #define FALSE 0
  58:main.c        **** #define ADC_1 1
  59:main.c        **** #define ADC_2 2
  60:main.c        **** #define ADC_3 3
  61:main.c        **** #define ADC_4 4
  62:main.c        **** #define ADC_5 5
  63:main.c        **** #define ADC_6 6
  64:main.c        **** #define ADC_7 7
  65:main.c        **** #define ADC_8 8
  66:main.c        **** 
  67:main.c        **** char RX_array1[512];
  68:main.c        **** char RX_array2[512];
  69:main.c        **** char ADC_array[512];
  70:main.c        **** char log_array1 = 0;
  71:main.c        **** char log_array2 = 0;
  72:main.c        **** short RX_in = 0;
  73:main.c        **** short ADC_in = 0;
  74:main.c        **** char log_adc = 0;
  75:main.c        **** char get_frame = 0;
  76:main.c        **** 
  77:main.c        **** signed int stringSize;
  78:main.c        **** signed int ADCStringSize;
  79:main.c        **** struct fat_file_struct* handle;
  80:main.c        **** struct fat_file_struct * fd;
  81:main.c        **** char stringBuf[256];
  82:main.c        **** unsigned int gps_valid = FALSE;
  83:main.c        **** unsigned int log_gps = FALSE;
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        **** // Default Settings
  87:main.c        **** static char mode = 0;
  88:main.c        **** static char asc = 'N';
  89:main.c        **** static int baud = 9600;
  90:main.c        **** static int freq = 100;
  91:main.c        **** static char trig = '$';
  92:main.c        **** static short frame = 100;
  93:main.c        **** static char ad1_7 = 'N';	// ADC 5
  94:main.c        **** static char ad1_6 = 'N';	// ADC 6
  95:main.c        **** static char ad1_3 = 'N';	// ADC 8
  96:main.c        **** static char ad1_2 = 'N';	// ADC 7
  97:main.c        **** static char ad0_4 = 'N';	// ADC 4
  98:main.c        **** static char ad0_3 = 'N';	// ADC 1
  99:main.c        **** static char ad0_2 = 'N';	// ADC 2
 100:main.c        **** static char ad0_1 = 'N';	// ADC 3
 101:main.c        **** 
 102:main.c        **** 
 103:main.c        **** /*******************************************************
 104:main.c        ****  * 		 Function Declarations
 105:main.c        ****  ******************************************************/
 106:main.c        **** 
 107:main.c        **** void Initialize(void);
 108:main.c        **** 
 109:main.c        **** void setup_uart0(int newbaud, char want_ints);
 110:main.c        **** 
 111:main.c        **** void mode_0(void);
 112:main.c        **** void mode_1(void);
 113:main.c        **** void mode_2(void);
 114:main.c        **** void mode_action(void);
 115:main.c        **** 
 116:main.c        **** void Log_init(void);
 117:main.c        **** void test(void);
 118:main.c        **** void stat(int statnum, int onoff);
 119:main.c        **** void AD_conversion(int regbank);
 120:main.c        **** 
 121:main.c        **** void feed(void);
 122:main.c        **** 
 123:main.c        **** static void IRQ_Routine(void) __attribute__ ((interrupt("IRQ")));
 124:main.c        **** static void UART0ISR(void); //__attribute__ ((interrupt("IRQ")));
 125:main.c        **** static void UART0ISR_2(void); //__attribute__ ((interrupt("IRQ")));
 126:main.c        **** static void MODE2ISR(void); //__attribute__ ((interrupt("IRQ")));
 127:main.c        **** 
 128:main.c        **** void FIQ_Routine(void) __attribute__ ((interrupt("FIQ")));
 129:main.c        **** void SWI_Routine(void) __attribute__ ((interrupt("SWI")));
 130:main.c        **** void UNDEF_Routine(void) __attribute__ ((interrupt("UNDEF")));
 131:main.c        **** 
 132:main.c        **** void LogADC(void);
 133:main.c        **** void GetADCValue(int adc);
 134:main.c        **** 
 135:main.c        **** void fat_initialize(void);
 136:main.c        **** 
 137:main.c        **** void delay_ms(int count);
 138:main.c        **** 
 139:main.c        **** void GetGPSDateTime(void);
 140:main.c        **** 
 141:main.c        **** 
 142:main.c        **** /*******************************************************
 143:main.c        ****  * 		     	MAIN
 144:main.c        ****  ******************************************************/
 145:main.c        **** 
 146:main.c        **** int main (void)
 147:main.c        **** {
 148:main.c        **** 	int i;
 149:main.c        **** 	char name[32];
 150:main.c        **** 	int count = 0;
 151:main.c        **** 	
 152:main.c        **** 	enableFIQ();
 153:main.c        **** 	
 154:main.c        **** 	Initialize();
 155:main.c        **** 	
 156:main.c        **** 	setup_uart0(9600, 0);
 157:main.c        **** 
 158:main.c        **** 	fat_initialize();		
 159:main.c        **** 
 160:main.c        **** 
 161:main.c        **** 	// Flash Status Lights
 162:main.c        **** 	for(i = 0; i < 5; i++)
 163:main.c        **** 	{
 164:main.c        **** 		stat(0,ON);
 165:main.c        **** 		delay_ms(50);
 166:main.c        **** 		stat(0,OFF);
 167:main.c        **** 		stat(1,ON);
 168:main.c        **** 		delay_ms(50);
 169:main.c        **** 		stat(1,OFF);
 170:main.c        **** 	}
 171:main.c        **** 	
 172:main.c        **** 	Log_init();
 173:main.c        **** 
 174:main.c        **** 	count++;
 175:main.c        **** 	string_printf(name,"LOG%02d.txt",count);
 176:main.c        **** 	while(root_file_exists(name))
 177:main.c        **** 	{
 178:main.c        **** 		count++;
 179:main.c        **** 		if(count == 250) 
 180:main.c        **** 		{
 181:main.c        **** 			rprintf("Too Many Logs!\n\r");
 182:main.c        **** 			while(1)
 183:main.c        **** 			{
 184:main.c        **** 				stat(0,ON);
 185:main.c        **** 				stat(1,ON);
 186:main.c        **** 				delay_ms(1000);
 187:main.c        **** 				stat(0,OFF);
 188:main.c        **** 				stat(1,OFF);
 189:main.c        **** 				delay_ms(1000);
 190:main.c        **** 			}
 191:main.c        **** 
 192:main.c        **** 		}
 193:main.c        **** 		string_printf(name,"LOG%02d.txt",count);
 194:main.c        **** 	}
 195:main.c        **** 	
 196:main.c        **** 	handle = root_open_new(name);
 197:main.c        **** 		
 198:main.c        **** 
 199:main.c        **** 	sd_raw_sync();	
 200:main.c        **** 	
 201:main.c        **** 	// if mode = 2 (ADC) then write out the ADC pins in use
 202:main.c        **** 	if(mode == 2)
 203:main.c        **** 	{
 204:main.c        **** 		char mybuf[10];	// eight pins + CR/LF
 205:main.c        **** 		mybuf[0] = ad1_3;
 206:main.c        **** 		mybuf[1] = ad0_3;
 207:main.c        **** 		mybuf[2] = ad0_2;
 208:main.c        **** 		mybuf[3] = ad0_1;
 209:main.c        **** 		mybuf[4] = ad1_2;
 210:main.c        **** 		mybuf[5] = ad0_4;
 211:main.c        **** 		mybuf[6] = ad1_7;
 212:main.c        **** 		mybuf[7] = ad1_6;
 213:main.c        **** 		mybuf[8] = 13;
 214:main.c        **** 		mybuf[9] = 10;	
 215:main.c        **** 	
 216:main.c        **** 		stat(0,ON);
 217:main.c        **** 				
 218:main.c        **** 		if(fat_write_file(handle,(unsigned char *)mybuf, 10) < 0)
 219:main.c        **** 		{
 220:main.c        **** 			while(1)
 221:main.c        **** 			{
 222:main.c        **** 				stat(0,ON);
 223:main.c        **** 				for(int j = 0; j < 500000; j++)
 224:main.c        **** 				stat(0,OFF);
 225:main.c        **** 				stat(1,ON);
 226:main.c        **** 				for(int j = 0; j < 500000; j++)
 227:main.c        **** 				stat(1,OFF);
 228:main.c        **** 			}
 229:main.c        **** 		}
 230:main.c        **** 			
 231:main.c        **** 		sd_raw_sync();
 232:main.c        **** 		stat(0,OFF);
 233:main.c        **** 	}	
 234:main.c        **** 	
 235:main.c        **** 	if(mode == 0){ mode_0(); }
 236:main.c        **** 	else if(mode == 1){ mode_1(); }
 237:main.c        **** 	else if(mode == 2){ mode_2(); }
 238:main.c        **** 
 239:main.c        ****     	return 0;
 240:main.c        **** }
 241:main.c        **** 
 242:main.c        **** 
 243:main.c        **** /*******************************************************
 244:main.c        ****  * 		     Initialize
 245:main.c        ****  ******************************************************/
 246:main.c        **** 
 247:main.c        **** #define PLOCK 0x400
 248:main.c        **** 
 249:main.c        **** void Initialize(void)
 250:main.c        **** {
 251:main.c        **** 	rprintf_devopen(putc_serial0);
 252:main.c        **** 	
 253:main.c        **** 	PINSEL0 = 0xCF351505;
 254:main.c        **** 	PINSEL1 = 0x15441801;
 255:main.c        **** 	IODIR0 |= 0x00000884;
 256:main.c        **** 	IOSET0 = 0x00000080;
 257:main.c        **** 
 258:main.c        **** 	S0SPCR = 0x08;  // SPI clk to be pclk/8
 259:main.c        **** 	S0SPCR = 0x30;  // master, msb, first clk edge, active high, no ints
 260:main.c        **** 
 261:main.c        **** }
 262:main.c        **** 
 263:main.c        **** void feed(void)
 264:main.c        **** {
 265:main.c        **** 	PLLFEED=0xAA;
 266:main.c        **** 	PLLFEED=0x55;
 267:main.c        **** }
 268:main.c        **** 
 269:main.c        **** /*******************************************
 270:main.c        **** * UART interrupt calls this function which
 271:main.c        **** * retrieves the arriving character that triggered
 272:main.c        **** * the interrupt and saves the character to the
 273:main.c        **** * buffer which is written to the microSD when
 274:main.c        **** * the buffer is full
 275:main.c        **** *******************************************/
 276:main.c        **** static void UART0ISR(void)
 277:main.c        **** {
  10              		.loc 1 277 0
  11              		.cfi_startproc
  12              		@ Function supports interworking.
  13              		@ args = 0, pretend = 0, frame = 0
  14              		@ frame_needed = 0, uses_anonymous_args = 0
  15              		@ link register save eliminated.
 278:main.c        **** 	char temp;
 279:main.c        **** 
 280:main.c        **** 
 281:main.c        **** 	if(RX_in < 512)
  16              		.loc 1 281 0
  17 0000 88309FE5 		ldr	r3, .L6
  18 0004 B020D3E1 		ldrh	r2, [r3, #0]
  19 0008 02C8A0E1 		mov	ip, r2, asl #16
  20 000c 4C18A0E1 		mov	r1, ip, asr #16
  21 0010 7C009FE5 		ldr	r0, .L6+4
  22 0014 020C51E3 		cmp	r1, #512
 282:main.c        **** 	{
 283:main.c        **** 		RX_array1[RX_in] = U0RBR;
  23              		.loc 1 283 0
  24 0018 0000D0E5 		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 281:main.c        **** 	{
  25              		.loc 1 281 0
  26 001c 090000AA 		bge	.L2
 284:main.c        **** 	
 285:main.c        **** 		RX_in++;
  27              		.loc 1 285 0
  28 0020 012082E2 		add	r2, r2, #1
  29 0024 0228A0E1 		mov	r2, r2, asl #16
  30 0028 2228A0E1 		mov	r2, r2, lsr #16
 286:main.c        **** 
 287:main.c        **** 		if(RX_in == 512) log_array1 = 1;
  31              		.loc 1 287 0
  32 002c 020C52E3 		cmp	r2, #512
 283:main.c        **** 	
  33              		.loc 1 283 0
  34 0030 60109FE5 		ldr	r1, .L6+8
 285:main.c        **** 
  35              		.loc 1 285 0
  36 0034 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  37              		.loc 1 287 0
  38 0038 0120A003 		moveq	r2, #1
 283:main.c        **** 	
  39              		.loc 1 283 0
  40 003c 4C08C1E7 		strb	r0, [r1, ip, asr #16]
  41              		.loc 1 287 0
  42 0040 0220C305 		streqb	r2, [r3, #2]
  43 0044 0B0000EA 		b	.L4
  44              	.L2:
 288:main.c        **** 	}
 289:main.c        **** 	else if(RX_in >= 512)
 290:main.c        **** 	{
 291:main.c        **** 		RX_array2[RX_in-512] = U0RBR;
 292:main.c        **** 		RX_in++;
  45              		.loc 1 292 0
  46 0048 012082E2 		add	r2, r2, #1
  47 004c 0228A0E1 		mov	r2, r2, asl #16
  48 0050 2228A0E1 		mov	r2, r2, lsr #16
 293:main.c        **** 
 294:main.c        **** 		if(RX_in == 1024)
  49              		.loc 1 294 0
  50 0054 010B52E3 		cmp	r2, #1024
 291:main.c        **** 		RX_in++;
  51              		.loc 1 291 0
  52 0058 3CC09FE5 		ldr	ip, .L6+12
 292:main.c        **** 
  53              		.loc 1 292 0
  54 005c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 295:main.c        **** 		{
 296:main.c        **** 			log_array2 = 1;
  55              		.loc 1 296 0
  56 0060 0120A003 		moveq	r2, #1
 291:main.c        **** 		RX_in++;
  57              		.loc 1 291 0
  58 0064 01108CE0 		add	r1, ip, r1
  59              		.loc 1 296 0
  60 0068 0320C305 		streqb	r2, [r3, #3]
 297:main.c        **** 			RX_in = 0;
  61              		.loc 1 297 0
  62 006c 0020A003 		moveq	r2, #0
 291:main.c        **** 		RX_in++;
  63              		.loc 1 291 0
  64 0070 000241E5 		strb	r0, [r1, #-512]
  65              		.loc 1 297 0
  66 0074 B020C301 		streqh	r2, [r3, #0]	@ movhi
  67              	.L4:
 298:main.c        **** 		}
 299:main.c        **** 	}
 300:main.c        **** 
 301:main.c        **** 
 302:main.c        **** 	temp = U0IIR; // Have to read this to clear the interrupt 
  68              		.loc 1 302 0
  69 0078 14309FE5 		ldr	r3, .L6+4
 303:main.c        **** 
 304:main.c        **** 	VICVectAddr = 0;
  70              		.loc 1 304 0
  71 007c 0020A0E3 		mov	r2, #0
 302:main.c        **** 
  72              		.loc 1 302 0
  73 0080 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
  74              	.LVL0:
  75              		.loc 1 304 0
  76 0084 0030E0E3 		mvn	r3, #0
  77 0088 CF2F03E5 		str	r2, [r3, #-4047]
  78 008c 1EFF2FE1 		bx	lr
  79              	.L7:
  80              		.align	2
  81              	.L6:
  82 0090 00000000 		.word	.LANCHOR0
  83 0094 00C000E0 		.word	-536821760
  84 0098 00000000 		.word	RX_array1
  85 009c 00000000 		.word	RX_array2
  86              		.cfi_endproc
  87              	.LFE3:
  89              		.align	2
  91              	UART0ISR_2:
  92              	.LFB4:
 305:main.c        **** 	
 306:main.c        **** }
 307:main.c        **** 
 308:main.c        **** static void UART0ISR_2(void)
 309:main.c        **** {
  93              		.loc 1 309 0
  94              		.cfi_startproc
  95              		@ Function supports interworking.
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98              		@ link register save eliminated.
  99 00a0 30002DE9 		stmfd	sp!, {r4, r5}
 100              	.LCFI0:
 101              		.cfi_def_cfa_offset 8
 102              		.cfi_offset 4, -8
 103              		.cfi_offset 5, -4
 310:main.c        **** 	char temp;
 311:main.c        **** 	temp = U0RBR;
 104              		.loc 1 311 0
 105 00a4 0C319FE5 		ldr	r3, .L14
 106 00a8 00C0D3E5 		ldrb	ip, [r3, #0]	@ zero_extendqisi2
 312:main.c        **** 
 313:main.c        **** 	if(temp == trig){ get_frame = 1; }
 107              		.loc 1 313 0
 108 00ac 08319FE5 		ldr	r3, .L14+4
 109 00b0 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 311:main.c        **** 
 110              		.loc 1 311 0
 111 00b4 FFC00CE2 		and	ip, ip, #255
 112              	.LVL1:
 113              		.loc 1 313 0
 114 00b8 0C0053E1 		cmp	r3, ip
 115 00bc FC209FE5 		ldr	r2, .L14+8
 116 00c0 0130A003 		moveq	r3, #1
 117 00c4 0430C205 		streqb	r3, [r2, #4]
 314:main.c        **** 	
 315:main.c        **** 	if(get_frame)
 118              		.loc 1 315 0
 119 00c8 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 120 00cc 000052E3 		cmp	r2, #0
 121 00d0 E8309FE5 		ldr	r3, .L14+8
 122 00d4 3000000A 		beq	.L11
 316:main.c        **** 	{
 317:main.c        **** 		if(RX_in < frame)
 123              		.loc 1 317 0
 124 00d8 B000D3E1 		ldrh	r0, [r3, #0]
 125 00dc D8209FE5 		ldr	r2, .L14+4
 126 00e0 0058A0E1 		mov	r5, r0, asl #16
 127 00e4 F220D2E1 		ldrsh	r2, [r2, #2]
 128 00e8 4548A0E1 		mov	r4, r5, asr #16
 129 00ec 020054E1 		cmp	r4, r2
 130 00f0 010080E2 		add	r0, r0, #1
 131 00f4 120000AA 		bge	.L12
 318:main.c        **** 		{
 319:main.c        **** 			RX_array1[RX_in] = temp;
 320:main.c        **** 			RX_in++;
 132              		.loc 1 320 0
 133 00f8 0008A0E1 		mov	r0, r0, asl #16
 134 00fc 2008A0E1 		mov	r0, r0, lsr #16
 319:main.c        **** 			RX_in++;
 135              		.loc 1 319 0
 136 0100 BC109FE5 		ldr	r1, .L14+12
 137              		.loc 1 320 0
 138 0104 B000C3E1 		strh	r0, [r3, #0]	@ movhi
 321:main.c        **** 
 322:main.c        **** 			if(RX_in == frame)
 139              		.loc 1 322 0
 140 0108 0008A0E1 		mov	r0, r0, asl #16
 319:main.c        **** 			RX_in++;
 141              		.loc 1 319 0
 142 010c 45C8C1E7 		strb	ip, [r1, r5, asr #16]
 143              		.loc 1 322 0
 144 0110 40C8A0E1 		mov	ip, r0, asr #16
 145              	.LVL2:
 146 0114 02005CE1 		cmp	ip, r2
 147 0118 1F00001A 		bne	.L11
 323:main.c        **** 			{
 324:main.c        **** 				RX_array1[RX_in] = 10; // delimiters
 148              		.loc 1 324 0
 149 011c 0A20A0E3 		mov	r2, #10
 150 0120 4028C1E7 		strb	r2, [r1, r0, asr #16]
 325:main.c        **** 				RX_array1[RX_in + 1] = 13;
 151              		.loc 1 325 0
 152 0124 0D20A0E3 		mov	r2, #13
 153 0128 0C1081E0 		add	r1, r1, ip
 154 012c 0120C1E5 		strb	r2, [r1, #1]
 326:main.c        **** 				log_array1 = 1;
 155              		.loc 1 326 0
 156 0130 0120A0E3 		mov	r2, #1
 157 0134 0220C3E5 		strb	r2, [r3, #2]
 327:main.c        **** 				get_frame = 0;
 158              		.loc 1 327 0
 159 0138 0020A0E3 		mov	r2, #0
 160 013c 0420C3E5 		strb	r2, [r3, #4]
 161 0140 150000EA 		b	.L11
 162              	.LVL3:
 163              	.L12:
 328:main.c        **** 			}
 329:main.c        **** 		}
 330:main.c        **** 		else if(RX_in >= frame)
 331:main.c        **** 		{
 332:main.c        **** 			RX_array2[RX_in - frame] = temp;
 333:main.c        **** 			RX_in++;
 164              		.loc 1 333 0
 165 0144 0008A0E1 		mov	r0, r0, asl #16
 166 0148 2008A0E1 		mov	r0, r0, lsr #16
 167 014c B000C3E1 		strh	r0, [r3, #0]	@ movhi
 334:main.c        **** 
 335:main.c        **** 			if(RX_in == 2*frame)
 168              		.loc 1 335 0
 169 0150 0008A0E1 		mov	r0, r0, asl #16
 332:main.c        **** 			RX_in++;
 170              		.loc 1 332 0
 171 0154 6C109FE5 		ldr	r1, .L14+16
 172              		.loc 1 335 0
 173 0158 4008A0E1 		mov	r0, r0, asr #16
 332:main.c        **** 			RX_in++;
 174              		.loc 1 332 0
 175 015c 044062E0 		rsb	r4, r2, r4
 176              		.loc 1 335 0
 177 0160 820050E1 		cmp	r0, r2, asl #1
 332:main.c        **** 			RX_in++;
 178              		.loc 1 332 0
 179 0164 04C0C1E7 		strb	ip, [r1, r4]
 180              		.loc 1 335 0
 181 0168 0B00001A 		bne	.L11
 336:main.c        **** 			{
 337:main.c        **** 				RX_array2[RX_in - frame] = 10; // delimiters
 182              		.loc 1 337 0
 183 016c 00C062E0 		rsb	ip, r2, r0
 184              	.LVL4:
 338:main.c        **** 				RX_array2[RX_in + 1 - frame] = 13;
 185              		.loc 1 338 0
 186 0170 010080E2 		add	r0, r0, #1
 187 0174 002062E0 		rsb	r2, r2, r0
 337:main.c        **** 				RX_array2[RX_in + 1 - frame] = 13;
 188              		.loc 1 337 0
 189 0178 0A40A0E3 		mov	r4, #10
 190              		.loc 1 338 0
 191 017c 0D00A0E3 		mov	r0, #13
 337:main.c        **** 				RX_array2[RX_in + 1 - frame] = 13;
 192              		.loc 1 337 0
 193 0180 0C40C1E7 		strb	r4, [r1, ip]
 194              		.loc 1 338 0
 195 0184 0200C1E7 		strb	r0, [r1, r2]
 339:main.c        **** 				log_array2 = 1;
 196              		.loc 1 339 0
 197 0188 0120A0E3 		mov	r2, #1
 198 018c 0320C3E5 		strb	r2, [r3, #3]
 340:main.c        **** 				get_frame = 0;
 199              		.loc 1 340 0
 200 0190 0020A0E3 		mov	r2, #0
 201 0194 0420C3E5 		strb	r2, [r3, #4]
 341:main.c        **** 				RX_in = 0;
 202              		.loc 1 341 0
 203 0198 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 204              	.L11:
 342:main.c        **** 			}
 343:main.c        **** 		}
 344:main.c        **** 	}
 345:main.c        **** 
 346:main.c        **** 	temp = U0IIR; // have to read this to clear the interrupt
 205              		.loc 1 346 0
 206 019c 14309FE5 		ldr	r3, .L14
 347:main.c        **** 
 348:main.c        **** 	VICVectAddr = 0;
 207              		.loc 1 348 0
 208 01a0 0020A0E3 		mov	r2, #0
 346:main.c        **** 
 209              		.loc 1 346 0
 210 01a4 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 211              		.loc 1 348 0
 212 01a8 0030E0E3 		mvn	r3, #0
 213 01ac CF2F03E5 		str	r2, [r3, #-4047]
 349:main.c        **** }
 214              		.loc 1 349 0
 215 01b0 3000BDE8 		ldmfd	sp!, {r4, r5}
 216 01b4 1EFF2FE1 		bx	lr
 217              	.L15:
 218              		.align	2
 219              	.L14:
 220 01b8 00C000E0 		.word	-536821760
 221 01bc 00000000 		.word	.LANCHOR1
 222 01c0 00000000 		.word	.LANCHOR0
 223 01c4 00000000 		.word	RX_array1
 224 01c8 00000000 		.word	RX_array2
 225              		.cfi_endproc
 226              	.LFE4:
 228              		.align	2
 230              	MODE2ISR:
 231              	.LFB5:
 350:main.c        **** 		
 351:main.c        **** static void MODE2ISR(void)
 352:main.c        **** {
 232              		.loc 1 352 0
 233              		.cfi_startproc
 234              		@ Function supports interworking.
 235              		@ args = 0, pretend = 0, frame = 56
 236              		@ frame_needed = 0, uses_anonymous_args = 0
 237              	.LVL5:
 238 01cc F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 239              	.LCFI1:
 240              		.cfi_def_cfa_offset 32
 241              		.cfi_offset 4, -32
 242              		.cfi_offset 5, -28
 243              		.cfi_offset 6, -24
 244              		.cfi_offset 7, -20
 245              		.cfi_offset 8, -16
 246              		.cfi_offset 9, -12
 247              		.cfi_offset 10, -8
 248              		.cfi_offset 14, -4
 353:main.c        **** 	int temp = 0, temp2 = 0, ind = 0;
 354:main.c        **** 	int j;
 355:main.c        **** 	short a;
 356:main.c        **** 	char q[50], temp_buff[4];
 357:main.c        **** 
 358:main.c        **** 
 359:main.c        **** 	T0IR = 1; // reset TMR0 interrupt
 249              		.loc 1 359 0
 250 01d0 FC3B9FE5 		ldr	r3, .L152
 251 01d4 0120A0E3 		mov	r2, #1
 252 01d8 002083E5 		str	r2, [r3, #0]
 253              	.LVL6:
 360:main.c        **** 	
 361:main.c        **** 	for(j = 0; j < 50; j++)
 254              		.loc 1 361 0
 255 01dc 0030A0E3 		mov	r3, #0
 352:main.c        **** 	int temp = 0, temp2 = 0, ind = 0;
 256              		.loc 1 352 0
 257 01e0 38D04DE2 		sub	sp, sp, #56
 258              	.LCFI2:
 259              		.cfi_def_cfa_offset 88
 362:main.c        **** 	{
 363:main.c        **** 		q[j] = 0;
 260              		.loc 1 363 0
 261 01e4 0310A0E1 		mov	r1, r3
 262              	.LVL7:
 263              	.L17:
 264              		.loc 1 363 0 is_stmt 0 discriminator 2
 265 01e8 04208DE2 		add	r2, sp, #4
 266 01ec 0210C3E7 		strb	r1, [r3, r2]
 361:main.c        **** 	{
 267              		.loc 1 361 0 is_stmt 1 discriminator 2
 268 01f0 013083E2 		add	r3, r3, #1
 269              	.LVL8:
 270 01f4 320053E3 		cmp	r3, #50
 271 01f8 FAFFFF1A 		bne	.L17
 364:main.c        **** 	}
 365:main.c        **** 
 366:main.c        **** 
 367:main.c        **** 	// Get AD1.3
 368:main.c        **** 	if(ad1_3 == 'Y')
 272              		.loc 1 368 0
 273 01fc D43B9FE5 		ldr	r3, .L152+4
 274              	.LVL9:
 275 0200 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 276 0204 590053E3 		cmp	r3, #89
 277 0208 0100000A 		beq	.L18
 278              	.LVL10:
 279              	.L28:
 353:main.c        **** 	int j;
 280              		.loc 1 353 0
 281 020c 0040A0E3 		mov	r4, #0
 282 0210 440000EA 		b	.L19
 283              	.LVL11:
 284              	.L18:
 369:main.c        **** 	{
 370:main.c        **** 		AD1CR = 0x00020FF08; // AD1.3
 285              		.loc 1 370 0
 286 0214 C03B9FE5 		ldr	r3, .L152+8
 287 0218 C02B9FE5 		ldr	r2, .L152+12
 288 021c 002083E5 		str	r2, [r3, #0]
 371:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 289              		.loc 1 371 0
 290 0220 002093E5 		ldr	r2, [r3, #0]
 291 0224 012482E3 		orr	r2, r2, #16777216
 292 0228 002083E5 		str	r2, [r3, #0]
 293              	.LVL12:
 294              	.L20:
 372:main.c        **** 		while((temp & 0x80000000) == 0)
 373:main.c        **** 		{
 374:main.c        **** 			temp = AD1DR;
 295              		.loc 1 374 0
 296 022c 042093E5 		ldr	r2, [r3, #4]
 297              	.LVL13:
 372:main.c        **** 		while((temp & 0x80000000) == 0)
 298              		.loc 1 372 0
 299 0230 000052E3 		cmp	r2, #0
 300 0234 FCFFFFAA 		bge	.L20
 301              	.LVL14:
 375:main.c        **** 		}
 376:main.c        **** 		temp &= 0x0000FFC0;
 377:main.c        **** 		temp2 = temp / 0x00000040;
 378:main.c        **** 
 379:main.c        **** 		AD1CR = 0x00000000;
 302              		.loc 1 379 0
 303 0238 9C3B9FE5 		ldr	r3, .L152+8
 304 023c 0040A0E3 		mov	r4, #0
 305 0240 004083E5 		str	r4, [r3, #0]
 380:main.c        **** 
 381:main.c        **** 		if(asc == 'Y' || asc == ',')
 306              		.loc 1 381 0
 307 0244 8C3B9FE5 		ldr	r3, .L152+4
 376:main.c        **** 		temp2 = temp / 0x00000040;
 308              		.loc 1 376 0
 309 0248 940B9FE5 		ldr	r0, .L152+16
 310              		.loc 1 381 0
 311 024c 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 376:main.c        **** 		temp2 = temp / 0x00000040;
 312              		.loc 1 376 0
 313 0250 000002E0 		and	r0, r2, r0
 314              	.LVL15:
 315              		.loc 1 381 0
 316 0254 590053E3 		cmp	r3, #89
 317 0258 2C005313 		cmpne	r3, #44
 377:main.c        **** 
 318              		.loc 1 377 0
 319 025c 4003A0E1 		mov	r0, r0, asr #6
 320              	.LVL16:
 321              		.loc 1 381 0
 322 0260 2A00001A 		bne	.L21
 382:main.c        **** 		{
 383:main.c        **** 			itoa(temp2, 10, temp_buff);
 323              		.loc 1 383 0
 324 0264 0A10A0E3 		mov	r1, #10
 325 0268 0D20A0E1 		mov	r2, sp
 326              	.LVL17:
 327 026c FEFFFFEB 		bl	itoa
 328              	.LVL18:
 384:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 329              		.loc 1 384 0
 330 0270 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 331 0274 302043E2 		sub	r2, r3, #48
 332 0278 090052E3 		cmp	r2, #9
 385:main.c        **** 			{
 386:main.c        **** 				q[ind] = temp_buff[0];
 333              		.loc 1 386 0
 334 027c 0430CD95 		strlsb	r3, [sp, #4]
 335              	.LVL19:
 387:main.c        **** 				ind++;
 388:main.c        **** 			}
 389:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 336              		.loc 1 389 0
 337 0280 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 338 0284 302043E2 		sub	r2, r3, #48
 387:main.c        **** 				ind++;
 339              		.loc 1 387 0
 340 0288 0140A093 		movls	r4, #1
 341              	.LVL20:
 342              		.loc 1 389 0
 343 028c 090052E3 		cmp	r2, #9
 390:main.c        **** 			{
 391:main.c        **** 				q[ind] = temp_buff[1];
 344              		.loc 1 391 0
 345 0290 38108D92 		addls	r1, sp, #56
 346 0294 04208190 		addls	r2, r1, r4
 347 0298 34304295 		strlsb	r3, [r2, #-52]
 392:main.c        **** 				ind++;
 393:main.c        **** 			}
 394:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 348              		.loc 1 394 0
 349 029c 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 350 02a0 302043E2 		sub	r2, r3, #48
 392:main.c        **** 				ind++;
 351              		.loc 1 392 0
 352 02a4 01408492 		addls	r4, r4, #1
 353              	.LVL21:
 354              		.loc 1 394 0
 355 02a8 090052E3 		cmp	r2, #9
 395:main.c        **** 			{
 396:main.c        **** 				q[ind] = temp_buff[2];
 356              		.loc 1 396 0
 357 02ac 38108D92 		addls	r1, sp, #56
 358 02b0 04208190 		addls	r2, r1, r4
 359 02b4 34304295 		strlsb	r3, [r2, #-52]
 397:main.c        **** 				ind++;
 398:main.c        **** 			}
 399:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 360              		.loc 1 399 0
 361 02b8 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 362 02bc 302043E2 		sub	r2, r3, #48
 397:main.c        **** 				ind++;
 363              		.loc 1 397 0
 364 02c0 01408492 		addls	r4, r4, #1
 365              	.LVL22:
 366              		.loc 1 399 0
 367 02c4 090052E3 		cmp	r2, #9
 400:main.c        **** 			{
 401:main.c        **** 				q[ind] = temp_buff[3];
 368              		.loc 1 401 0
 369 02c8 38108D92 		addls	r1, sp, #56
 370 02cc 04208190 		addls	r2, r1, r4
 371 02d0 34304295 		strlsb	r3, [r2, #-52]
 402:main.c        **** 				ind++;
 403:main.c        **** 			}
 404:main.c        **** 	
 405:main.c        **** 			if(asc == ',')
 372              		.loc 1 405 0
 373 02d4 FC3A9FE5 		ldr	r3, .L152+4
 374 02d8 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 402:main.c        **** 				ind++;
 375              		.loc 1 402 0
 376 02dc 01408492 		addls	r4, r4, #1
 377              	.LVL23:
 378 02e0 38108DE2 		add	r1, sp, #56
 379              		.loc 1 405 0
 380 02e4 2C0052E3 		cmp	r2, #44
 381 02e8 043081E0 		add	r3, r1, r4
 406:main.c        **** 			{
 407:main.c        **** 				q[ind] = ',';
 408:main.c        **** 			}
 409:main.c        **** 			else
 410:main.c        **** 			{
 411:main.c        **** 				q[ind] = 0;
 382              		.loc 1 411 0
 383 02ec 0020A013 		movne	r2, #0
 384 02f0 342043E5 		strb	r2, [r3, #-52]
 412:main.c        **** 			}
 413:main.c        **** 			ind++;
 414:main.c        **** 			temp = 0; 
 415:main.c        **** 			temp2 = 0;
 416:main.c        **** 			temp_buff[0] = 0;
 385              		.loc 1 416 0
 386 02f4 0030A0E3 		mov	r3, #0
 413:main.c        **** 			temp = 0; 
 387              		.loc 1 413 0
 388 02f8 014084E2 		add	r4, r4, #1
 389              	.LVL24:
 390              		.loc 1 416 0
 391 02fc 0030CDE5 		strb	r3, [sp, #0]
 417:main.c        **** 			temp_buff[1] = 0;
 392              		.loc 1 417 0
 393 0300 0130CDE5 		strb	r3, [sp, #1]
 418:main.c        **** 			temp_buff[2] = 0;
 394              		.loc 1 418 0
 395 0304 0230CDE5 		strb	r3, [sp, #2]
 419:main.c        **** 			temp_buff[3] = 0;
 396              		.loc 1 419 0
 397 0308 0330CDE5 		strb	r3, [sp, #3]
 398 030c 050000EA 		b	.L19
 399              	.LVL25:
 400              	.L21:
 420:main.c        **** 
 421:main.c        **** 		}
 422:main.c        **** 
 423:main.c        **** 		else if(asc == 'N')
 401              		.loc 1 423 0
 402 0310 4E0053E3 		cmp	r3, #78
 403 0314 BCFFFF1A 		bne	.L28
 404              	.LVL26:
 424:main.c        **** 		{
 425:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 405              		.loc 1 425 0
 406 0318 2034A0E1 		mov	r3, r0, lsr #8
 426:main.c        **** 			q[ind] = (char)a;
 407              		.loc 1 426 0
 408 031c 0430CDE5 		strb	r3, [sp, #4]
 427:main.c        **** 			
 428:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 409              		.loc 1 428 0
 410 0320 0500CDE5 		strb	r0, [sp, #5]
 411              	.LVL27:
 429:main.c        **** 			ind += 2;
 412              		.loc 1 429 0
 413 0324 0240A0E3 		mov	r4, #2
 414              	.LVL28:
 415              	.L19:
 430:main.c        **** 			temp = 0;
 431:main.c        **** 		}
 432:main.c        **** 	}
 433:main.c        **** 	// Get AD0.3
 434:main.c        **** 	if(ad0_3 == 'Y')
 416              		.loc 1 434 0
 417 0328 A83A9FE5 		ldr	r3, .L152+4
 418 032c 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 419 0330 590053E3 		cmp	r3, #89
 420 0334 4800001A 		bne	.L29
 435:main.c        **** 	{
 436:main.c        **** 		AD0CR = 0x00020FF08; // AD0.3
 421              		.loc 1 436 0
 422 0338 A83A9FE5 		ldr	r3, .L152+20
 423 033c 9C2A9FE5 		ldr	r2, .L152+12
 424 0340 002083E5 		str	r2, [r3, #0]
 437:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 425              		.loc 1 437 0
 426 0344 002093E5 		ldr	r2, [r3, #0]
 427 0348 012482E3 		orr	r2, r2, #16777216
 428 034c 002083E5 		str	r2, [r3, #0]
 429              	.L30:
 438:main.c        **** 		while((temp & 0x80000000) == 0)
 439:main.c        **** 		{
 440:main.c        **** 			temp = AD0DR;
 430              		.loc 1 440 0
 431 0350 042093E5 		ldr	r2, [r3, #4]
 432              	.LVL29:
 438:main.c        **** 		while((temp & 0x80000000) == 0)
 433              		.loc 1 438 0
 434 0354 000052E3 		cmp	r2, #0
 435 0358 FCFFFFAA 		bge	.L30
 436              	.LVL30:
 441:main.c        **** 		}
 442:main.c        **** 		temp &= 0x0000FFC0;
 437              		.loc 1 442 0
 438 035c 800A9FE5 		ldr	r0, .L152+16
 443:main.c        **** 		temp2 = temp / 0x00000040;
 444:main.c        **** 
 445:main.c        **** 		AD0CR = 0x00000000;
 439              		.loc 1 445 0
 440 0360 803A9FE5 		ldr	r3, .L152+20
 442:main.c        **** 		temp2 = temp / 0x00000040;
 441              		.loc 1 442 0
 442 0364 000002E0 		and	r0, r2, r0
 443              	.LVL31:
 444              		.loc 1 445 0
 445 0368 0020A0E3 		mov	r2, #0
 446 036c 002083E5 		str	r2, [r3, #0]
 446:main.c        **** 
 447:main.c        **** 		if(asc == 'Y' || asc ==',')
 447              		.loc 1 447 0
 448 0370 603A9FE5 		ldr	r3, .L152+4
 449 0374 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 450 0378 590053E3 		cmp	r3, #89
 451 037c 2C005313 		cmpne	r3, #44
 443:main.c        **** 
 452              		.loc 1 443 0
 453 0380 4003A0E1 		mov	r0, r0, asr #6
 454              	.LVL32:
 455              		.loc 1 447 0
 456 0384 2C00001A 		bne	.L31
 448:main.c        **** 		{
 449:main.c        **** 			itoa(temp2, 10, temp_buff);
 457              		.loc 1 449 0
 458 0388 0A10A0E3 		mov	r1, #10
 459 038c 0D20A0E1 		mov	r2, sp
 460 0390 FEFFFFEB 		bl	itoa
 461              	.LVL33:
 450:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 462              		.loc 1 450 0
 463 0394 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 464 0398 302043E2 		sub	r2, r3, #48
 465 039c 090052E3 		cmp	r2, #9
 451:main.c        **** 			{
 452:main.c        **** 				q[ind] = temp_buff[0];
 466              		.loc 1 452 0
 467 03a0 38108D92 		addls	r1, sp, #56
 468 03a4 04208190 		addls	r2, r1, r4
 469 03a8 34304295 		strlsb	r3, [r2, #-52]
 453:main.c        **** 				ind++;
 454:main.c        **** 			}
 455:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 470              		.loc 1 455 0
 471 03ac 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 472 03b0 302043E2 		sub	r2, r3, #48
 453:main.c        **** 				ind++;
 473              		.loc 1 453 0
 474 03b4 01408492 		addls	r4, r4, #1
 475              	.LVL34:
 476              		.loc 1 455 0
 477 03b8 090052E3 		cmp	r2, #9
 456:main.c        **** 			{
 457:main.c        **** 				q[ind] = temp_buff[1];
 478              		.loc 1 457 0
 479 03bc 38108D92 		addls	r1, sp, #56
 480 03c0 04208190 		addls	r2, r1, r4
 481 03c4 34304295 		strlsb	r3, [r2, #-52]
 458:main.c        **** 				ind++;
 459:main.c        **** 			}
 460:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 482              		.loc 1 460 0
 483 03c8 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 484 03cc 302043E2 		sub	r2, r3, #48
 458:main.c        **** 				ind++;
 485              		.loc 1 458 0
 486 03d0 01408492 		addls	r4, r4, #1
 487              	.LVL35:
 488              		.loc 1 460 0
 489 03d4 090052E3 		cmp	r2, #9
 461:main.c        **** 			{
 462:main.c        **** 				q[ind] = temp_buff[2];
 490              		.loc 1 462 0
 491 03d8 38108D92 		addls	r1, sp, #56
 492 03dc 04208190 		addls	r2, r1, r4
 493 03e0 34304295 		strlsb	r3, [r2, #-52]
 463:main.c        **** 				ind++;
 464:main.c        **** 			}
 465:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 494              		.loc 1 465 0
 495 03e4 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 496 03e8 302043E2 		sub	r2, r3, #48
 463:main.c        **** 				ind++;
 497              		.loc 1 463 0
 498 03ec 01408492 		addls	r4, r4, #1
 499              	.LVL36:
 500              		.loc 1 465 0
 501 03f0 090052E3 		cmp	r2, #9
 466:main.c        **** 			{
 467:main.c        **** 				q[ind] = temp_buff[3];
 502              		.loc 1 467 0
 503 03f4 38108D92 		addls	r1, sp, #56
 504 03f8 04208190 		addls	r2, r1, r4
 505 03fc 34304295 		strlsb	r3, [r2, #-52]
 468:main.c        **** 				ind++;
 469:main.c        **** 			}
 470:main.c        **** 
 471:main.c        **** 			if(asc == ',')
 506              		.loc 1 471 0
 507 0400 D0399FE5 		ldr	r3, .L152+4
 508 0404 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 468:main.c        **** 				ind++;
 509              		.loc 1 468 0
 510 0408 01408492 		addls	r4, r4, #1
 511              	.LVL37:
 512 040c 38108DE2 		add	r1, sp, #56
 513              		.loc 1 471 0
 514 0410 2C0052E3 		cmp	r2, #44
 515 0414 043081E0 		add	r3, r1, r4
 472:main.c        **** 			{
 473:main.c        **** 				q[ind] = ',';
 474:main.c        **** 			}
 475:main.c        **** 			else
 476:main.c        **** 			{
 477:main.c        **** 				q[ind] = 0;
 516              		.loc 1 477 0
 517 0418 0020A013 		movne	r2, #0
 518 041c 342043E5 		strb	r2, [r3, #-52]
 478:main.c        **** 			}
 479:main.c        **** 			ind++;
 480:main.c        **** 			temp = 0; 
 481:main.c        **** 			temp2 = 0;
 482:main.c        **** 			temp_buff[0] = 0;
 519              		.loc 1 482 0
 520 0420 0030A0E3 		mov	r3, #0
 479:main.c        **** 			temp = 0; 
 521              		.loc 1 479 0
 522 0424 014084E2 		add	r4, r4, #1
 523              	.LVL38:
 524              		.loc 1 482 0
 525 0428 0030CDE5 		strb	r3, [sp, #0]
 483:main.c        **** 			temp_buff[1] = 0;
 526              		.loc 1 483 0
 527 042c 0130CDE5 		strb	r3, [sp, #1]
 484:main.c        **** 			temp_buff[2] = 0;
 528              		.loc 1 484 0
 529 0430 0230CDE5 		strb	r3, [sp, #2]
 485:main.c        **** 			temp_buff[3] = 0;
 530              		.loc 1 485 0
 531 0434 0330CDE5 		strb	r3, [sp, #3]
 532 0438 070000EA 		b	.L29
 533              	.LVL39:
 534              	.L31:
 486:main.c        **** 
 487:main.c        **** 		}
 488:main.c        **** 
 489:main.c        **** 		else if(asc == 'N')
 535              		.loc 1 489 0
 536 043c 4E0053E3 		cmp	r3, #78
 537 0440 0500001A 		bne	.L29
 538              	.LVL40:
 490:main.c        **** 		{
 491:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 492:main.c        **** 			q[ind] = (char)a;
 539              		.loc 1 492 0
 540 0444 38208DE2 		add	r2, sp, #56
 541 0448 043082E0 		add	r3, r2, r4
 491:main.c        **** 			q[ind] = (char)a;
 542              		.loc 1 491 0
 543 044c 2024A0E1 		mov	r2, r0, lsr #8
 544              		.loc 1 492 0
 545 0450 342043E5 		strb	r2, [r3, #-52]
 493:main.c        **** 			
 494:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 546              		.loc 1 494 0
 547 0454 330043E5 		strb	r0, [r3, #-51]
 495:main.c        **** 			ind += 2;
 548              		.loc 1 495 0
 549 0458 024084E2 		add	r4, r4, #2
 550              	.LVL41:
 551              	.L29:
 496:main.c        **** 			temp = 0;
 497:main.c        **** 		}
 498:main.c        **** 	}
 499:main.c        **** 	// Get AD0.2
 500:main.c        **** 	if(ad0_2 == 'Y')
 552              		.loc 1 500 0
 553 045c 74399FE5 		ldr	r3, .L152+4
 554 0460 0730D3E5 		ldrb	r3, [r3, #7]	@ zero_extendqisi2
 555 0464 590053E3 		cmp	r3, #89
 556 0468 4800001A 		bne	.L38
 501:main.c        **** 	{
 502:main.c        **** 		AD0CR = 0x00020FF04; // AD1.2
 557              		.loc 1 502 0
 558 046c 74399FE5 		ldr	r3, .L152+20
 559 0470 74299FE5 		ldr	r2, .L152+24
 560 0474 002083E5 		str	r2, [r3, #0]
 503:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 561              		.loc 1 503 0
 562 0478 002093E5 		ldr	r2, [r3, #0]
 563 047c 012482E3 		orr	r2, r2, #16777216
 564 0480 002083E5 		str	r2, [r3, #0]
 565              	.L39:
 504:main.c        **** 		while((temp & 0x80000000) == 0)
 505:main.c        **** 		{
 506:main.c        **** 			temp = AD0DR;
 566              		.loc 1 506 0
 567 0484 042093E5 		ldr	r2, [r3, #4]
 568              	.LVL42:
 504:main.c        **** 		while((temp & 0x80000000) == 0)
 569              		.loc 1 504 0
 570 0488 000052E3 		cmp	r2, #0
 571 048c FCFFFFAA 		bge	.L39
 572              	.LVL43:
 507:main.c        **** 		}
 508:main.c        **** 		temp &= 0x0000FFC0;
 573              		.loc 1 508 0
 574 0490 4C099FE5 		ldr	r0, .L152+16
 509:main.c        **** 		temp2 = temp / 0x00000040;
 510:main.c        **** 
 511:main.c        **** 		AD0CR = 0x00000000;
 575              		.loc 1 511 0
 576 0494 4C399FE5 		ldr	r3, .L152+20
 508:main.c        **** 		temp2 = temp / 0x00000040;
 577              		.loc 1 508 0
 578 0498 000002E0 		and	r0, r2, r0
 579              	.LVL44:
 580              		.loc 1 511 0
 581 049c 0020A0E3 		mov	r2, #0
 582 04a0 002083E5 		str	r2, [r3, #0]
 512:main.c        **** 
 513:main.c        **** 		if(asc == 'Y' || asc == ',')
 583              		.loc 1 513 0
 584 04a4 2C399FE5 		ldr	r3, .L152+4
 585 04a8 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 586 04ac 590053E3 		cmp	r3, #89
 587 04b0 2C005313 		cmpne	r3, #44
 509:main.c        **** 
 588              		.loc 1 509 0
 589 04b4 4003A0E1 		mov	r0, r0, asr #6
 590              	.LVL45:
 591              		.loc 1 513 0
 592 04b8 2C00001A 		bne	.L40
 514:main.c        **** 		{
 515:main.c        **** 			itoa(temp2, 10, temp_buff);
 593              		.loc 1 515 0
 594 04bc 0A10A0E3 		mov	r1, #10
 595 04c0 0D20A0E1 		mov	r2, sp
 596 04c4 FEFFFFEB 		bl	itoa
 597              	.LVL46:
 516:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 598              		.loc 1 516 0
 599 04c8 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 600 04cc 302043E2 		sub	r2, r3, #48
 601 04d0 090052E3 		cmp	r2, #9
 517:main.c        **** 			{
 518:main.c        **** 				q[ind] = temp_buff[0];
 602              		.loc 1 518 0
 603 04d4 38108D92 		addls	r1, sp, #56
 604 04d8 04208190 		addls	r2, r1, r4
 605 04dc 34304295 		strlsb	r3, [r2, #-52]
 519:main.c        **** 				ind++;
 520:main.c        **** 			}
 521:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 606              		.loc 1 521 0
 607 04e0 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 608 04e4 302043E2 		sub	r2, r3, #48
 519:main.c        **** 				ind++;
 609              		.loc 1 519 0
 610 04e8 01408492 		addls	r4, r4, #1
 611              	.LVL47:
 612              		.loc 1 521 0
 613 04ec 090052E3 		cmp	r2, #9
 522:main.c        **** 			{
 523:main.c        **** 				q[ind] = temp_buff[1];
 614              		.loc 1 523 0
 615 04f0 38108D92 		addls	r1, sp, #56
 616 04f4 04208190 		addls	r2, r1, r4
 617 04f8 34304295 		strlsb	r3, [r2, #-52]
 524:main.c        **** 				ind++;
 525:main.c        **** 			}
 526:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 618              		.loc 1 526 0
 619 04fc 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 620 0500 302043E2 		sub	r2, r3, #48
 524:main.c        **** 				ind++;
 621              		.loc 1 524 0
 622 0504 01408492 		addls	r4, r4, #1
 623              	.LVL48:
 624              		.loc 1 526 0
 625 0508 090052E3 		cmp	r2, #9
 527:main.c        **** 			{
 528:main.c        **** 				q[ind] = temp_buff[2];
 626              		.loc 1 528 0
 627 050c 38108D92 		addls	r1, sp, #56
 628 0510 04208190 		addls	r2, r1, r4
 629 0514 34304295 		strlsb	r3, [r2, #-52]
 529:main.c        **** 				ind++;
 530:main.c        **** 			}
 531:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 630              		.loc 1 531 0
 631 0518 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 632 051c 302043E2 		sub	r2, r3, #48
 529:main.c        **** 				ind++;
 633              		.loc 1 529 0
 634 0520 01408492 		addls	r4, r4, #1
 635              	.LVL49:
 636              		.loc 1 531 0
 637 0524 090052E3 		cmp	r2, #9
 532:main.c        **** 			{
 533:main.c        **** 				q[ind] = temp_buff[3];
 638              		.loc 1 533 0
 639 0528 38108D92 		addls	r1, sp, #56
 640 052c 04208190 		addls	r2, r1, r4
 641 0530 34304295 		strlsb	r3, [r2, #-52]
 534:main.c        **** 				ind++;
 535:main.c        **** 			}
 536:main.c        **** 
 537:main.c        **** 			if(asc == ',')
 642              		.loc 1 537 0
 643 0534 9C389FE5 		ldr	r3, .L152+4
 644 0538 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 534:main.c        **** 				ind++;
 645              		.loc 1 534 0
 646 053c 01408492 		addls	r4, r4, #1
 647              	.LVL50:
 648 0540 38108DE2 		add	r1, sp, #56
 649              		.loc 1 537 0
 650 0544 2C0052E3 		cmp	r2, #44
 651 0548 043081E0 		add	r3, r1, r4
 538:main.c        **** 			{
 539:main.c        **** 				q[ind] = ',';
 540:main.c        **** 			}
 541:main.c        **** 			else
 542:main.c        **** 			{
 543:main.c        **** 				q[ind] = 0;
 652              		.loc 1 543 0
 653 054c 0020A013 		movne	r2, #0
 654 0550 342043E5 		strb	r2, [r3, #-52]
 544:main.c        **** 			}
 545:main.c        **** 			ind++;
 546:main.c        **** 			temp = 0; 
 547:main.c        **** 			temp2 = 0;
 548:main.c        **** 			temp_buff[0] = 0;
 655              		.loc 1 548 0
 656 0554 0030A0E3 		mov	r3, #0
 545:main.c        **** 			temp = 0; 
 657              		.loc 1 545 0
 658 0558 014084E2 		add	r4, r4, #1
 659              	.LVL51:
 660              		.loc 1 548 0
 661 055c 0030CDE5 		strb	r3, [sp, #0]
 549:main.c        **** 			temp_buff[1] = 0;
 662              		.loc 1 549 0
 663 0560 0130CDE5 		strb	r3, [sp, #1]
 550:main.c        **** 			temp_buff[2] = 0;
 664              		.loc 1 550 0
 665 0564 0230CDE5 		strb	r3, [sp, #2]
 551:main.c        **** 			temp_buff[3] = 0;
 666              		.loc 1 551 0
 667 0568 0330CDE5 		strb	r3, [sp, #3]
 668 056c 070000EA 		b	.L38
 669              	.LVL52:
 670              	.L40:
 552:main.c        **** 
 553:main.c        **** 		}
 554:main.c        **** 
 555:main.c        **** 		else if(asc == 'N')
 671              		.loc 1 555 0
 672 0570 4E0053E3 		cmp	r3, #78
 673 0574 0500001A 		bne	.L38
 674              	.LVL53:
 556:main.c        **** 		{
 557:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 558:main.c        **** 			q[ind] = (char)a;
 675              		.loc 1 558 0
 676 0578 38208DE2 		add	r2, sp, #56
 677 057c 043082E0 		add	r3, r2, r4
 557:main.c        **** 			q[ind] = (char)a;
 678              		.loc 1 557 0
 679 0580 2024A0E1 		mov	r2, r0, lsr #8
 680              		.loc 1 558 0
 681 0584 342043E5 		strb	r2, [r3, #-52]
 559:main.c        **** 			
 560:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 682              		.loc 1 560 0
 683 0588 330043E5 		strb	r0, [r3, #-51]
 561:main.c        **** 			ind += 2;
 684              		.loc 1 561 0
 685 058c 024084E2 		add	r4, r4, #2
 686              	.LVL54:
 687              	.L38:
 562:main.c        **** 			temp = 0;
 563:main.c        **** 		}
 564:main.c        **** 	}
 565:main.c        **** 	// Get AD0.1
 566:main.c        **** 	if(ad0_1 == 'Y')
 688              		.loc 1 566 0
 689 0590 40389FE5 		ldr	r3, .L152+4
 690 0594 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 691 0598 590053E3 		cmp	r3, #89
 692 059c 4800001A 		bne	.L47
 567:main.c        **** 	{
 568:main.c        **** 		AD0CR = 0x00020FF02; // AD0.1
 693              		.loc 1 568 0
 694 05a0 40389FE5 		ldr	r3, .L152+20
 695 05a4 44289FE5 		ldr	r2, .L152+28
 696 05a8 002083E5 		str	r2, [r3, #0]
 569:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 697              		.loc 1 569 0
 698 05ac 002093E5 		ldr	r2, [r3, #0]
 699 05b0 012482E3 		orr	r2, r2, #16777216
 700 05b4 002083E5 		str	r2, [r3, #0]
 701              	.L48:
 570:main.c        **** 		while((temp & 0x80000000) == 0)
 571:main.c        **** 		{
 572:main.c        **** 			temp = AD0DR;
 702              		.loc 1 572 0
 703 05b8 042093E5 		ldr	r2, [r3, #4]
 704              	.LVL55:
 570:main.c        **** 		while((temp & 0x80000000) == 0)
 705              		.loc 1 570 0
 706 05bc 000052E3 		cmp	r2, #0
 707 05c0 FCFFFFAA 		bge	.L48
 708              	.LVL56:
 573:main.c        **** 		}
 574:main.c        **** 		temp &= 0x0000FFC0;
 709              		.loc 1 574 0
 710 05c4 18089FE5 		ldr	r0, .L152+16
 575:main.c        **** 		temp2 = temp / 0x00000040;
 576:main.c        **** 
 577:main.c        **** 		AD0CR = 0x00000000;
 711              		.loc 1 577 0
 712 05c8 18389FE5 		ldr	r3, .L152+20
 574:main.c        **** 		temp2 = temp / 0x00000040;
 713              		.loc 1 574 0
 714 05cc 000002E0 		and	r0, r2, r0
 715              	.LVL57:
 716              		.loc 1 577 0
 717 05d0 0020A0E3 		mov	r2, #0
 718 05d4 002083E5 		str	r2, [r3, #0]
 578:main.c        **** 
 579:main.c        **** 		if(asc == 'Y' || asc == ',')
 719              		.loc 1 579 0
 720 05d8 F8379FE5 		ldr	r3, .L152+4
 721 05dc 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 722 05e0 590053E3 		cmp	r3, #89
 723 05e4 2C005313 		cmpne	r3, #44
 575:main.c        **** 
 724              		.loc 1 575 0
 725 05e8 4003A0E1 		mov	r0, r0, asr #6
 726              	.LVL58:
 727              		.loc 1 579 0
 728 05ec 2C00001A 		bne	.L49
 580:main.c        **** 		{
 581:main.c        **** 			itoa(temp2, 10, temp_buff);
 729              		.loc 1 581 0
 730 05f0 0A10A0E3 		mov	r1, #10
 731 05f4 0D20A0E1 		mov	r2, sp
 732 05f8 FEFFFFEB 		bl	itoa
 733              	.LVL59:
 582:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 734              		.loc 1 582 0
 735 05fc 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 736 0600 302043E2 		sub	r2, r3, #48
 737 0604 090052E3 		cmp	r2, #9
 583:main.c        **** 			{
 584:main.c        **** 				q[ind] = temp_buff[0];
 738              		.loc 1 584 0
 739 0608 38108D92 		addls	r1, sp, #56
 740 060c 04208190 		addls	r2, r1, r4
 741 0610 34304295 		strlsb	r3, [r2, #-52]
 585:main.c        **** 				ind++;
 586:main.c        **** 			}
 587:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 742              		.loc 1 587 0
 743 0614 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 744 0618 302043E2 		sub	r2, r3, #48
 585:main.c        **** 				ind++;
 745              		.loc 1 585 0
 746 061c 01408492 		addls	r4, r4, #1
 747              	.LVL60:
 748              		.loc 1 587 0
 749 0620 090052E3 		cmp	r2, #9
 588:main.c        **** 			{
 589:main.c        **** 				q[ind] = temp_buff[1];
 750              		.loc 1 589 0
 751 0624 38108D92 		addls	r1, sp, #56
 752 0628 04208190 		addls	r2, r1, r4
 753 062c 34304295 		strlsb	r3, [r2, #-52]
 590:main.c        **** 				ind++;
 591:main.c        **** 			}
 592:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 754              		.loc 1 592 0
 755 0630 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 756 0634 302043E2 		sub	r2, r3, #48
 590:main.c        **** 				ind++;
 757              		.loc 1 590 0
 758 0638 01408492 		addls	r4, r4, #1
 759              	.LVL61:
 760              		.loc 1 592 0
 761 063c 090052E3 		cmp	r2, #9
 593:main.c        **** 			{
 594:main.c        **** 				q[ind] = temp_buff[2];
 762              		.loc 1 594 0
 763 0640 38108D92 		addls	r1, sp, #56
 764 0644 04208190 		addls	r2, r1, r4
 765 0648 34304295 		strlsb	r3, [r2, #-52]
 595:main.c        **** 				ind++;
 596:main.c        **** 			}
 597:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 766              		.loc 1 597 0
 767 064c 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 768 0650 302043E2 		sub	r2, r3, #48
 595:main.c        **** 				ind++;
 769              		.loc 1 595 0
 770 0654 01408492 		addls	r4, r4, #1
 771              	.LVL62:
 772              		.loc 1 597 0
 773 0658 090052E3 		cmp	r2, #9
 598:main.c        **** 			{
 599:main.c        **** 				q[ind] = temp_buff[3];
 774              		.loc 1 599 0
 775 065c 38108D92 		addls	r1, sp, #56
 776 0660 04208190 		addls	r2, r1, r4
 777 0664 34304295 		strlsb	r3, [r2, #-52]
 600:main.c        **** 				ind++;
 601:main.c        **** 			}
 602:main.c        **** 
 603:main.c        **** 			if(asc == ',')
 778              		.loc 1 603 0
 779 0668 68379FE5 		ldr	r3, .L152+4
 780 066c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 600:main.c        **** 				ind++;
 781              		.loc 1 600 0
 782 0670 01408492 		addls	r4, r4, #1
 783              	.LVL63:
 784 0674 38108DE2 		add	r1, sp, #56
 785              		.loc 1 603 0
 786 0678 2C0052E3 		cmp	r2, #44
 787 067c 043081E0 		add	r3, r1, r4
 604:main.c        **** 			{
 605:main.c        **** 				q[ind] = ',';
 606:main.c        **** 			}
 607:main.c        **** 			else
 608:main.c        **** 			{
 609:main.c        **** 				q[ind] = 0;
 788              		.loc 1 609 0
 789 0680 0020A013 		movne	r2, #0
 790 0684 342043E5 		strb	r2, [r3, #-52]
 610:main.c        **** 			}
 611:main.c        **** 			ind++;
 612:main.c        **** 			temp = 0; 
 613:main.c        **** 			temp2 = 0;
 614:main.c        **** 			temp_buff[0] = 0;
 791              		.loc 1 614 0
 792 0688 0030A0E3 		mov	r3, #0
 611:main.c        **** 			temp = 0; 
 793              		.loc 1 611 0
 794 068c 014084E2 		add	r4, r4, #1
 795              	.LVL64:
 796              		.loc 1 614 0
 797 0690 0030CDE5 		strb	r3, [sp, #0]
 615:main.c        **** 			temp_buff[1] = 0;
 798              		.loc 1 615 0
 799 0694 0130CDE5 		strb	r3, [sp, #1]
 616:main.c        **** 			temp_buff[2] = 0;
 800              		.loc 1 616 0
 801 0698 0230CDE5 		strb	r3, [sp, #2]
 617:main.c        **** 			temp_buff[3] = 0;
 802              		.loc 1 617 0
 803 069c 0330CDE5 		strb	r3, [sp, #3]
 804 06a0 070000EA 		b	.L47
 805              	.LVL65:
 806              	.L49:
 618:main.c        **** 
 619:main.c        **** 		}
 620:main.c        **** 
 621:main.c        **** 		else if(asc == 'N')
 807              		.loc 1 621 0
 808 06a4 4E0053E3 		cmp	r3, #78
 809 06a8 0500001A 		bne	.L47
 810              	.LVL66:
 622:main.c        **** 		{
 623:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 624:main.c        **** 			q[ind] = (char)a;
 811              		.loc 1 624 0
 812 06ac 38208DE2 		add	r2, sp, #56
 813 06b0 043082E0 		add	r3, r2, r4
 623:main.c        **** 			q[ind] = (char)a;
 814              		.loc 1 623 0
 815 06b4 2024A0E1 		mov	r2, r0, lsr #8
 816              		.loc 1 624 0
 817 06b8 342043E5 		strb	r2, [r3, #-52]
 625:main.c        **** 			
 626:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 818              		.loc 1 626 0
 819 06bc 330043E5 		strb	r0, [r3, #-51]
 627:main.c        **** 			ind += 2;
 820              		.loc 1 627 0
 821 06c0 024084E2 		add	r4, r4, #2
 822              	.LVL67:
 823              	.L47:
 628:main.c        **** 			temp = 0;
 629:main.c        **** 		}
 630:main.c        **** 	}
 631:main.c        **** 	// Get AD1.2
 632:main.c        **** 	if(ad1_2 == 'Y')
 824              		.loc 1 632 0
 825 06c4 0C379FE5 		ldr	r3, .L152+4
 826 06c8 0930D3E5 		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 827 06cc 590053E3 		cmp	r3, #89
 828 06d0 4800001A 		bne	.L56
 633:main.c        **** 	{
 634:main.c        **** 		AD1CR = 0x00020FF04; // AD1.2
 829              		.loc 1 634 0
 830 06d4 00379FE5 		ldr	r3, .L152+8
 831 06d8 0C279FE5 		ldr	r2, .L152+24
 832 06dc 002083E5 		str	r2, [r3, #0]
 635:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 833              		.loc 1 635 0
 834 06e0 002093E5 		ldr	r2, [r3, #0]
 835 06e4 012482E3 		orr	r2, r2, #16777216
 836 06e8 002083E5 		str	r2, [r3, #0]
 837              	.L57:
 636:main.c        **** 		while((temp & 0x80000000) == 0)
 637:main.c        **** 		{
 638:main.c        **** 			temp = AD1DR;
 838              		.loc 1 638 0
 839 06ec 042093E5 		ldr	r2, [r3, #4]
 840              	.LVL68:
 636:main.c        **** 		while((temp & 0x80000000) == 0)
 841              		.loc 1 636 0
 842 06f0 000052E3 		cmp	r2, #0
 843 06f4 FCFFFFAA 		bge	.L57
 844              	.LVL69:
 639:main.c        **** 		}
 640:main.c        **** 		temp &= 0x0000FFC0;
 845              		.loc 1 640 0
 846 06f8 E4069FE5 		ldr	r0, .L152+16
 641:main.c        **** 		temp2 = temp / 0x00000040;
 642:main.c        **** 
 643:main.c        **** 		AD1CR = 0x00000000;
 847              		.loc 1 643 0
 848 06fc D8369FE5 		ldr	r3, .L152+8
 640:main.c        **** 		temp2 = temp / 0x00000040;
 849              		.loc 1 640 0
 850 0700 000002E0 		and	r0, r2, r0
 851              	.LVL70:
 852              		.loc 1 643 0
 853 0704 0020A0E3 		mov	r2, #0
 854 0708 002083E5 		str	r2, [r3, #0]
 644:main.c        **** 
 645:main.c        **** 		if(asc == 'Y' || asc == ',')
 855              		.loc 1 645 0
 856 070c C4369FE5 		ldr	r3, .L152+4
 857 0710 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 858 0714 590053E3 		cmp	r3, #89
 859 0718 2C005313 		cmpne	r3, #44
 641:main.c        **** 
 860              		.loc 1 641 0
 861 071c 4003A0E1 		mov	r0, r0, asr #6
 862              	.LVL71:
 863              		.loc 1 645 0
 864 0720 2C00001A 		bne	.L58
 646:main.c        **** 		{
 647:main.c        **** 			itoa(temp2, 10, temp_buff);
 865              		.loc 1 647 0
 866 0724 0A10A0E3 		mov	r1, #10
 867 0728 0D20A0E1 		mov	r2, sp
 868 072c FEFFFFEB 		bl	itoa
 869              	.LVL72:
 648:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 870              		.loc 1 648 0
 871 0730 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 872 0734 302043E2 		sub	r2, r3, #48
 873 0738 090052E3 		cmp	r2, #9
 649:main.c        **** 			{
 650:main.c        **** 				q[ind] = temp_buff[0];
 874              		.loc 1 650 0
 875 073c 38108D92 		addls	r1, sp, #56
 876 0740 04208190 		addls	r2, r1, r4
 877 0744 34304295 		strlsb	r3, [r2, #-52]
 651:main.c        **** 				ind++;
 652:main.c        **** 			}
 653:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 878              		.loc 1 653 0
 879 0748 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 880 074c 302043E2 		sub	r2, r3, #48
 651:main.c        **** 				ind++;
 881              		.loc 1 651 0
 882 0750 01408492 		addls	r4, r4, #1
 883              	.LVL73:
 884              		.loc 1 653 0
 885 0754 090052E3 		cmp	r2, #9
 654:main.c        **** 			{
 655:main.c        **** 				q[ind] = temp_buff[1];
 886              		.loc 1 655 0
 887 0758 38108D92 		addls	r1, sp, #56
 888 075c 04208190 		addls	r2, r1, r4
 889 0760 34304295 		strlsb	r3, [r2, #-52]
 656:main.c        **** 				ind++;
 657:main.c        **** 			}
 658:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 890              		.loc 1 658 0
 891 0764 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 892 0768 302043E2 		sub	r2, r3, #48
 656:main.c        **** 				ind++;
 893              		.loc 1 656 0
 894 076c 01408492 		addls	r4, r4, #1
 895              	.LVL74:
 896              		.loc 1 658 0
 897 0770 090052E3 		cmp	r2, #9
 659:main.c        **** 			{
 660:main.c        **** 				q[ind] = temp_buff[2];
 898              		.loc 1 660 0
 899 0774 38108D92 		addls	r1, sp, #56
 900 0778 04208190 		addls	r2, r1, r4
 901 077c 34304295 		strlsb	r3, [r2, #-52]
 661:main.c        **** 				ind++;
 662:main.c        **** 			}
 663:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 902              		.loc 1 663 0
 903 0780 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 904 0784 302043E2 		sub	r2, r3, #48
 661:main.c        **** 				ind++;
 905              		.loc 1 661 0
 906 0788 01408492 		addls	r4, r4, #1
 907              	.LVL75:
 908              		.loc 1 663 0
 909 078c 090052E3 		cmp	r2, #9
 664:main.c        **** 			{
 665:main.c        **** 				q[ind] = temp_buff[3];
 910              		.loc 1 665 0
 911 0790 38108D92 		addls	r1, sp, #56
 912 0794 04208190 		addls	r2, r1, r4
 913 0798 34304295 		strlsb	r3, [r2, #-52]
 666:main.c        **** 				ind++;
 667:main.c        **** 			}
 668:main.c        **** 
 669:main.c        **** 			if(asc == ',')
 914              		.loc 1 669 0
 915 079c 34369FE5 		ldr	r3, .L152+4
 916 07a0 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 666:main.c        **** 				ind++;
 917              		.loc 1 666 0
 918 07a4 01408492 		addls	r4, r4, #1
 919              	.LVL76:
 920 07a8 38108DE2 		add	r1, sp, #56
 921              		.loc 1 669 0
 922 07ac 2C0052E3 		cmp	r2, #44
 923 07b0 043081E0 		add	r3, r1, r4
 670:main.c        **** 			{
 671:main.c        **** 				q[ind] = ',';
 672:main.c        **** 			}
 673:main.c        **** 			else
 674:main.c        **** 			{
 675:main.c        **** 				q[ind] = 0;
 924              		.loc 1 675 0
 925 07b4 0020A013 		movne	r2, #0
 926 07b8 342043E5 		strb	r2, [r3, #-52]
 676:main.c        **** 			}
 677:main.c        **** 			ind++;
 678:main.c        **** 			temp = 0; 
 679:main.c        **** 			temp2 = 0;
 680:main.c        **** 			temp_buff[0] = 0;
 927              		.loc 1 680 0
 928 07bc 0030A0E3 		mov	r3, #0
 677:main.c        **** 			temp = 0; 
 929              		.loc 1 677 0
 930 07c0 014084E2 		add	r4, r4, #1
 931              	.LVL77:
 932              		.loc 1 680 0
 933 07c4 0030CDE5 		strb	r3, [sp, #0]
 681:main.c        **** 			temp_buff[1] = 0;
 934              		.loc 1 681 0
 935 07c8 0130CDE5 		strb	r3, [sp, #1]
 682:main.c        **** 			temp_buff[2] = 0;
 936              		.loc 1 682 0
 937 07cc 0230CDE5 		strb	r3, [sp, #2]
 683:main.c        **** 			temp_buff[3] = 0;
 938              		.loc 1 683 0
 939 07d0 0330CDE5 		strb	r3, [sp, #3]
 940 07d4 070000EA 		b	.L56
 941              	.LVL78:
 942              	.L58:
 684:main.c        **** 
 685:main.c        **** 		}
 686:main.c        **** 
 687:main.c        **** 		else if(asc == 'N')
 943              		.loc 1 687 0
 944 07d8 4E0053E3 		cmp	r3, #78
 945 07dc 0500001A 		bne	.L56
 946              	.LVL79:
 688:main.c        **** 		{
 689:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 690:main.c        **** 			q[ind] = (char)a;
 947              		.loc 1 690 0
 948 07e0 38208DE2 		add	r2, sp, #56
 949 07e4 043082E0 		add	r3, r2, r4
 689:main.c        **** 			q[ind] = (char)a;
 950              		.loc 1 689 0
 951 07e8 2024A0E1 		mov	r2, r0, lsr #8
 952              		.loc 1 690 0
 953 07ec 342043E5 		strb	r2, [r3, #-52]
 691:main.c        **** 			
 692:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 954              		.loc 1 692 0
 955 07f0 330043E5 		strb	r0, [r3, #-51]
 693:main.c        **** 			ind += 2;
 956              		.loc 1 693 0
 957 07f4 024084E2 		add	r4, r4, #2
 958              	.LVL80:
 959              	.L56:
 694:main.c        **** 			temp = 0;
 695:main.c        **** 		}
 696:main.c        **** 	}
 697:main.c        **** 	// Get AD0.4
 698:main.c        **** 	if(ad0_4 == 'Y')
 960              		.loc 1 698 0
 961 07f8 D8359FE5 		ldr	r3, .L152+4
 962 07fc 0A30D3E5 		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 963 0800 590053E3 		cmp	r3, #89
 964 0804 4800001A 		bne	.L65
 699:main.c        **** 	{
 700:main.c        **** 		AD0CR = 0x00020FF10; // AD0.4
 965              		.loc 1 700 0
 966 0808 D8359FE5 		ldr	r3, .L152+20
 967 080c E0259FE5 		ldr	r2, .L152+32
 968 0810 002083E5 		str	r2, [r3, #0]
 701:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 969              		.loc 1 701 0
 970 0814 002093E5 		ldr	r2, [r3, #0]
 971 0818 012482E3 		orr	r2, r2, #16777216
 972 081c 002083E5 		str	r2, [r3, #0]
 973              	.L66:
 702:main.c        **** 		while((temp & 0x80000000) == 0)
 703:main.c        **** 		{
 704:main.c        **** 			temp = AD0DR;
 974              		.loc 1 704 0
 975 0820 042093E5 		ldr	r2, [r3, #4]
 976              	.LVL81:
 702:main.c        **** 		while((temp & 0x80000000) == 0)
 977              		.loc 1 702 0
 978 0824 000052E3 		cmp	r2, #0
 979 0828 FCFFFFAA 		bge	.L66
 980              	.LVL82:
 705:main.c        **** 		}
 706:main.c        **** 		temp &= 0x0000FFC0;
 981              		.loc 1 706 0
 982 082c B0059FE5 		ldr	r0, .L152+16
 707:main.c        **** 		temp2 = temp / 0x00000040;
 708:main.c        **** 
 709:main.c        **** 		AD0CR = 0x00000000;
 983              		.loc 1 709 0
 984 0830 B0359FE5 		ldr	r3, .L152+20
 706:main.c        **** 		temp2 = temp / 0x00000040;
 985              		.loc 1 706 0
 986 0834 000002E0 		and	r0, r2, r0
 987              	.LVL83:
 988              		.loc 1 709 0
 989 0838 0020A0E3 		mov	r2, #0
 990 083c 002083E5 		str	r2, [r3, #0]
 710:main.c        **** 
 711:main.c        **** 		if(asc == 'Y' || asc == ',')
 991              		.loc 1 711 0
 992 0840 90359FE5 		ldr	r3, .L152+4
 993 0844 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 994 0848 590053E3 		cmp	r3, #89
 995 084c 2C005313 		cmpne	r3, #44
 707:main.c        **** 
 996              		.loc 1 707 0
 997 0850 4003A0E1 		mov	r0, r0, asr #6
 998              	.LVL84:
 999              		.loc 1 711 0
 1000 0854 2C00001A 		bne	.L67
 712:main.c        **** 		{
 713:main.c        **** 			itoa(temp2, 10, temp_buff);
 1001              		.loc 1 713 0
 1002 0858 0A10A0E3 		mov	r1, #10
 1003 085c 0D20A0E1 		mov	r2, sp
 1004 0860 FEFFFFEB 		bl	itoa
 1005              	.LVL85:
 714:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 1006              		.loc 1 714 0
 1007 0864 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1008 0868 302043E2 		sub	r2, r3, #48
 1009 086c 090052E3 		cmp	r2, #9
 715:main.c        **** 			{
 716:main.c        **** 				q[ind] = temp_buff[0];
 1010              		.loc 1 716 0
 1011 0870 38108D92 		addls	r1, sp, #56
 1012 0874 04208190 		addls	r2, r1, r4
 1013 0878 34304295 		strlsb	r3, [r2, #-52]
 717:main.c        **** 				ind++;
 718:main.c        **** 			}
 719:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 1014              		.loc 1 719 0
 1015 087c 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1016 0880 302043E2 		sub	r2, r3, #48
 717:main.c        **** 				ind++;
 1017              		.loc 1 717 0
 1018 0884 01408492 		addls	r4, r4, #1
 1019              	.LVL86:
 1020              		.loc 1 719 0
 1021 0888 090052E3 		cmp	r2, #9
 720:main.c        **** 			{
 721:main.c        **** 				q[ind] = temp_buff[1];
 1022              		.loc 1 721 0
 1023 088c 38108D92 		addls	r1, sp, #56
 1024 0890 04208190 		addls	r2, r1, r4
 1025 0894 34304295 		strlsb	r3, [r2, #-52]
 722:main.c        **** 				ind++;
 723:main.c        **** 			}
 724:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 1026              		.loc 1 724 0
 1027 0898 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1028 089c 302043E2 		sub	r2, r3, #48
 722:main.c        **** 				ind++;
 1029              		.loc 1 722 0
 1030 08a0 01408492 		addls	r4, r4, #1
 1031              	.LVL87:
 1032              		.loc 1 724 0
 1033 08a4 090052E3 		cmp	r2, #9
 725:main.c        **** 			{
 726:main.c        **** 				q[ind] = temp_buff[2];
 1034              		.loc 1 726 0
 1035 08a8 38108D92 		addls	r1, sp, #56
 1036 08ac 04208190 		addls	r2, r1, r4
 1037 08b0 34304295 		strlsb	r3, [r2, #-52]
 727:main.c        **** 				ind++;
 728:main.c        **** 			}
 729:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 1038              		.loc 1 729 0
 1039 08b4 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1040 08b8 302043E2 		sub	r2, r3, #48
 727:main.c        **** 				ind++;
 1041              		.loc 1 727 0
 1042 08bc 01408492 		addls	r4, r4, #1
 1043              	.LVL88:
 1044              		.loc 1 729 0
 1045 08c0 090052E3 		cmp	r2, #9
 730:main.c        **** 			{
 731:main.c        **** 				q[ind] = temp_buff[3];
 1046              		.loc 1 731 0
 1047 08c4 38108D92 		addls	r1, sp, #56
 1048 08c8 04208190 		addls	r2, r1, r4
 1049 08cc 34304295 		strlsb	r3, [r2, #-52]
 732:main.c        **** 				ind++;
 733:main.c        **** 			}
 734:main.c        **** 
 735:main.c        **** 			if(asc == ',')
 1050              		.loc 1 735 0
 1051 08d0 00359FE5 		ldr	r3, .L152+4
 1052 08d4 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 732:main.c        **** 				ind++;
 1053              		.loc 1 732 0
 1054 08d8 01408492 		addls	r4, r4, #1
 1055              	.LVL89:
 1056 08dc 38108DE2 		add	r1, sp, #56
 1057              		.loc 1 735 0
 1058 08e0 2C0052E3 		cmp	r2, #44
 1059 08e4 043081E0 		add	r3, r1, r4
 736:main.c        **** 			{
 737:main.c        **** 				q[ind] = ',';
 738:main.c        **** 			}
 739:main.c        **** 			else
 740:main.c        **** 			{
 741:main.c        **** 				q[ind] = 0;
 1060              		.loc 1 741 0
 1061 08e8 0020A013 		movne	r2, #0
 1062 08ec 342043E5 		strb	r2, [r3, #-52]
 742:main.c        **** 			}
 743:main.c        **** 			ind++;
 744:main.c        **** 			temp = 0; 
 745:main.c        **** 			temp2 = 0;
 746:main.c        **** 			temp_buff[0] = 0;
 1063              		.loc 1 746 0
 1064 08f0 0030A0E3 		mov	r3, #0
 743:main.c        **** 			temp = 0; 
 1065              		.loc 1 743 0
 1066 08f4 014084E2 		add	r4, r4, #1
 1067              	.LVL90:
 1068              		.loc 1 746 0
 1069 08f8 0030CDE5 		strb	r3, [sp, #0]
 747:main.c        **** 			temp_buff[1] = 0;
 1070              		.loc 1 747 0
 1071 08fc 0130CDE5 		strb	r3, [sp, #1]
 748:main.c        **** 			temp_buff[2] = 0;
 1072              		.loc 1 748 0
 1073 0900 0230CDE5 		strb	r3, [sp, #2]
 749:main.c        **** 			temp_buff[3] = 0;
 1074              		.loc 1 749 0
 1075 0904 0330CDE5 		strb	r3, [sp, #3]
 1076 0908 070000EA 		b	.L65
 1077              	.LVL91:
 1078              	.L67:
 750:main.c        **** 
 751:main.c        **** 		}
 752:main.c        **** 
 753:main.c        **** 		else if(asc == 'N')
 1079              		.loc 1 753 0
 1080 090c 4E0053E3 		cmp	r3, #78
 1081 0910 0500001A 		bne	.L65
 1082              	.LVL92:
 754:main.c        **** 		{
 755:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 756:main.c        **** 			q[ind] = (char)a;
 1083              		.loc 1 756 0
 1084 0914 38208DE2 		add	r2, sp, #56
 1085 0918 043082E0 		add	r3, r2, r4
 755:main.c        **** 			q[ind] = (char)a;
 1086              		.loc 1 755 0
 1087 091c 2024A0E1 		mov	r2, r0, lsr #8
 1088              		.loc 1 756 0
 1089 0920 342043E5 		strb	r2, [r3, #-52]
 757:main.c        **** 			
 758:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 1090              		.loc 1 758 0
 1091 0924 330043E5 		strb	r0, [r3, #-51]
 759:main.c        **** 			ind += 2;
 1092              		.loc 1 759 0
 1093 0928 024084E2 		add	r4, r4, #2
 1094              	.LVL93:
 1095              	.L65:
 760:main.c        **** 			temp = 0;
 761:main.c        **** 		}
 762:main.c        **** 	}
 763:main.c        **** 	// Get AD1.7
 764:main.c        **** 	if(ad1_7 == 'Y')
 1096              		.loc 1 764 0
 1097 092c A4349FE5 		ldr	r3, .L152+4
 1098 0930 0B30D3E5 		ldrb	r3, [r3, #11]	@ zero_extendqisi2
 1099 0934 590053E3 		cmp	r3, #89
 1100 0938 4800001A 		bne	.L74
 765:main.c        **** 	{
 766:main.c        **** 		AD1CR = 0x00020FF80; // AD1.7
 1101              		.loc 1 766 0
 1102 093c 98349FE5 		ldr	r3, .L152+8
 1103 0940 B0249FE5 		ldr	r2, .L152+36
 1104 0944 002083E5 		str	r2, [r3, #0]
 767:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 1105              		.loc 1 767 0
 1106 0948 002093E5 		ldr	r2, [r3, #0]
 1107 094c 012482E3 		orr	r2, r2, #16777216
 1108 0950 002083E5 		str	r2, [r3, #0]
 1109              	.L75:
 768:main.c        **** 		while((temp & 0x80000000) == 0)
 769:main.c        **** 		{
 770:main.c        **** 			temp = AD1DR;
 1110              		.loc 1 770 0
 1111 0954 042093E5 		ldr	r2, [r3, #4]
 1112              	.LVL94:
 768:main.c        **** 		while((temp & 0x80000000) == 0)
 1113              		.loc 1 768 0
 1114 0958 000052E3 		cmp	r2, #0
 1115 095c FCFFFFAA 		bge	.L75
 1116              	.LVL95:
 771:main.c        **** 		}
 772:main.c        **** 		temp &= 0x0000FFC0;
 1117              		.loc 1 772 0
 1118 0960 7C049FE5 		ldr	r0, .L152+16
 773:main.c        **** 		temp2 = temp / 0x00000040;
 774:main.c        **** 
 775:main.c        **** 		AD1CR = 0x00000000;
 1119              		.loc 1 775 0
 1120 0964 70349FE5 		ldr	r3, .L152+8
 772:main.c        **** 		temp2 = temp / 0x00000040;
 1121              		.loc 1 772 0
 1122 0968 000002E0 		and	r0, r2, r0
 1123              	.LVL96:
 1124              		.loc 1 775 0
 1125 096c 0020A0E3 		mov	r2, #0
 1126 0970 002083E5 		str	r2, [r3, #0]
 776:main.c        **** 
 777:main.c        **** 		if(asc == 'Y' || asc == ',')
 1127              		.loc 1 777 0
 1128 0974 5C349FE5 		ldr	r3, .L152+4
 1129 0978 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1130 097c 590053E3 		cmp	r3, #89
 1131 0980 2C005313 		cmpne	r3, #44
 773:main.c        **** 
 1132              		.loc 1 773 0
 1133 0984 4003A0E1 		mov	r0, r0, asr #6
 1134              	.LVL97:
 1135              		.loc 1 777 0
 1136 0988 2C00001A 		bne	.L76
 778:main.c        **** 		{
 779:main.c        **** 			itoa(temp2, 10, temp_buff);
 1137              		.loc 1 779 0
 1138 098c 0A10A0E3 		mov	r1, #10
 1139 0990 0D20A0E1 		mov	r2, sp
 1140 0994 FEFFFFEB 		bl	itoa
 1141              	.LVL98:
 780:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 1142              		.loc 1 780 0
 1143 0998 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1144 099c 302043E2 		sub	r2, r3, #48
 1145 09a0 090052E3 		cmp	r2, #9
 781:main.c        **** 			{
 782:main.c        **** 				q[ind] = temp_buff[0];
 1146              		.loc 1 782 0
 1147 09a4 38108D92 		addls	r1, sp, #56
 1148 09a8 04208190 		addls	r2, r1, r4
 1149 09ac 34304295 		strlsb	r3, [r2, #-52]
 783:main.c        **** 				ind++;
 784:main.c        **** 			}
 785:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 1150              		.loc 1 785 0
 1151 09b0 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1152 09b4 302043E2 		sub	r2, r3, #48
 783:main.c        **** 				ind++;
 1153              		.loc 1 783 0
 1154 09b8 01408492 		addls	r4, r4, #1
 1155              	.LVL99:
 1156              		.loc 1 785 0
 1157 09bc 090052E3 		cmp	r2, #9
 786:main.c        **** 			{
 787:main.c        **** 				q[ind] = temp_buff[1];
 1158              		.loc 1 787 0
 1159 09c0 38108D92 		addls	r1, sp, #56
 1160 09c4 04208190 		addls	r2, r1, r4
 1161 09c8 34304295 		strlsb	r3, [r2, #-52]
 788:main.c        **** 				ind++;
 789:main.c        **** 			}
 790:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 1162              		.loc 1 790 0
 1163 09cc 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1164 09d0 302043E2 		sub	r2, r3, #48
 788:main.c        **** 				ind++;
 1165              		.loc 1 788 0
 1166 09d4 01408492 		addls	r4, r4, #1
 1167              	.LVL100:
 1168              		.loc 1 790 0
 1169 09d8 090052E3 		cmp	r2, #9
 791:main.c        **** 			{
 792:main.c        **** 				q[ind] = temp_buff[2];
 1170              		.loc 1 792 0
 1171 09dc 38108D92 		addls	r1, sp, #56
 1172 09e0 04208190 		addls	r2, r1, r4
 1173 09e4 34304295 		strlsb	r3, [r2, #-52]
 793:main.c        **** 				ind++;
 794:main.c        **** 			}
 795:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 1174              		.loc 1 795 0
 1175 09e8 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1176 09ec 302043E2 		sub	r2, r3, #48
 793:main.c        **** 				ind++;
 1177              		.loc 1 793 0
 1178 09f0 01408492 		addls	r4, r4, #1
 1179              	.LVL101:
 1180              		.loc 1 795 0
 1181 09f4 090052E3 		cmp	r2, #9
 796:main.c        **** 			{
 797:main.c        **** 				q[ind] = temp_buff[3];
 1182              		.loc 1 797 0
 1183 09f8 38108D92 		addls	r1, sp, #56
 1184 09fc 04208190 		addls	r2, r1, r4
 1185 0a00 34304295 		strlsb	r3, [r2, #-52]
 798:main.c        **** 				ind++;
 799:main.c        **** 			}
 800:main.c        **** 
 801:main.c        **** 			if(asc == ',')
 1186              		.loc 1 801 0
 1187 0a04 CC339FE5 		ldr	r3, .L152+4
 1188 0a08 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 798:main.c        **** 				ind++;
 1189              		.loc 1 798 0
 1190 0a0c 01408492 		addls	r4, r4, #1
 1191              	.LVL102:
 1192 0a10 38108DE2 		add	r1, sp, #56
 1193              		.loc 1 801 0
 1194 0a14 2C0052E3 		cmp	r2, #44
 1195 0a18 043081E0 		add	r3, r1, r4
 802:main.c        **** 			{
 803:main.c        **** 				q[ind] = ',';
 804:main.c        **** 			}
 805:main.c        **** 			else
 806:main.c        **** 			{
 807:main.c        **** 				q[ind] = 0;
 1196              		.loc 1 807 0
 1197 0a1c 0020A013 		movne	r2, #0
 1198 0a20 342043E5 		strb	r2, [r3, #-52]
 808:main.c        **** 			}
 809:main.c        **** 			ind++;
 810:main.c        **** 			temp = 0; 
 811:main.c        **** 			temp2 = 0;
 812:main.c        **** 			temp_buff[0] = 0;
 1199              		.loc 1 812 0
 1200 0a24 0030A0E3 		mov	r3, #0
 809:main.c        **** 			temp = 0; 
 1201              		.loc 1 809 0
 1202 0a28 014084E2 		add	r4, r4, #1
 1203              	.LVL103:
 1204              		.loc 1 812 0
 1205 0a2c 0030CDE5 		strb	r3, [sp, #0]
 813:main.c        **** 			temp_buff[1] = 0;
 1206              		.loc 1 813 0
 1207 0a30 0130CDE5 		strb	r3, [sp, #1]
 814:main.c        **** 			temp_buff[2] = 0;
 1208              		.loc 1 814 0
 1209 0a34 0230CDE5 		strb	r3, [sp, #2]
 815:main.c        **** 			temp_buff[3] = 0;
 1210              		.loc 1 815 0
 1211 0a38 0330CDE5 		strb	r3, [sp, #3]
 1212 0a3c 070000EA 		b	.L74
 1213              	.LVL104:
 1214              	.L76:
 816:main.c        **** 
 817:main.c        **** 		}
 818:main.c        **** 
 819:main.c        **** 		else if(asc == 'N')
 1215              		.loc 1 819 0
 1216 0a40 4E0053E3 		cmp	r3, #78
 1217 0a44 0500001A 		bne	.L74
 1218              	.LVL105:
 820:main.c        **** 		{
 821:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 822:main.c        **** 			q[ind] = (char)a;
 1219              		.loc 1 822 0
 1220 0a48 38208DE2 		add	r2, sp, #56
 1221 0a4c 043082E0 		add	r3, r2, r4
 821:main.c        **** 			q[ind] = (char)a;
 1222              		.loc 1 821 0
 1223 0a50 2024A0E1 		mov	r2, r0, lsr #8
 1224              		.loc 1 822 0
 1225 0a54 342043E5 		strb	r2, [r3, #-52]
 823:main.c        **** 			
 824:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 1226              		.loc 1 824 0
 1227 0a58 330043E5 		strb	r0, [r3, #-51]
 825:main.c        **** 			ind += 2;
 1228              		.loc 1 825 0
 1229 0a5c 024084E2 		add	r4, r4, #2
 1230              	.LVL106:
 1231              	.L74:
 826:main.c        **** 			temp = 0;
 827:main.c        **** 		}
 828:main.c        **** 	}
 829:main.c        **** 	// Get AD1.6
 830:main.c        **** 	if(ad1_6 == 'Y')
 1232              		.loc 1 830 0
 1233 0a60 70339FE5 		ldr	r3, .L152+4
 1234 0a64 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 1235 0a68 590053E3 		cmp	r3, #89
 1236 0a6c 4800001A 		bne	.L83
 831:main.c        **** 	{
 832:main.c        **** 		AD1CR = 0x00020FF40; // AD1.3
 1237              		.loc 1 832 0
 1238 0a70 64339FE5 		ldr	r3, .L152+8
 1239 0a74 80239FE5 		ldr	r2, .L152+40
 1240 0a78 002083E5 		str	r2, [r3, #0]
 833:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 1241              		.loc 1 833 0
 1242 0a7c 002093E5 		ldr	r2, [r3, #0]
 1243 0a80 012482E3 		orr	r2, r2, #16777216
 1244 0a84 002083E5 		str	r2, [r3, #0]
 1245              	.L84:
 834:main.c        **** 		while((temp & 0x80000000) == 0)
 835:main.c        **** 		{
 836:main.c        **** 			temp = AD1DR;
 1246              		.loc 1 836 0
 1247 0a88 042093E5 		ldr	r2, [r3, #4]
 1248              	.LVL107:
 834:main.c        **** 		while((temp & 0x80000000) == 0)
 1249              		.loc 1 834 0
 1250 0a8c 000052E3 		cmp	r2, #0
 1251 0a90 FCFFFFAA 		bge	.L84
 1252              	.LVL108:
 837:main.c        **** 		}
 838:main.c        **** 		temp &= 0x0000FFC0;
 1253              		.loc 1 838 0
 1254 0a94 48039FE5 		ldr	r0, .L152+16
 839:main.c        **** 		temp2 = temp / 0x00000040;
 840:main.c        **** 
 841:main.c        **** 		AD1CR = 0x00000000;
 1255              		.loc 1 841 0
 1256 0a98 3C339FE5 		ldr	r3, .L152+8
 838:main.c        **** 		temp2 = temp / 0x00000040;
 1257              		.loc 1 838 0
 1258 0a9c 000002E0 		and	r0, r2, r0
 1259              	.LVL109:
 1260              		.loc 1 841 0
 1261 0aa0 0020A0E3 		mov	r2, #0
 1262 0aa4 002083E5 		str	r2, [r3, #0]
 842:main.c        **** 
 843:main.c        **** 		if(asc == 'Y' || asc == ',')
 1263              		.loc 1 843 0
 1264 0aa8 28339FE5 		ldr	r3, .L152+4
 1265 0aac 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1266 0ab0 590053E3 		cmp	r3, #89
 1267 0ab4 2C005313 		cmpne	r3, #44
 839:main.c        **** 
 1268              		.loc 1 839 0
 1269 0ab8 4003A0E1 		mov	r0, r0, asr #6
 1270              	.LVL110:
 1271              		.loc 1 843 0
 1272 0abc 2C00001A 		bne	.L85
 844:main.c        **** 		{
 845:main.c        **** 			itoa(temp2, 10, temp_buff);
 1273              		.loc 1 845 0
 1274 0ac0 0A10A0E3 		mov	r1, #10
 1275 0ac4 0D20A0E1 		mov	r2, sp
 1276 0ac8 FEFFFFEB 		bl	itoa
 1277              	.LVL111:
 846:main.c        **** 			if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 1278              		.loc 1 846 0
 1279 0acc 0030DDE5 		ldrb	r3, [sp, #0]	@ zero_extendqisi2
 1280 0ad0 302043E2 		sub	r2, r3, #48
 1281 0ad4 090052E3 		cmp	r2, #9
 847:main.c        **** 			{
 848:main.c        **** 				q[ind] = temp_buff[0];
 1282              		.loc 1 848 0
 1283 0ad8 38108D92 		addls	r1, sp, #56
 1284 0adc 04208190 		addls	r2, r1, r4
 1285 0ae0 34304295 		strlsb	r3, [r2, #-52]
 849:main.c        **** 				ind++;
 850:main.c        **** 			}
 851:main.c        **** 			if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 1286              		.loc 1 851 0
 1287 0ae4 0130DDE5 		ldrb	r3, [sp, #1]	@ zero_extendqisi2
 1288 0ae8 302043E2 		sub	r2, r3, #48
 849:main.c        **** 				ind++;
 1289              		.loc 1 849 0
 1290 0aec 01408492 		addls	r4, r4, #1
 1291              	.LVL112:
 1292              		.loc 1 851 0
 1293 0af0 090052E3 		cmp	r2, #9
 852:main.c        **** 			{
 853:main.c        **** 				q[ind] = temp_buff[1];
 1294              		.loc 1 853 0
 1295 0af4 38108D92 		addls	r1, sp, #56
 1296 0af8 04208190 		addls	r2, r1, r4
 1297 0afc 34304295 		strlsb	r3, [r2, #-52]
 854:main.c        **** 				ind++;
 855:main.c        **** 			}
 856:main.c        **** 			if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 1298              		.loc 1 856 0
 1299 0b00 0230DDE5 		ldrb	r3, [sp, #2]	@ zero_extendqisi2
 1300 0b04 302043E2 		sub	r2, r3, #48
 854:main.c        **** 				ind++;
 1301              		.loc 1 854 0
 1302 0b08 01408492 		addls	r4, r4, #1
 1303              	.LVL113:
 1304              		.loc 1 856 0
 1305 0b0c 090052E3 		cmp	r2, #9
 857:main.c        **** 			{
 858:main.c        **** 				q[ind] = temp_buff[2];
 1306              		.loc 1 858 0
 1307 0b10 38108D92 		addls	r1, sp, #56
 1308 0b14 04208190 		addls	r2, r1, r4
 1309 0b18 34304295 		strlsb	r3, [r2, #-52]
 859:main.c        **** 				ind++;
 860:main.c        **** 			}
 861:main.c        **** 			if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 1310              		.loc 1 861 0
 1311 0b1c 0330DDE5 		ldrb	r3, [sp, #3]	@ zero_extendqisi2
 1312 0b20 302043E2 		sub	r2, r3, #48
 859:main.c        **** 				ind++;
 1313              		.loc 1 859 0
 1314 0b24 01408492 		addls	r4, r4, #1
 1315              	.LVL114:
 1316              		.loc 1 861 0
 1317 0b28 090052E3 		cmp	r2, #9
 862:main.c        **** 			{
 863:main.c        **** 				q[ind] = temp_buff[3];
 1318              		.loc 1 863 0
 1319 0b2c 38108D92 		addls	r1, sp, #56
 1320 0b30 04208190 		addls	r2, r1, r4
 1321 0b34 34304295 		strlsb	r3, [r2, #-52]
 864:main.c        **** 				ind++;
 865:main.c        **** 			}
 866:main.c        **** 
 867:main.c        **** 			if(asc == ',')
 1322              		.loc 1 867 0
 1323 0b38 98329FE5 		ldr	r3, .L152+4
 1324 0b3c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 864:main.c        **** 				ind++;
 1325              		.loc 1 864 0
 1326 0b40 01408492 		addls	r4, r4, #1
 1327              	.LVL115:
 1328 0b44 38108DE2 		add	r1, sp, #56
 1329              		.loc 1 867 0
 1330 0b48 2C0052E3 		cmp	r2, #44
 1331 0b4c 043081E0 		add	r3, r1, r4
 868:main.c        **** 			{
 869:main.c        **** 				q[ind] = ',';
 870:main.c        **** 			}
 871:main.c        **** 			else
 872:main.c        **** 			{
 873:main.c        **** 				q[ind] = 0;
 1332              		.loc 1 873 0
 1333 0b50 0020A013 		movne	r2, #0
 1334 0b54 342043E5 		strb	r2, [r3, #-52]
 874:main.c        **** 			}
 875:main.c        **** 			ind++;
 876:main.c        **** 			temp = 0; 
 877:main.c        **** 			temp2 = 0;
 878:main.c        **** 			temp_buff[0] = 0;
 1335              		.loc 1 878 0
 1336 0b58 0030A0E3 		mov	r3, #0
 875:main.c        **** 			temp = 0; 
 1337              		.loc 1 875 0
 1338 0b5c 014084E2 		add	r4, r4, #1
 1339              	.LVL116:
 1340              		.loc 1 878 0
 1341 0b60 0030CDE5 		strb	r3, [sp, #0]
 879:main.c        **** 			temp_buff[1] = 0;
 1342              		.loc 1 879 0
 1343 0b64 0130CDE5 		strb	r3, [sp, #1]
 880:main.c        **** 			temp_buff[2] = 0;
 1344              		.loc 1 880 0
 1345 0b68 0230CDE5 		strb	r3, [sp, #2]
 881:main.c        **** 			temp_buff[3] = 0;
 1346              		.loc 1 881 0
 1347 0b6c 0330CDE5 		strb	r3, [sp, #3]
 1348 0b70 070000EA 		b	.L83
 1349              	.LVL117:
 1350              	.L85:
 882:main.c        **** 
 883:main.c        **** 		}
 884:main.c        **** 
 885:main.c        **** 		else if(asc == 'N')
 1351              		.loc 1 885 0
 1352 0b74 4E0053E3 		cmp	r3, #78
 1353 0b78 0500001A 		bne	.L83
 1354              	.LVL118:
 886:main.c        **** 		{
 887:main.c        **** 			a = ((short)temp2 & 0xFF00) / 0x00000100;
 888:main.c        **** 			q[ind] = (char)a;
 1355              		.loc 1 888 0
 1356 0b7c 38208DE2 		add	r2, sp, #56
 1357 0b80 043082E0 		add	r3, r2, r4
 887:main.c        **** 			q[ind] = (char)a;
 1358              		.loc 1 887 0
 1359 0b84 2024A0E1 		mov	r2, r0, lsr #8
 1360              		.loc 1 888 0
 1361 0b88 342043E5 		strb	r2, [r3, #-52]
 889:main.c        **** 			
 890:main.c        **** 			q[ind+1]  = (char)temp2 & 0xFF;
 1362              		.loc 1 890 0
 1363 0b8c 330043E5 		strb	r0, [r3, #-51]
 891:main.c        **** 			ind += 2;
 1364              		.loc 1 891 0
 1365 0b90 024084E2 		add	r4, r4, #2
 1366              	.LVL119:
 1367              	.L83:
 892:main.c        **** 			temp = 0;
 893:main.c        **** 		}
 894:main.c        **** 	}
 895:main.c        **** 	
 896:main.c        **** 	if(asc == ',')	// remove final comma, replace with zero (NULL)
 1368              		.loc 1 896 0
 1369 0b94 3C329FE5 		ldr	r3, .L152+4
 1370 0b98 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 1371 0b9c 2C0053E3 		cmp	r3, #44
 1372 0ba0 0400001A 		bne	.L92
 897:main.c        **** 	{
 898:main.c        **** 		if(ind > 0)	// sanity check, maybe no ADCs were marked to be read
 1373              		.loc 1 898 0
 1374 0ba4 000054E3 		cmp	r4, #0
 899:main.c        **** 		{
 900:main.c        **** 			q[ind-1] = 0;
 1375              		.loc 1 900 0
 1376 0ba8 38108D12 		addne	r1, sp, #56
 1377 0bac 04208110 		addne	r2, r1, r4
 1378 0bb0 0010A013 		movne	r1, #0
 1379 0bb4 35104215 		strneb	r1, [r2, #-53]
 1380              	.L92:
 1381 0bb8 40129FE5 		ldr	r1, .L152+44
 1382 0bbc 40729FE5 		ldr	r7, .L152+48
 1383 0bc0 B020D1E1 		ldrh	r2, [r1, #0]
 1384 0bc4 02C0D1E5 		ldrb	ip, [r1, #2]	@ zero_extendqisi2
 1385 0bc8 0300D1E5 		ldrb	r0, [r1, #3]	@ zero_extendqisi2
 901:main.c        **** 		}
 902:main.c        **** 	}
 903:main.c        **** 	
 904:main.c        **** 	for(j = 0; j < ind; j++)
 905:main.c        **** 	{
 906:main.c        **** 		if(RX_in < 512)
 907:main.c        **** 		{
 908:main.c        **** 			RX_array1[RX_in] = q[j];
 909:main.c        **** 			RX_in++;
 910:main.c        **** 
 911:main.c        **** 			if(RX_in == 512) log_array1 = 1;
 912:main.c        **** 		}
 913:main.c        **** 		else if(RX_in >= 512)
 914:main.c        **** 		{
 915:main.c        **** 			RX_array2[RX_in - 512] = q[j];
 1386              		.loc 1 915 0 discriminator 1
 1387 0bcc 34829FE5 		ldr	r8, .L152+52
 916:main.c        **** 			RX_in++;
 917:main.c        **** 
 918:main.c        **** 			if(RX_in == 1024)
 919:main.c        **** 			{
 920:main.c        **** 				log_array2 = 1;
 921:main.c        **** 				RX_in = 0;
 1388              		.loc 1 921 0 discriminator 1
 1389 0bd0 0010A0E3 		mov	r1, #0
 908:main.c        **** 			RX_in++;
 1390              		.loc 1 908 0 discriminator 1
 1391 0bd4 30A29FE5 		ldr	sl, .L152+56
 1392 0bd8 170000EA 		b	.L93
 1393              	.LVL120:
 1394              	.L97:
 906:main.c        **** 		{
 1395              		.loc 1 906 0
 1396 0bdc 0298A0E1 		mov	r9, r2, asl #16
 1397 0be0 4968A0E1 		mov	r6, r9, asr #16
 1398 0be4 070056E1 		cmp	r6, r7
 1399 0be8 04508DE2 		add	r5, sp, #4
 1400 0bec 070000CA 		bgt	.L94
 908:main.c        **** 			RX_in++;
 1401              		.loc 1 908 0
 1402 0bf0 0150D5E7 		ldrb	r5, [r5, r1]	@ zero_extendqisi2
 909:main.c        **** 
 1403              		.loc 1 909 0
 1404 0bf4 012082E2 		add	r2, r2, #1
 908:main.c        **** 			RX_in++;
 1405              		.loc 1 908 0
 1406 0bf8 4958CAE7 		strb	r5, [sl, r9, asr #16]
 909:main.c        **** 
 1407              		.loc 1 909 0
 1408 0bfc 0258A0E1 		mov	r5, r2, asl #16
 911:main.c        **** 		}
 1409              		.loc 1 911 0
 1410 0c00 020455E3 		cmp	r5, #33554432
 1411 0c04 2528A0E1 		mov	r2, r5, lsr #16
 1412 0c08 01C0A003 		moveq	ip, #1
 1413 0c0c 090000EA 		b	.L95
 1414              	.L94:
 915:main.c        **** 			RX_in++;
 1415              		.loc 1 915 0
 1416 0c10 0150D5E7 		ldrb	r5, [r5, r1]	@ zero_extendqisi2
 916:main.c        **** 
 1417              		.loc 1 916 0
 1418 0c14 012082E2 		add	r2, r2, #1
 1419 0c18 0228A0E1 		mov	r2, r2, asl #16
 915:main.c        **** 			RX_in++;
 1420              		.loc 1 915 0
 1421 0c1c 066088E0 		add	r6, r8, r6
 1422 0c20 005246E5 		strb	r5, [r6, #-512]
 918:main.c        **** 			{
 1423              		.loc 1 918 0
 1424 0c24 4258A0E1 		mov	r5, r2, asr #16
 920:main.c        **** 				RX_in = 0;
 1425              		.loc 1 920 0
 1426 0c28 010B55E3 		cmp	r5, #1024
 1427 0c2c 0100A003 		moveq	r0, #1
 1428 0c30 0020A003 		moveq	r2, #0
 1429 0c34 2228A011 		movne	r2, r2, lsr #16
 1430              	.L95:
 904:main.c        **** 	{
 1431              		.loc 1 904 0
 1432 0c38 011081E2 		add	r1, r1, #1
 1433              	.LVL121:
 1434              	.L93:
 904:main.c        **** 	{
 1435              		.loc 1 904 0 is_stmt 0 discriminator 1
 1436 0c3c 040051E1 		cmp	r1, r4
 1437 0c40 E5FFFFBA 		blt	.L97
 1438 0c44 B4119FE5 		ldr	r1, .L152+44
 1439              	.LVL122:
 1440 0c48 02C0C1E5 		strb	ip, [r1, #2]
 1441 0c4c 0300C1E5 		strb	r0, [r1, #3]
 922:main.c        **** 			}
 923:main.c        **** 		}
 924:main.c        **** 	}
 925:main.c        **** 	if(RX_in < 512)
 1442              		.loc 1 925 0 is_stmt 1
 1443 0c50 ACC19FE5 		ldr	ip, .L152+48
 1444 0c54 0208A0E1 		mov	r0, r2, asl #16
 1445 0c58 4018A0E1 		mov	r1, r0, asr #16
 1446 0c5c 0C0051E1 		cmp	r1, ip
 1447 0c60 110000CA 		bgt	.L98
 926:main.c        **** 	{
 927:main.c        **** 		if(asc == 'N') { RX_array1[RX_in] = '$'; }
 1448              		.loc 1 927 0
 1449 0c64 4E0053E3 		cmp	r3, #78
 1450 0c68 24C0A003 		moveq	ip, #36
 1451 0c6c 0300000A 		beq	.L148
 1452              	.L99:
 928:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array1[RX_in] = 13; }
 1453              		.loc 1 928 0
 1454 0c70 590053E3 		cmp	r3, #89
 1455 0c74 2C005313 		cmpne	r3, #44
 1456 0c78 0200001A 		bne	.L100
 1457              		.loc 1 928 0 is_stmt 0 discriminator 1
 1458 0c7c 0DC0A0E3 		mov	ip, #13
 1459              	.L148:
 1460 0c80 84119FE5 		ldr	r1, .L152+56
 1461 0c84 40C8C1E7 		strb	ip, [r1, r0, asr #16]
 1462              	.L100:
 929:main.c        **** 		RX_in++;
 1463              		.loc 1 929 0 is_stmt 1
 1464 0c88 012082E2 		add	r2, r2, #1
 1465 0c8c 0228A0E1 		mov	r2, r2, asl #16
 1466 0c90 2228A0E1 		mov	r2, r2, lsr #16
 1467 0c94 64119FE5 		ldr	r1, .L152+44
 930:main.c        **** 
 931:main.c        **** 		if(RX_in == 512) log_array1 = 1;
 1468              		.loc 1 931 0
 1469 0c98 020C52E3 		cmp	r2, #512
 929:main.c        **** 		RX_in++;
 1470              		.loc 1 929 0
 1471 0c9c B020C1E1 		strh	r2, [r1, #0]	@ movhi
 1472              		.loc 1 931 0
 1473 0ca0 0120A003 		moveq	r2, #1
 1474 0ca4 0220C105 		streqb	r2, [r1, #2]
 1475 0ca8 150000EA 		b	.L102
 1476              	.L98:
 932:main.c        **** 	}
 933:main.c        **** 	else if(RX_in >= 512)
 934:main.c        **** 	{
 935:main.c        **** 		
 936:main.c        **** 		if(asc == 'N') RX_array2[RX_in - 512] = '$';
 1477              		.loc 1 936 0
 1478 0cac 4E0053E3 		cmp	r3, #78
 1479              		.loc 1 936 0 is_stmt 0 discriminator 1
 1480 0cb0 50019F05 		ldreq	r0, .L152+52
 1481 0cb4 01108000 		addeq	r1, r0, r1
 1482 0cb8 2400A003 		moveq	r0, #36
 1483 0cbc 0500000A 		beq	.L149
 1484              	.L103:
 937:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array2[RX_in - 512] = 13; }
 1485              		.loc 1 937 0 is_stmt 1
 1486 0cc0 590053E3 		cmp	r3, #89
 1487 0cc4 2C005313 		cmpne	r3, #44
 1488 0cc8 0300001A 		bne	.L104
 1489              		.loc 1 937 0 is_stmt 0 discriminator 1
 1490 0ccc 34019FE5 		ldr	r0, .L152+52
 1491 0cd0 011080E0 		add	r1, r0, r1
 1492 0cd4 0D00A0E3 		mov	r0, #13
 1493              	.L149:
 1494 0cd8 000241E5 		strb	r0, [r1, #-512]
 1495              	.L104:
 938:main.c        **** 		RX_in++;
 1496              		.loc 1 938 0 is_stmt 1
 1497 0cdc 012082E2 		add	r2, r2, #1
 1498 0ce0 0228A0E1 		mov	r2, r2, asl #16
 1499 0ce4 2228A0E1 		mov	r2, r2, lsr #16
 1500 0ce8 10119FE5 		ldr	r1, .L152+44
 939:main.c        **** 		
 940:main.c        **** 		if(RX_in == 1024)
 1501              		.loc 1 940 0
 1502 0cec 010B52E3 		cmp	r2, #1024
 938:main.c        **** 		RX_in++;
 1503              		.loc 1 938 0
 1504 0cf0 B020C1E1 		strh	r2, [r1, #0]	@ movhi
 941:main.c        **** 		{
 942:main.c        **** 			log_array2 = 1;
 1505              		.loc 1 942 0
 1506 0cf4 0120A003 		moveq	r2, #1
 1507 0cf8 0320C105 		streqb	r2, [r1, #3]
 943:main.c        **** 			RX_in = 0;
 1508              		.loc 1 943 0
 1509 0cfc 0020A003 		moveq	r2, #0
 1510 0d00 B020C101 		streqh	r2, [r1, #0]	@ movhi
 1511              	.L102:
 944:main.c        **** 		}
 945:main.c        **** 	}
 946:main.c        **** 	if(RX_in < 512)
 1512              		.loc 1 946 0
 1513 0d04 F4209FE5 		ldr	r2, .L152+44
 1514 0d08 B020D2E1 		ldrh	r2, [r2, #0]
 1515 0d0c 0208A0E1 		mov	r0, r2, asl #16
 1516 0d10 4018A0E1 		mov	r1, r0, asr #16
 1517 0d14 020C51E3 		cmp	r1, #512
 1518 0d18 110000AA 		bge	.L106
 947:main.c        **** 	{
 948:main.c        **** 		if(asc == 'N') RX_array1[RX_in] = '$';
 1519              		.loc 1 948 0
 1520 0d1c 4E0053E3 		cmp	r3, #78
 1521 0d20 2410A003 		moveq	r1, #36
 1522 0d24 0300000A 		beq	.L150
 1523              	.L107:
 949:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array1[RX_in] = 10; }
 1524              		.loc 1 949 0
 1525 0d28 590053E3 		cmp	r3, #89
 1526 0d2c 2C005313 		cmpne	r3, #44
 1527 0d30 0200001A 		bne	.L108
 1528              		.loc 1 949 0 is_stmt 0 discriminator 1
 1529 0d34 0A10A0E3 		mov	r1, #10
 1530              	.L150:
 1531 0d38 CC309FE5 		ldr	r3, .L152+56
 1532 0d3c 4018C3E7 		strb	r1, [r3, r0, asr #16]
 1533              	.L108:
 950:main.c        **** 		RX_in++;
 1534              		.loc 1 950 0 is_stmt 1
 1535 0d40 012082E2 		add	r2, r2, #1
 1536 0d44 0228A0E1 		mov	r2, r2, asl #16
 1537 0d48 2228A0E1 		mov	r2, r2, lsr #16
 1538 0d4c AC309FE5 		ldr	r3, .L152+44
 951:main.c        **** 
 952:main.c        **** 		if(RX_in == 512) log_array1 = 1;
 1539              		.loc 1 952 0
 1540 0d50 020C52E3 		cmp	r2, #512
 950:main.c        **** 		RX_in++;
 1541              		.loc 1 950 0
 1542 0d54 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 1543              		.loc 1 952 0
 1544 0d58 0120A003 		moveq	r2, #1
 1545 0d5c 0220C305 		streqb	r2, [r3, #2]
 1546 0d60 150000EA 		b	.L110
 1547              	.L106:
 953:main.c        **** 	}
 954:main.c        **** 	else if(RX_in >= 512)
 955:main.c        **** 	{
 956:main.c        **** 		
 957:main.c        **** 		if(asc == 'N') RX_array2[RX_in - 512] = '$';
 1548              		.loc 1 957 0
 1549 0d64 4E0053E3 		cmp	r3, #78
 1550              		.loc 1 957 0 is_stmt 0 discriminator 1
 1551 0d68 98309F05 		ldreq	r3, .L152+52
 1552 0d6c 01108300 		addeq	r1, r3, r1
 1553 0d70 2430A003 		moveq	r3, #36
 1554 0d74 0500000A 		beq	.L151
 1555              	.L111:
 958:main.c        **** 		else if(asc == 'Y' || asc == ','){ RX_array2[RX_in - 512] = 10; }
 1556              		.loc 1 958 0 is_stmt 1
 1557 0d78 590053E3 		cmp	r3, #89
 1558 0d7c 2C005313 		cmpne	r3, #44
 1559 0d80 0300001A 		bne	.L112
 1560              		.loc 1 958 0 is_stmt 0 discriminator 1
 1561 0d84 7C309FE5 		ldr	r3, .L152+52
 1562 0d88 011083E0 		add	r1, r3, r1
 1563 0d8c 0A30A0E3 		mov	r3, #10
 1564              	.L151:
 1565 0d90 003241E5 		strb	r3, [r1, #-512]
 1566              	.L112:
 959:main.c        **** 		RX_in++;
 1567              		.loc 1 959 0 is_stmt 1
 1568 0d94 012082E2 		add	r2, r2, #1
 1569 0d98 0228A0E1 		mov	r2, r2, asl #16
 1570 0d9c 2228A0E1 		mov	r2, r2, lsr #16
 1571 0da0 58309FE5 		ldr	r3, .L152+44
 960:main.c        **** 		
 961:main.c        **** 		if(RX_in == 1024)
 1572              		.loc 1 961 0
 1573 0da4 010B52E3 		cmp	r2, #1024
 959:main.c        **** 		RX_in++;
 1574              		.loc 1 959 0
 1575 0da8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 962:main.c        **** 		{
 963:main.c        **** 			log_array2 = 1;
 1576              		.loc 1 963 0
 1577 0dac 0120A003 		moveq	r2, #1
 1578 0db0 0320C305 		streqb	r2, [r3, #3]
 964:main.c        **** 			RX_in = 0;
 1579              		.loc 1 964 0
 1580 0db4 0020A003 		moveq	r2, #0
 1581 0db8 B020C301 		streqh	r2, [r3, #0]	@ movhi
 1582              	.L110:
 965:main.c        **** 		}
 966:main.c        **** 	}
 967:main.c        **** 
 968:main.c        **** 	VICVectAddr= 0;
 1583              		.loc 1 968 0
 1584 0dbc 0020A0E3 		mov	r2, #0
 1585 0dc0 0030E0E3 		mvn	r3, #0
 1586 0dc4 CF2F03E5 		str	r2, [r3, #-4047]
 969:main.c        **** }
 1587              		.loc 1 969 0
 1588 0dc8 38D08DE2 		add	sp, sp, #56
 1589 0dcc F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1590 0dd0 1EFF2FE1 		bx	lr
 1591              	.L153:
 1592              		.align	2
 1593              	.L152:
 1594 0dd4 004000E0 		.word	-536854528
 1595 0dd8 00000000 		.word	.LANCHOR1
 1596 0ddc 000006E0 		.word	-536477696
 1597 0de0 08FF2000 		.word	2162440
 1598 0de4 C0FF0000 		.word	65472
 1599 0de8 004003E0 		.word	-536657920
 1600 0dec 04FF2000 		.word	2162436
 1601 0df0 02FF2000 		.word	2162434
 1602 0df4 10FF2000 		.word	2162448
 1603 0df8 80FF2000 		.word	2162560
 1604 0dfc 40FF2000 		.word	2162496
 1605 0e00 00000000 		.word	.LANCHOR0
 1606 0e04 FF010000 		.word	511
 1607 0e08 00000000 		.word	RX_array2
 1608 0e0c 00000000 		.word	RX_array1
 1609              		.cfi_endproc
 1610              	.LFE5:
 1612              		.align	2
 1613              		.global	Initialize
 1615              	Initialize:
 1616              	.LFB1:
 250:main.c        **** 	rprintf_devopen(putc_serial0);
 1617              		.loc 1 250 0
 1618              		.cfi_startproc
 1619              		@ Function supports interworking.
 1620              		@ args = 0, pretend = 0, frame = 0
 1621              		@ frame_needed = 0, uses_anonymous_args = 0
 1622 0e10 04E02DE5 		str	lr, [sp, #-4]!
 1623              	.LCFI3:
 1624              		.cfi_def_cfa_offset 4
 1625              		.cfi_offset 14, -4
 251:main.c        **** 	
 1626              		.loc 1 251 0
 1627 0e14 4C009FE5 		ldr	r0, .L155
 1628 0e18 FEFFFFEB 		bl	rprintf_devopen
 1629              	.LVL123:
 253:main.c        **** 	PINSEL1 = 0x15441801;
 1630              		.loc 1 253 0
 1631 0e1c 48309FE5 		ldr	r3, .L155+4
 1632 0e20 48209FE5 		ldr	r2, .L155+8
 1633 0e24 002083E5 		str	r2, [r3, #0]
 254:main.c        **** 	IODIR0 |= 0x00000884;
 1634              		.loc 1 254 0
 1635 0e28 44209FE5 		ldr	r2, .L155+12
 1636 0e2c 042083E5 		str	r2, [r3, #4]
 255:main.c        **** 	IOSET0 = 0x00000080;
 1637              		.loc 1 255 0
 1638 0e30 013943E2 		sub	r3, r3, #16384
 1639 0e34 082093E5 		ldr	r2, [r3, #8]
 1640 0e38 222D82E3 		orr	r2, r2, #2176
 1641 0e3c 042082E3 		orr	r2, r2, #4
 1642 0e40 082083E5 		str	r2, [r3, #8]
 256:main.c        **** 
 1643              		.loc 1 256 0
 1644 0e44 8020A0E3 		mov	r2, #128
 1645 0e48 042083E5 		str	r2, [r3, #4]
 258:main.c        **** 	S0SPCR = 0x30;  // master, msb, first clk edge, active high, no ints
 1646              		.loc 1 258 0
 1647 0e4c 023943E2 		sub	r3, r3, #32768
 1648 0e50 0820A0E3 		mov	r2, #8
 1649 0e54 0020C3E5 		strb	r2, [r3, #0]
 259:main.c        **** 
 1650              		.loc 1 259 0
 1651 0e58 3020A0E3 		mov	r2, #48
 1652 0e5c 0020C3E5 		strb	r2, [r3, #0]
 261:main.c        **** 
 1653              		.loc 1 261 0
 1654 0e60 04E09DE4 		ldr	lr, [sp], #4
 1655 0e64 1EFF2FE1 		bx	lr
 1656              	.L156:
 1657              		.align	2
 1658              	.L155:
 1659 0e68 00000000 		.word	putc_serial0
 1660 0e6c 00C002E0 		.word	-536690688
 1661 0e70 051535CF 		.word	-818604795
 1662 0e74 01184415 		.word	356784129
 1663              		.cfi_endproc
 1664              	.LFE1:
 1666              		.align	2
 1667              		.global	feed
 1669              	feed:
 1670              	.LFB2:
 264:main.c        **** 	PLLFEED=0xAA;
 1671              		.loc 1 264 0
 1672              		.cfi_startproc
 1673              		@ Function supports interworking.
 1674              		@ args = 0, pretend = 0, frame = 0
 1675              		@ frame_needed = 0, uses_anonymous_args = 0
 1676              		@ link register save eliminated.
 265:main.c        **** 	PLLFEED=0x55;
 1677              		.loc 1 265 0
 1678 0e78 10309FE5 		ldr	r3, .L158
 1679 0e7c 5520E0E3 		mvn	r2, #85
 1680 0e80 8C20C3E5 		strb	r2, [r3, #140]
 266:main.c        **** }
 1681              		.loc 1 266 0
 1682 0e84 5520A0E3 		mov	r2, #85
 1683 0e88 8C20C3E5 		strb	r2, [r3, #140]
 1684 0e8c 1EFF2FE1 		bx	lr
 1685              	.L159:
 1686              		.align	2
 1687              	.L158:
 1688 0e90 00C01FE0 		.word	-534790144
 1689              		.cfi_endproc
 1690              	.LFE2:
 1692              		.align	2
 1693              		.global	FIQ_Routine
 1695              	FIQ_Routine:
 1696              	.LFB6:
 970:main.c        **** 
 971:main.c        **** void FIQ_Routine(void)
 972:main.c        **** {
 1697              		.loc 1 972 0
 1698              		.cfi_startproc
 1699              		@ Fast Interrupt Service Routine.
 1700              		@ args = 0, pretend = 0, frame = 0
 1701              		@ frame_needed = 0, uses_anonymous_args = 0
 1702              		@ link register save eliminated.
 1703              	.LVL124:
 1704 0e94 0C002DE9 		stmfd	sp!, {r2, r3}
 1705              	.LCFI4:
 1706              		.cfi_def_cfa_offset 8
 1707              		.cfi_offset 2, -8
 1708              		.cfi_offset 3, -4
 1709              	.LBB10:
 1710              	.LBB11:
 973:main.c        **** 	char a;
 974:main.c        **** 	int j;
 975:main.c        **** 
 976:main.c        **** 	stat(0,ON);
 977:main.c        **** 	for(j = 0; j < 5000000; j++);
 978:main.c        **** 	stat(0,OFF);
 979:main.c        **** 	a = U0RBR;
 980:main.c        **** 
 981:main.c        **** 	a = U0IIR;  // have to read this to clear the interrupt
 982:main.c        **** }
 983:main.c        **** 
 984:main.c        **** void SWI_Routine(void)
 985:main.c        **** {
 986:main.c        **** 	while(1);
 987:main.c        **** }
 988:main.c        **** 
 989:main.c        **** void UNDEF_Routine(void)
 990:main.c        **** {
 991:main.c        **** 	stat(0,ON);
 992:main.c        **** }
 993:main.c        **** 
 994:main.c        **** void setup_uart0(int newbaud, char want_ints)
 995:main.c        **** {
 996:main.c        **** 	baud = newbaud;
 997:main.c        **** 	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
 998:main.c        **** 	
 999:main.c        **** 	if(baud == 1200)
1000:main.c        **** 	{
1001:main.c        **** 		U0DLM = 0x0C;
1002:main.c        **** 		U0DLL = 0x00;
1003:main.c        **** 	}
1004:main.c        **** 	else if(baud == 2400)
1005:main.c        **** 	{
1006:main.c        **** 		U0DLM = 0x06;
1007:main.c        **** 		U0DLL = 0x00;
1008:main.c        **** 	}
1009:main.c        **** 	else if(baud == 4800)
1010:main.c        **** 	{
1011:main.c        **** 		U0DLM = 0x03;
1012:main.c        **** 		U0DLL = 0x00;
1013:main.c        **** 	}
1014:main.c        **** 	else if(baud == 9600)
1015:main.c        **** 	{
1016:main.c        **** 		U0DLM = 0x01;
1017:main.c        **** 		U0DLL = 0x80;
1018:main.c        **** 	}
1019:main.c        **** 	else if(baud == 19200)
1020:main.c        **** 	{
1021:main.c        **** 		U0DLM = 0x00;
1022:main.c        **** 		U0DLL = 0xC0;
1023:main.c        **** 	}
1024:main.c        **** 	else if(baud == 38400)
1025:main.c        **** 	{
1026:main.c        **** 		U0DLM = 0x00;
1027:main.c        **** 		U0DLL = 0x60;
1028:main.c        **** 	}
1029:main.c        **** 	else if(baud == 57600)
1030:main.c        **** 	{
1031:main.c        **** 		U0DLM = 0x00;
1032:main.c        **** 		U0DLL = 0x40;
1033:main.c        **** 	}
1034:main.c        **** 	else if(baud == 115200)
1035:main.c        **** 	{
1036:main.c        **** 		U0DLM = 0x00;
1037:main.c        **** 		U0DLL = 0x20;
1038:main.c        **** 	}
1039:main.c        **** 
1040:main.c        **** 	U0FCR = 0x01;
1041:main.c        **** 	U0LCR = 0x03;   
1042:main.c        **** 
1043:main.c        **** 	if(want_ints == 1)
1044:main.c        **** 	{
1045:main.c        **** 		enableIRQ();
1046:main.c        **** 		VICIntSelect &= ~0x00000040;
1047:main.c        **** 		VICIntEnable |= 0x00000040;
1048:main.c        **** 		VICVectCntl1 = 0x26;
1049:main.c        **** 		VICVectAddr1 = (unsigned int)UART0ISR;
1050:main.c        **** 		U0IER = 0x01;
1051:main.c        **** 	}
1052:main.c        **** 	else if(want_ints == 2)
1053:main.c        **** 	{
1054:main.c        **** 		enableIRQ();
1055:main.c        **** 		VICIntSelect &= ~0x00000040;
1056:main.c        **** 		VICIntEnable |= 0x00000040;
1057:main.c        **** 		VICVectCntl2 = 0x26;
1058:main.c        **** 		VICVectAddr2 = (unsigned int)UART0ISR_2;
1059:main.c        **** 		U0IER = 0X01;
1060:main.c        **** 	}
1061:main.c        **** 	else if(want_ints == 0)
1062:main.c        **** 	{
1063:main.c        **** 		VICIntEnClr = 0x00000040;
1064:main.c        **** 		U0IER = 0x00;
1065:main.c        **** 	}
1066:main.c        **** }
1067:main.c        **** 
1068:main.c        **** void stat(int statnum, int onoff)
1069:main.c        **** {
1070:main.c        **** 	if(statnum) // Stat 1
1071:main.c        **** 	{
1072:main.c        **** 		if(onoff){ IOCLR0 = 0x00000800; } // On
1073:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
1074:main.c        **** 	}
1075:main.c        **** 	else // Stat 0 
1076:main.c        **** 	{
1077:main.c        **** 		if(onoff){ IOCLR0 = 0x00000004; } // On
 1711              		.loc 1 1077 0
 1712 0e98 1C309FE5 		ldr	r3, .L161
 1713 0e9c 0420A0E3 		mov	r2, #4
 1714 0ea0 0C2083E5 		str	r2, [r3, #12]
 1715              	.LVL125:
 1716              	.LBE11:
 1717              	.LBE10:
 1718              	.LBB12:
 1719              	.LBB13:
1078:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 1720              		.loc 1 1078 0
 1721 0ea4 042083E5 		str	r2, [r3, #4]
 1722              	.LBE13:
 1723              	.LBE12:
 979:main.c        **** 
 1724              		.loc 1 979 0
 1725 0ea8 073943E2 		sub	r3, r3, #114688
 1726 0eac 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1727              	.LVL126:
 981:main.c        **** }
 1728              		.loc 1 981 0
 1729 0eb0 0830D3E5 		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 982:main.c        **** 
 1730              		.loc 1 982 0
 1731 0eb4 0C00BDE8 		ldmfd	sp!, {r2, r3}
 1732 0eb8 04F05EE2 		subs	pc, lr, #4
 1733              	.L162:
 1734              		.align	2
 1735              	.L161:
 1736 0ebc 008002E0 		.word	-536707072
 1737              		.cfi_endproc
 1738              	.LFE6:
 1740              		.align	2
 1741              		.global	SWI_Routine
 1743              	SWI_Routine:
 1744              	.LFB7:
 985:main.c        **** 	while(1);
 1745              		.loc 1 985 0
 1746              		.cfi_startproc
 1747              		@ ARM Exception Handler.
 1748              		@ Volatile: function does not return.
 1749              		@ args = 0, pretend = 0, frame = 0
 1750              		@ frame_needed = 0, uses_anonymous_args = 0
 1751              		@ link register save eliminated.
 1752              	.L164:
 1753 0ec0 FEFFFFEA 		b	.L164
 1754              		.cfi_endproc
 1755              	.LFE7:
 1757              		.align	2
 1758              		.global	UNDEF_Routine
 1760              	UNDEF_Routine:
 1761              	.LFB8:
 990:main.c        **** 	stat(0,ON);
 1762              		.loc 1 990 0
 1763              		.cfi_startproc
 1764              		@ ARM Exception Handler.
 1765              		@ args = 0, pretend = 0, frame = 0
 1766              		@ frame_needed = 0, uses_anonymous_args = 0
 1767              		@ link register save eliminated.
 1768              	.LVL127:
 990:main.c        **** 	stat(0,ON);
 1769              		.loc 1 990 0
 1770 0ec4 0C002DE9 		stmfd	sp!, {r2, r3}
 1771              	.LCFI5:
 1772              		.cfi_def_cfa_offset 8
 1773              		.cfi_offset 2, -8
 1774              		.cfi_offset 3, -4
 1775              	.LBB18:
 1776              	.LBB19:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 1777              		.loc 1 1077 0
 1778 0ec8 0C309FE5 		ldr	r3, .L166
 1779 0ecc 0420A0E3 		mov	r2, #4
 1780 0ed0 0C2083E5 		str	r2, [r3, #12]
 1781              	.LBE19:
 1782              	.LBE18:
 992:main.c        **** 
 1783              		.loc 1 992 0
 1784 0ed4 0C00BDE8 		ldmfd	sp!, {r2, r3}
 1785 0ed8 0EF0B0E1 		movs	pc, lr
 1786              	.L167:
 1787              		.align	2
 1788              	.L166:
 1789 0edc 008002E0 		.word	-536707072
 1790              		.cfi_endproc
 1791              	.LFE8:
 1793              		.align	2
 1794              		.global	setup_uart0
 1796              	setup_uart0:
 1797              	.LFB9:
 995:main.c        **** 	baud = newbaud;
 1798              		.loc 1 995 0
 1799              		.cfi_startproc
 1800              		@ Function supports interworking.
 1801              		@ args = 0, pretend = 0, frame = 0
 1802              		@ frame_needed = 0, uses_anonymous_args = 0
 1803              	.LVL128:
 996:main.c        **** 	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
 1804              		.loc 1 996 0
 1805 0ee0 60319FE5 		ldr	r3, .L183
 995:main.c        **** 	baud = newbaud;
 1806              		.loc 1 995 0
 1807 0ee4 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1808              	.LCFI6:
 1809              		.cfi_def_cfa_offset 16
 1810              		.cfi_offset 4, -16
 1811              		.cfi_offset 5, -12
 1812              		.cfi_offset 6, -8
 1813              		.cfi_offset 14, -4
 996:main.c        **** 	U0LCR = 0x83;   // 8 bits, no parity, 1 stop bit, DLAB = 1
 1814              		.loc 1 996 0
 1815 0ee8 100083E5 		str	r0, [r3, #16]
 997:main.c        **** 	
 1816              		.loc 1 997 0
 1817 0eec 58319FE5 		ldr	r3, .L183+4
 1818 0ef0 7C20E0E3 		mvn	r2, #124
 999:main.c        **** 	{
 1819              		.loc 1 999 0
 1820 0ef4 4B0E50E3 		cmp	r0, #1200
 997:main.c        **** 	
 1821              		.loc 1 997 0
 1822 0ef8 0C20C3E5 		strb	r2, [r3, #12]
 995:main.c        **** 	baud = newbaud;
 1823              		.loc 1 995 0
 1824 0efc FF4001E2 		and	r4, r1, #255
1001:main.c        **** 		U0DLL = 0x00;
 1825              		.loc 1 1001 0
 1826 0f00 0C20A003 		moveq	r2, #12
 999:main.c        **** 	{
 1827              		.loc 1 999 0
 1828 0f04 0200000A 		beq	.L182
 1829              	.L169:
1004:main.c        **** 	{
 1830              		.loc 1 1004 0
 1831 0f08 960E50E3 		cmp	r0, #2400
 1832 0f0c 0300001A 		bne	.L171
1006:main.c        **** 		U0DLL = 0x00;
 1833              		.loc 1 1006 0
 1834 0f10 0620A0E3 		mov	r2, #6
 1835              	.L182:
 1836 0f14 0420C3E5 		strb	r2, [r3, #4]
1007:main.c        **** 	}
 1837              		.loc 1 1007 0
 1838 0f18 0020A0E3 		mov	r2, #0
 1839 0f1c 1C0000EA 		b	.L180
 1840              	.L171:
1009:main.c        **** 	{
 1841              		.loc 1 1009 0
 1842 0f20 4B0D50E3 		cmp	r0, #4800
1011:main.c        **** 		U0DLL = 0x00;
 1843              		.loc 1 1011 0
 1844 0f24 0320A003 		moveq	r2, #3
1009:main.c        **** 	{
 1845              		.loc 1 1009 0
 1846 0f28 F9FFFF0A 		beq	.L182
 1847              	.L172:
1014:main.c        **** 	{
 1848              		.loc 1 1014 0
 1849 0f2c 960D50E3 		cmp	r0, #9600
1016:main.c        **** 		U0DLL = 0x80;
 1850              		.loc 1 1016 0
 1851 0f30 0120A003 		moveq	r2, #1
 1852 0f34 0420C305 		streqb	r2, [r3, #4]
1017:main.c        **** 	}
 1853              		.loc 1 1017 0
 1854 0f38 7F20E003 		mvneq	r2, #127
1014:main.c        **** 	{
 1855              		.loc 1 1014 0
 1856 0f3c 1400000A 		beq	.L180
 1857              	.L173:
1019:main.c        **** 	{
 1858              		.loc 1 1019 0
 1859 0f40 4B0C50E3 		cmp	r0, #19200
1021:main.c        **** 		U0DLL = 0xC0;
 1860              		.loc 1 1021 0
 1861 0f44 0020A003 		moveq	r2, #0
 1862 0f48 0420C305 		streqb	r2, [r3, #4]
1022:main.c        **** 	}
 1863              		.loc 1 1022 0
 1864 0f4c 3F20E003 		mvneq	r2, #63
1019:main.c        **** 	{
 1865              		.loc 1 1019 0
 1866 0f50 0F00000A 		beq	.L180
 1867              	.L174:
1024:main.c        **** 	{
 1868              		.loc 1 1024 0
 1869 0f54 960C50E3 		cmp	r0, #38400
1026:main.c        **** 		U0DLL = 0x60;
 1870              		.loc 1 1026 0
 1871 0f58 0020A003 		moveq	r2, #0
 1872 0f5c 0420C305 		streqb	r2, [r3, #4]
1027:main.c        **** 	}
 1873              		.loc 1 1027 0
 1874 0f60 6020A003 		moveq	r2, #96
1024:main.c        **** 	{
 1875              		.loc 1 1024 0
 1876 0f64 0A00000A 		beq	.L180
 1877              	.L175:
1029:main.c        **** 	{
 1878              		.loc 1 1029 0
 1879 0f68 E10C50E3 		cmp	r0, #57600
1031:main.c        **** 		U0DLL = 0x40;
 1880              		.loc 1 1031 0
 1881 0f6c 0020A003 		moveq	r2, #0
 1882 0f70 0420C305 		streqb	r2, [r3, #4]
1032:main.c        **** 	}
 1883              		.loc 1 1032 0
 1884 0f74 4020A003 		moveq	r2, #64
1029:main.c        **** 	{
 1885              		.loc 1 1029 0
 1886 0f78 0500000A 		beq	.L180
 1887              	.L176:
1034:main.c        **** 	{
 1888              		.loc 1 1034 0
 1889 0f7c CC209FE5 		ldr	r2, .L183+8
 1890 0f80 020050E1 		cmp	r0, r2
 1891 0f84 0300001A 		bne	.L170
1036:main.c        **** 		U0DLL = 0x20;
 1892              		.loc 1 1036 0
 1893 0f88 0020A0E3 		mov	r2, #0
 1894 0f8c 0420C3E5 		strb	r2, [r3, #4]
1037:main.c        **** 	}
 1895              		.loc 1 1037 0
 1896 0f90 2020A0E3 		mov	r2, #32
 1897              	.L180:
 1898 0f94 0020C3E5 		strb	r2, [r3, #0]
 1899              	.L170:
1040:main.c        **** 	U0LCR = 0x03;   
 1900              		.loc 1 1040 0
 1901 0f98 0160A0E3 		mov	r6, #1
1041:main.c        **** 
 1902              		.loc 1 1041 0
 1903 0f9c 0320A0E3 		mov	r2, #3
1043:main.c        **** 	{
 1904              		.loc 1 1043 0
 1905 0fa0 060054E1 		cmp	r4, r6
1040:main.c        **** 	U0LCR = 0x03;   
 1906              		.loc 1 1040 0
 1907 0fa4 0860C3E5 		strb	r6, [r3, #8]
 1908 0fa8 9C509FE5 		ldr	r5, .L183+4
1041:main.c        **** 
 1909              		.loc 1 1041 0
 1910 0fac 0C20C3E5 		strb	r2, [r3, #12]
1043:main.c        **** 	{
 1911              		.loc 1 1043 0
 1912 0fb0 0C00001A 		bne	.L177
1045:main.c        **** 		VICIntSelect &= ~0x00000040;
 1913              		.loc 1 1045 0
 1914 0fb4 FEFFFFEB 		bl	enableIRQ
 1915              	.LVL129:
1046:main.c        **** 		VICIntEnable |= 0x00000040;
 1916              		.loc 1 1046 0
 1917 0fb8 0030E0E3 		mvn	r3, #0
 1918 0fbc F32F13E5 		ldr	r2, [r3, #-4083]
 1919 0fc0 4020C2E3 		bic	r2, r2, #64
 1920 0fc4 F32F03E5 		str	r2, [r3, #-4083]
1047:main.c        **** 		VICVectCntl1 = 0x26;
 1921              		.loc 1 1047 0
 1922 0fc8 EF2F13E5 		ldr	r2, [r3, #-4079]
 1923 0fcc 402082E3 		orr	r2, r2, #64
 1924 0fd0 EF2F03E5 		str	r2, [r3, #-4079]
1048:main.c        **** 		VICVectAddr1 = (unsigned int)UART0ISR;
 1925              		.loc 1 1048 0
 1926 0fd4 2620A0E3 		mov	r2, #38
 1927 0fd8 FB2D03E5 		str	r2, [r3, #-3579]
1049:main.c        **** 		U0IER = 0x01;
 1928              		.loc 1 1049 0
 1929 0fdc 70209FE5 		ldr	r2, .L183+12
 1930 0fe0 FB2E03E5 		str	r2, [r3, #-3835]
 1931 0fe4 140000EA 		b	.L181
 1932              	.LVL130:
 1933              	.L177:
1052:main.c        **** 	{
 1934              		.loc 1 1052 0
 1935 0fe8 020054E3 		cmp	r4, #2
 1936 0fec 0D00001A 		bne	.L179
1054:main.c        **** 		VICIntSelect &= ~0x00000040;
 1937              		.loc 1 1054 0
 1938 0ff0 FEFFFFEB 		bl	enableIRQ
 1939              	.LVL131:
1055:main.c        **** 		VICIntEnable |= 0x00000040;
 1940              		.loc 1 1055 0
 1941 0ff4 0030E0E3 		mvn	r3, #0
 1942 0ff8 F32F13E5 		ldr	r2, [r3, #-4083]
 1943 0ffc 4020C2E3 		bic	r2, r2, #64
 1944 1000 F32F03E5 		str	r2, [r3, #-4083]
1056:main.c        **** 		VICVectCntl2 = 0x26;
 1945              		.loc 1 1056 0
 1946 1004 EF2F13E5 		ldr	r2, [r3, #-4079]
 1947 1008 402082E3 		orr	r2, r2, #64
 1948 100c EF2F03E5 		str	r2, [r3, #-4079]
1057:main.c        **** 		VICVectAddr2 = (unsigned int)UART0ISR_2;
 1949              		.loc 1 1057 0
 1950 1010 2620A0E3 		mov	r2, #38
 1951 1014 F72D03E5 		str	r2, [r3, #-3575]
1058:main.c        **** 		U0IER = 0X01;
 1952              		.loc 1 1058 0
 1953 1018 38209FE5 		ldr	r2, .L183+16
 1954 101c F72E03E5 		str	r2, [r3, #-3831]
1059:main.c        **** 	}
 1955              		.loc 1 1059 0
 1956 1020 0460C5E5 		strb	r6, [r5, #4]
 1957 1024 050000EA 		b	.L168
 1958              	.LVL132:
 1959              	.L179:
1061:main.c        **** 	{
 1960              		.loc 1 1061 0
 1961 1028 000054E3 		cmp	r4, #0
 1962 102c 0300001A 		bne	.L168
1063:main.c        **** 		U0IER = 0x00;
 1963              		.loc 1 1063 0
 1964 1030 4020A0E3 		mov	r2, #64
 1965 1034 0030E0E3 		mvn	r3, #0
 1966 1038 EB2F03E5 		str	r2, [r3, #-4075]
 1967              	.LVL133:
 1968              	.L181:
1064:main.c        **** 	}
 1969              		.loc 1 1064 0
 1970 103c 0440C5E5 		strb	r4, [r5, #4]
 1971              	.L168:
1066:main.c        **** 
 1972              		.loc 1 1066 0
 1973 1040 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1974 1044 1EFF2FE1 		bx	lr
 1975              	.L184:
 1976              		.align	2
 1977              	.L183:
 1978 1048 00000000 		.word	.LANCHOR1
 1979 104c 00C000E0 		.word	-536821760
 1980 1050 00C20100 		.word	115200
 1981 1054 00000000 		.word	UART0ISR
 1982 1058 00000000 		.word	UART0ISR_2
 1983              		.cfi_endproc
 1984              	.LFE9:
 1986              		.align	2
 1987              		.global	stat
 1989              	stat:
 1990              	.LFB10:
1069:main.c        **** 	if(statnum) // Stat 1
 1991              		.loc 1 1069 0
 1992              		.cfi_startproc
 1993              		@ Function supports interworking.
 1994              		@ args = 0, pretend = 0, frame = 0
 1995              		@ frame_needed = 0, uses_anonymous_args = 0
 1996              		@ link register save eliminated.
 1997              	.LVL134:
1070:main.c        **** 	{
 1998              		.loc 1 1070 0
 1999 105c 000050E3 		cmp	r0, #0
 2000 1060 20309FE5 		ldr	r3, .L193
 2001 1064 0200000A 		beq	.L186
 2002              	.LVL135:
 2003              	.LBB22:
 2004              	.LBB23:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 2005              		.loc 1 1072 0
 2006 1068 000051E3 		cmp	r1, #0
 2007 106c 022BA0E3 		mov	r2, #2048
 2008 1070 010000EA 		b	.L192
 2009              	.LVL136:
 2010              	.L186:
 2011              	.LBE23:
 2012              	.LBE22:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 2013              		.loc 1 1077 0
 2014 1074 000051E3 		cmp	r1, #0
 2015 1078 0420A0E3 		mov	r2, #4
 2016              	.L192:
 2017 107c 0C208315 		strne	r2, [r3, #12]
 2018              		.loc 1 1078 0
 2019 1080 04208305 		streq	r2, [r3, #4]
 2020 1084 1EFF2FE1 		bx	lr
 2021              	.L194:
 2022              		.align	2
 2023              	.L193:
 2024 1088 008002E0 		.word	-536707072
 2025              		.cfi_endproc
 2026              	.LFE10:
 2028              		.align	2
 2029              		.global	AD_conversion
 2031              	AD_conversion:
 2032              	.LFB17:
1079:main.c        **** 	}
1080:main.c        **** }
1081:main.c        **** 
1082:main.c        **** void Log_init(void)
1083:main.c        **** {
1084:main.c        **** 	int x, mark = 0, ind = 0;
1085:main.c        **** 	char temp, temp2 = 0, safety = 0;
1086:main.c        **** //	signed char handle;
1087:main.c        **** 
1088:main.c        **** 	if(root_file_exists("LOGCON.txt"))
1089:main.c        **** 	{
1090:main.c        **** 		//rprintf("\n\rFound LOGcon.txt\n");
1091:main.c        **** 		fd = root_open("LOGCON.txt");
1092:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
1093:main.c        **** 		stringBuf[stringSize] = '\0';
1094:main.c        **** 		fat_close_file(fd);
1095:main.c        **** 	}
1096:main.c        **** 	else
1097:main.c        **** 	{
1098:main.c        **** 		//rprintf("Couldn't find LOGcon.txt, creating...\n");
1099:main.c        **** 		fd = root_open_new("LOGCON.txt");
1100:main.c        **** 		if(fd == NULL)
1101:main.c        **** 		{
1102:main.c        **** 		 	rprintf("Error creating LOGCON.txt, locking up...\n\r");
1103:main.c        **** 		 	while(1)
1104:main.c        **** 			{
1105:main.c        **** 				stat(0,ON);
1106:main.c        **** 				delay_ms(50);
1107:main.c        **** 				stat(0,OFF);
1108:main.c        **** 				stat(1,ON);
1109:main.c        **** 				delay_ms(50);
1110:main.c        **** 				stat(1,OFF);
1111:main.c        **** 			}
1112:main.c        **** 		}
1113:main.c        **** 
1114:main.c        **** 		strcpy(stringBuf, "MODE = 0\r\nASCII = N\r\nBaud = 4\r\nFrequency = 100\r\nTrigger Character = $\
1115:main.c        **** 		stringSize = strlen(stringBuf);
1116:main.c        **** 		fat_write_file(fd, (unsigned char*)stringBuf, stringSize);
1117:main.c        **** 		sd_raw_sync();
1118:main.c        **** 	}
1119:main.c        **** 
1120:main.c        **** 	for(x = 0; x < stringSize; x++)
1121:main.c        **** 	{
1122:main.c        **** 		temp = stringBuf[x];
1123:main.c        **** 		if(temp == 10)
1124:main.c        **** 		{
1125:main.c        **** 			mark = x;
1126:main.c        **** 			ind++;
1127:main.c        **** 			if(ind == 1)
1128:main.c        **** 			{
1129:main.c        **** 				mode = stringBuf[mark-2]-48; // 0 = auto uart, 1 = trigger uart, 2 = adc
1130:main.c        **** 				rprintf("mode = %d\n\r",mode);
1131:main.c        **** 			}
1132:main.c        **** 			else if(ind == 2)
1133:main.c        **** 			{
1134:main.c        **** 				asc = stringBuf[mark-2]; // default is 'N'
1135:main.c        **** 				rprintf("asc = %c\n\r",asc);
1136:main.c        **** 			}
1137:main.c        **** 			else if(ind == 3)
1138:main.c        **** 			{
1139:main.c        **** 				if(stringBuf[mark-2] == '1'){ baud = 1200; }
1140:main.c        **** 				else if(stringBuf[mark-2] == '2'){ baud = 2400; }
1141:main.c        **** 				else if(stringBuf[mark-2] == '3'){ baud = 4800; }
1142:main.c        **** 				else if(stringBuf[mark-2] == '4'){ baud = 9600; }
1143:main.c        **** 				else if(stringBuf[mark-2] == '5'){ baud = 19200; }
1144:main.c        **** 				else if(stringBuf[mark-2] == '6'){ baud = 38400; }
1145:main.c        **** 				else if(stringBuf[mark-2] == '7'){ baud = 57600; }
1146:main.c        **** 				else if(stringBuf[mark-2] == '8'){ baud = 115200; }
1147:main.c        **** 
1148:main.c        **** 				rprintf("baud = %d\n\r",baud);
1149:main.c        **** 			}
1150:main.c        **** 			else if(ind == 4)
1151:main.c        **** 			{
1152:main.c        **** 				freq = (stringBuf[mark-2]-48) + (stringBuf[mark-3]-48) * 10;
1153:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
1154:main.c        **** 				{
1155:main.c        **** 					freq+= (stringBuf[mark-4]-48) * 100;
1156:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
1157:main.c        **** 				}
1158:main.c        **** 				rprintf("freq = %d\n\r",freq);
1159:main.c        **** 			}
1160:main.c        **** 			else if(ind == 5)
1161:main.c        **** 			{
1162:main.c        **** 				trig = stringBuf[mark-2]; // default is $
1163:main.c        **** 				
1164:main.c        **** 				rprintf("trig = %c\n\r",trig);
1165:main.c        **** 			}
1166:main.c        **** 			else if(ind == 6)
1167:main.c        **** 			{
1168:main.c        **** 				frame = (stringBuf[mark-2]-48) + (stringBuf[mark-3]-48) * 10 + (stringBuf[mark-4]-48)*100;
1169:main.c        **** 				if(frame > 510){ frame = 510; } // up to 510 characters
1170:main.c        **** 				rprintf("frame = %d\n\r",frame);
1171:main.c        **** 			}
1172:main.c        **** 			else if(ind == 7)
1173:main.c        **** 			{
1174:main.c        **** 				ad1_3 = stringBuf[mark-2]; // default is 'N'
1175:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
1176:main.c        **** 				rprintf("ad1_3 = %c\n\r",ad1_3);
1177:main.c        **** 			}
1178:main.c        **** 			else if(ind == 8)
1179:main.c        **** 			{
1180:main.c        **** 				ad0_3 = stringBuf[mark-2]; // default is 'N'
1181:main.c        **** 				if(ad0_3 == 'Y'){ temp2++; }
1182:main.c        **** 				rprintf("ad0_3 = %c\n\r",ad0_3);
1183:main.c        **** 			}
1184:main.c        **** 			else if(ind == 9)
1185:main.c        **** 			{
1186:main.c        **** 				ad0_2 = stringBuf[mark-2]; // default is 'N'
1187:main.c        **** 				if(ad0_2 == 'Y'){ temp2++; }
1188:main.c        **** 				rprintf("ad0_2 = %c\n\r",ad0_2);
1189:main.c        **** 			}
1190:main.c        **** 			else if(ind == 10)
1191:main.c        **** 			{
1192:main.c        **** 				ad0_1 = stringBuf[mark-2]; // default is 'N'
1193:main.c        **** 				if(ad0_1 == 'Y'){ temp2++; }
1194:main.c        **** 				rprintf("ad0_1 = %c\n\r",ad0_1);
1195:main.c        **** 			}
1196:main.c        **** 			else if(ind == 11)
1197:main.c        **** 			{
1198:main.c        **** 				ad1_2 = stringBuf[mark-2]; // default is 'N'
1199:main.c        **** 				if(ad1_2 == 'Y'){ temp2++; }
1200:main.c        **** 				rprintf("ad1_2 = %c\n\r",ad1_2);
1201:main.c        **** 			}
1202:main.c        **** 			else if(ind == 12)
1203:main.c        **** 			{
1204:main.c        **** 				ad0_4 = stringBuf[mark-2]; // default is 'N'
1205:main.c        **** 				if(ad0_4 == 'Y'){ temp2++; }
1206:main.c        **** 				rprintf("ad0_4 = %c\n\r",ad0_4);
1207:main.c        **** 			}
1208:main.c        **** 			else if(ind == 13)
1209:main.c        **** 			{
1210:main.c        **** 				ad1_7 = stringBuf[mark-2]; // default is 'N'
1211:main.c        **** 				if(ad1_7 == 'Y'){ temp2++; }
1212:main.c        **** 				rprintf("ad1_7 = %c\n\r",ad1_7);
1213:main.c        **** 			}
1214:main.c        **** 			else if(ind == 14)
1215:main.c        **** 			{
1216:main.c        **** 				ad1_6 = stringBuf[mark-2]; // default is 'N'
1217:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
1218:main.c        **** 				rprintf("ad1_6 = %c\n\r",ad1_6);
1219:main.c        **** 			}
1220:main.c        **** 			else if(ind == 15)
1221:main.c        **** 			{
1222:main.c        **** 				safety = stringBuf[mark-2]; // default is 'Y'
1223:main.c        **** 				rprintf("safety = %c\n\r",safety);
1224:main.c        **** 			}
1225:main.c        **** 		}
1226:main.c        **** 	}
1227:main.c        **** 
1228:main.c        **** 	if(safety == 'Y')
1229:main.c        **** 	{
1230:main.c        **** 		if((temp2 ==10) && (freq > 150)){ freq = 150; }
1231:main.c        **** 		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
1232:main.c        **** 		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
1233:main.c        **** 		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
1234:main.c        **** 		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
1235:main.c        **** 		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
1236:main.c        **** 		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
1237:main.c        **** 		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
1238:main.c        **** 		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
1239:main.c        **** 		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
1240:main.c        **** 		else if((temp2 == 0)){ freq = 100; }
1241:main.c        **** 	}
1242:main.c        **** 	
1243:main.c        **** 	if(safety == 'T'){ test(); }
1244:main.c        **** 
1245:main.c        **** }
1246:main.c        **** 
1247:main.c        **** /***********************************************
1248:main.c        **** * Automatic UART mode
1249:main.c        **** * Each time the UART interrupt is triggered the
1250:main.c        **** * arriving character is read and added to the
1251:main.c        **** * data buffer
1252:main.c        **** ************************************************/
1253:main.c        **** void mode_0(void) // Auto UART mode
1254:main.c        **** {
1255:main.c        **** 	rprintf("MODE 0\n\r");
1256:main.c        **** 	setup_uart0(baud,1);
1257:main.c        **** 	stringSize = 512;
1258:main.c        **** 	mode_action();
1259:main.c        **** 	//rprintf("Exit mode 0\n\r");
1260:main.c        **** 
1261:main.c        **** }
1262:main.c        **** 
1263:main.c        **** /**********************************************
1264:main.c        **** * Triggered UART mode
1265:main.c        **** * Trigger is '$'
1266:main.c        **** * Logs '$' and next 99 characters or until CR/LF
1267:main.c        **** *
1268:main.c        **** ***********************************************/
1269:main.c        **** void mode_1(void)
1270:main.c        **** {
1271:main.c        **** 	rprintf("MODE 1\n\r");	
1272:main.c        **** 
1273:main.c        **** 	setup_uart0(baud,2);
1274:main.c        **** 	stringSize = frame + 2;
1275:main.c        **** 
1276:main.c        **** 	mode_action();
1277:main.c        **** }
1278:main.c        **** 
1279:main.c        **** /***************************************************
1280:main.c        **** * Timer Interrupt triggered ADC read mode
1281:main.c        **** * 'Frequency' for LOGCON.TXT determines frequency
1282:main.c        **** * 100 is roughly 1 trigger per second
1283:main.c        **** ***************************************************/
1284:main.c        **** void mode_2(void)
1285:main.c        **** {
1286:main.c        **** 	rprintf("MODE 2\n\r");	
1287:main.c        **** 	enableIRQ();
1288:main.c        **** 	// Timer0  interrupt is an IRQ interrupt
1289:main.c        **** 	VICIntSelect &= ~0x00000010;
1290:main.c        **** 	// Enable Timer0 interrupt
1291:main.c        **** 	VICIntEnable |= 0x00000010;
1292:main.c        **** 	// Use slot 2 for UART0 interrupt
1293:main.c        **** 	VICVectCntl2 = 0x24;
1294:main.c        **** 	// Set the address of ISR for slot 1
1295:main.c        **** 	VICVectAddr2 = (unsigned int)MODE2ISR;
1296:main.c        **** 
1297:main.c        **** 	T0TCR = 0x00000002;	// Reset counter and prescaler
1298:main.c        **** 	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
1299:main.c        **** 	T0MR0 = 58982400 / freq;
1300:main.c        **** 
1301:main.c        **** 	T0PR = 0x00000000;
1302:main.c        **** 
1303:main.c        **** 	T0TCR = 0x00000001; // enable timer
1304:main.c        **** 
1305:main.c        **** 	stringSize = 512;
1306:main.c        **** 	mode_action();
1307:main.c        **** }
1308:main.c        **** 
1309:main.c        **** /********************************************************
1310:main.c        **** * All of the non-Interrupt driven work, after initial
1311:main.c        **** * configuration, going on here.
1312:main.c        **** * Control is passed here after mode (0-2 above) related
1313:main.c        **** * initialization has occurred. Program execution, other
1314:main.c        **** * than Interrupt driven code, never leaves here. This 
1315:main.c        **** * function just writes to the microSD when the buffers 
1316:main.c        **** * are full. It also checks to make sure the 'stop'
1317:main.c        **** * button hasn't been pressed which writes all buffers
1318:main.c        **** * to the microSD, lights the STAT0 & STAT1 LEDs,
1319:main.c        **** * and then is locked into an endless loop.
1320:main.c        **** ********************************************************/
1321:main.c        **** void mode_action(void)
1322:main.c        **** {
1323:main.c        **** 	int j;
1324:main.c        **** 
1325:main.c        **** 	while(1)
1326:main.c        **** 	{
1327:main.c        **** 		// if the first data buffer is full, write it to the microSD
1328:main.c        **** 		if(log_array1 == 1)
1329:main.c        **** 		{
1330:main.c        **** 			stat(0,ON);
1331:main.c        **** 				
1332:main.c        **** 			if(fat_write_file(handle,(unsigned char *)RX_array1, stringSize) < 0)
1333:main.c        **** 			{
1334:main.c        **** 				while(1)
1335:main.c        **** 				{
1336:main.c        **** 					stat(0,ON);
1337:main.c        **** 					for(j = 0; j < 500000; j++)
1338:main.c        **** 					stat(0,OFF);
1339:main.c        **** 					stat(1,ON);
1340:main.c        **** 					for(j = 0; j < 500000; j++)
1341:main.c        **** 					stat(1,OFF);
1342:main.c        **** 				}
1343:main.c        **** 			}
1344:main.c        **** 			
1345:main.c        **** 			sd_raw_sync();
1346:main.c        **** 			stat(0,OFF);
1347:main.c        **** 			log_array1 = 0;
1348:main.c        **** 		}
1349:main.c        **** 
1350:main.c        **** 		// if the second data buffer is full, write it to the microSD
1351:main.c        **** 		if(log_array2 == 1)
1352:main.c        **** 		{
1353:main.c        **** 			stat(1,ON);
1354:main.c        **** 			
1355:main.c        **** 			if(fat_write_file(handle,(unsigned char *)RX_array2, stringSize) < 0)
1356:main.c        **** 			{
1357:main.c        **** 				while(1)
1358:main.c        **** 				{
1359:main.c        **** 					stat(0,ON);
1360:main.c        **** 					for(j = 0; j < 500000; j++)
1361:main.c        **** 					stat(0,OFF);
1362:main.c        **** 					stat(1,ON);
1363:main.c        **** 					for(j = 0; j < 500000; j++)
1364:main.c        **** 					stat(1,OFF);
1365:main.c        **** 				}
1366:main.c        **** 			}
1367:main.c        **** 			
1368:main.c        **** 			sd_raw_sync();
1369:main.c        **** 			stat(1,OFF);
1370:main.c        **** 			log_array2 = 0;
1371:main.c        **** 			LogADC();
1372:main.c        **** 		}
1373:main.c        **** 		
1374:main.c        **** 		// see if ADC data needs to be logged
1375:main.c        **** 		if(log_adc == 1)
1376:main.c        **** 		{
1377:main.c        **** 			stat(0,ON);
1378:main.c        **** 			
1379:main.c        **** 			if(fat_write_file(handle,(unsigned char *)ADC_array,ADCStringSize) < 0)
1380:main.c        **** 			{
1381:main.c        **** 				while(1)
1382:main.c        **** 				{
1383:main.c        **** 					stat(0,ON);
1384:main.c        **** 					for(j = 0; j < 500000; j++)
1385:main.c        **** 					stat(0,OFF);
1386:main.c        **** 					stat(1,ON);
1387:main.c        **** 					for(j = 0; j < 500000; j++)
1388:main.c        **** 					stat(1,OFF);
1389:main.c        **** 				}
1390:main.c        **** 			}
1391:main.c        **** 			sd_raw_sync();
1392:main.c        **** 			stat(0,OFF);
1393:main.c        **** 			log_adc = 0;
1394:main.c        **** 		}
1395:main.c        **** 
1396:main.c        **** 		// if the 'stop' button has been pressed then write everything to
1397:main.c        **** 		// the microSD, turn on the STAT0 & STAT1 LEDs, and lock up
1398:main.c        **** 		if((IOPIN0 & 0x00000008) == 0)
1399:main.c        **** 		{
1400:main.c        **** 			VICIntEnClr = 0xFFFFFFFF;
1401:main.c        **** 			// write whatever is left in the data buffer to the microSD
1402:main.c        **** 			if(RX_in < 512)
1403:main.c        **** 			{
1404:main.c        **** 				fat_write_file(handle, (unsigned char *)RX_array1, RX_in);
1405:main.c        **** 				sd_raw_sync();
1406:main.c        **** 			}
1407:main.c        **** 			else if(RX_in >= 512)
1408:main.c        **** 			{
1409:main.c        **** 				fat_write_file(handle, (unsigned char *)RX_array2, RX_in - 512);
1410:main.c        **** 				sd_raw_sync();
1411:main.c        **** 			}
1412:main.c        **** 			// turn on STAT0 & STAT1 and lock up in endless loop
1413:main.c        **** 			while(1)
1414:main.c        **** 			{
1415:main.c        **** 				stat(0,ON);
1416:main.c        **** 				for(j = 0; j < 500000; j++);
1417:main.c        **** 				stat(0,OFF);
1418:main.c        **** 				stat(1,ON);
1419:main.c        **** 				for(j = 0; j < 500000; j++);
1420:main.c        **** 				stat(1,OFF);
1421:main.c        **** 			}
1422:main.c        **** 		}
1423:main.c        **** 	}
1424:main.c        **** 
1425:main.c        **** }
1426:main.c        **** 
1427:main.c        **** void test(void)
1428:main.c        **** {
1429:main.c        **** 
1430:main.c        **** 	rprintf("\n\rLogomatic V2 Test Code:\n\r");
1431:main.c        **** 	rprintf("ADC Test will begin in 5 seconds, hit stop button to terminate the test.\r\n\n");
1432:main.c        **** 
1433:main.c        **** 	delay_ms(5000);
1434:main.c        **** 
1435:main.c        **** 	while((IOPIN0 & 0x00000008) == 0x00000008)
1436:main.c        **** 	{
1437:main.c        **** 		// Get AD1.3
1438:main.c        **** 		AD1CR = 0x0020FF08;
1439:main.c        **** 		AD_conversion(1);
1440:main.c        **** 
1441:main.c        **** 		// Get AD0.3
1442:main.c        **** 		AD0CR = 0x0020FF08;
1443:main.c        **** 		AD_conversion(0);
1444:main.c        **** 		
1445:main.c        **** 		// Get AD0.2
1446:main.c        **** 		AD0CR = 0x0020FF04;
1447:main.c        **** 		AD_conversion(0);
1448:main.c        **** 
1449:main.c        **** 		// Get AD0.1
1450:main.c        **** 		AD0CR = 0x0020FF02;
1451:main.c        **** 		AD_conversion(0);
1452:main.c        **** 
1453:main.c        **** 		// Get AD1.2
1454:main.c        **** 		AD1CR = 0x0020FF04;
1455:main.c        **** 		AD_conversion(1);
1456:main.c        **** 		
1457:main.c        **** 		// Get AD0.4
1458:main.c        **** 		AD0CR = 0x0020FF10;
1459:main.c        **** 		AD_conversion(0);
1460:main.c        **** 
1461:main.c        **** 		// Get AD1.7
1462:main.c        **** 		AD1CR = 0x0020FF80;
1463:main.c        **** 		AD_conversion(1);
1464:main.c        **** 
1465:main.c        **** 		// Get AD1.6
1466:main.c        **** 		AD1CR = 0x0020FF40;
1467:main.c        **** 		AD_conversion(1);
1468:main.c        **** 
1469:main.c        **** 		delay_ms(1000);
1470:main.c        **** 		rprintf("\n\r");
1471:main.c        **** 	}
1472:main.c        **** 
1473:main.c        **** 	rprintf("\n\rTest complete, locking up...\n\r");
1474:main.c        **** 	while(1);
1475:main.c        **** 		
1476:main.c        **** }
1477:main.c        **** 
1478:main.c        **** void AD_conversion(int regbank)
1479:main.c        **** {
 2033              		.loc 1 1479 0
 2034              		.cfi_startproc
 2035              		@ Function supports interworking.
 2036              		@ args = 0, pretend = 0, frame = 0
 2037              		@ frame_needed = 0, uses_anonymous_args = 0
 2038              	.LVL137:
1480:main.c        **** 	int temp = 0, temp2;
1481:main.c        **** 
1482:main.c        **** 	if(!regbank) // bank 0
 2039              		.loc 1 1482 0
 2040 108c 000050E3 		cmp	r0, #0
1479:main.c        **** 	int temp = 0, temp2;
 2041              		.loc 1 1479 0
 2042 1090 04E02DE5 		str	lr, [sp, #-4]!
 2043              	.LCFI7:
 2044              		.cfi_def_cfa_offset 4
 2045              		.cfi_offset 14, -4
 2046              		.loc 1 1482 0
 2047 1094 0C00001A 		bne	.L196
1483:main.c        **** 	{
1484:main.c        **** 		AD0CR |= 0x01000000; // start conversion
 2048              		.loc 1 1484 0
 2049 1098 78309FE5 		ldr	r3, .L203
 2050 109c 002093E5 		ldr	r2, [r3, #0]
 2051 10a0 012482E3 		orr	r2, r2, #16777216
 2052 10a4 002083E5 		str	r2, [r3, #0]
 2053              	.LVL138:
 2054              	.L197:
1485:main.c        **** 		while((temp & 0x80000000) == 0)
1486:main.c        **** 		{
1487:main.c        **** 			temp = AD0DR;
 2055              		.loc 1 1487 0
 2056 10a8 042093E5 		ldr	r2, [r3, #4]
 2057              	.LVL139:
1485:main.c        **** 		while((temp & 0x80000000) == 0)
 2058              		.loc 1 1485 0
 2059 10ac 000052E3 		cmp	r2, #0
 2060 10b0 FCFFFFAA 		bge	.L197
 2061              	.LVL140:
1488:main.c        **** 		}
1489:main.c        **** 		temp &= 0x0000FFC0;
 2062              		.loc 1 1489 0
 2063 10b4 60109FE5 		ldr	r1, .L203+4
 2064 10b8 011002E0 		and	r1, r2, r1
 2065              	.LVL141:
1490:main.c        **** 		temp2 = temp / 0x00000040;
 2066              		.loc 1 1490 0
 2067 10bc 4113A0E1 		mov	r1, r1, asr #6
 2068              	.LVL142:
1491:main.c        **** 
1492:main.c        **** 		AD0CR = 0x00000000;
 2069              		.loc 1 1492 0
 2070 10c0 0020A0E3 		mov	r2, #0
 2071              	.LVL143:
 2072 10c4 4C309FE5 		ldr	r3, .L203
 2073 10c8 0B0000EA 		b	.L202
 2074              	.LVL144:
 2075              	.L196:
1493:main.c        **** 	}
1494:main.c        **** 	else	    // bank 1
1495:main.c        **** 	{
1496:main.c        **** 		AD1CR |= 0x01000000; // start conversion
 2076              		.loc 1 1496 0
 2077 10cc 4C309FE5 		ldr	r3, .L203+8
 2078 10d0 002093E5 		ldr	r2, [r3, #0]
 2079 10d4 012482E3 		orr	r2, r2, #16777216
 2080 10d8 002083E5 		str	r2, [r3, #0]
 2081              	.LVL145:
 2082              	.L199:
1497:main.c        **** 		while((temp & 0x80000000) == 0)
1498:main.c        **** 		{
1499:main.c        **** 			temp = AD1DR;
 2083              		.loc 1 1499 0
 2084 10dc 042093E5 		ldr	r2, [r3, #4]
 2085              	.LVL146:
1497:main.c        **** 		while((temp & 0x80000000) == 0)
 2086              		.loc 1 1497 0
 2087 10e0 000052E3 		cmp	r2, #0
 2088 10e4 FCFFFFAA 		bge	.L199
 2089              	.LVL147:
1500:main.c        **** 		}
1501:main.c        **** 		temp &= 0x0000FFC0;
 2090              		.loc 1 1501 0
 2091 10e8 2C109FE5 		ldr	r1, .L203+4
1502:main.c        **** 		temp2 = temp / 0x00000040;
1503:main.c        **** 
1504:main.c        **** 		AD1CR = 0x00000000;
 2092              		.loc 1 1504 0
 2093 10ec 2C309FE5 		ldr	r3, .L203+8
1501:main.c        **** 		temp2 = temp / 0x00000040;
 2094              		.loc 1 1501 0
 2095 10f0 011002E0 		and	r1, r2, r1
 2096              	.LVL148:
1502:main.c        **** 		temp2 = temp / 0x00000040;
 2097              		.loc 1 1502 0
 2098 10f4 4113A0E1 		mov	r1, r1, asr #6
 2099              	.LVL149:
 2100              		.loc 1 1504 0
 2101 10f8 0020A0E3 		mov	r2, #0
 2102              	.LVL150:
 2103              	.L202:
 2104 10fc 002083E5 		str	r2, [r3, #0]
1505:main.c        **** 	}
1506:main.c        **** 
1507:main.c        **** 	rprintf("%d", temp2);
 2105              		.loc 1 1507 0
 2106 1100 1C009FE5 		ldr	r0, .L203+12
 2107              	.LVL151:
 2108 1104 FEFFFFEB 		bl	rprintf
 2109              	.LVL152:
1508:main.c        **** 	rprintf("   ");
 2110              		.loc 1 1508 0
 2111 1108 18009FE5 		ldr	r0, .L203+16
 2112 110c FEFFFFEB 		bl	rprintf
 2113              	.LVL153:
1509:main.c        **** 	
1510:main.c        **** }
 2114              		.loc 1 1510 0
 2115 1110 04E09DE4 		ldr	lr, [sp], #4
 2116 1114 1EFF2FE1 		bx	lr
 2117              	.L204:
 2118              		.align	2
 2119              	.L203:
 2120 1118 004003E0 		.word	-536657920
 2121 111c C0FF0000 		.word	65472
 2122 1120 000006E0 		.word	-536477696
 2123 1124 00000000 		.word	.LC0
 2124 1128 03000000 		.word	.LC1
 2125              		.cfi_endproc
 2126              	.LFE17:
 2128              		.align	2
 2129              		.global	fat_initialize
 2131              	fat_initialize:
 2132              	.LFB18:
1511:main.c        **** 
1512:main.c        **** void fat_initialize(void)
1513:main.c        **** {
 2133              		.loc 1 1513 0
 2134              		.cfi_startproc
 2135              		@ Function supports interworking.
 2136              		@ args = 0, pretend = 0, frame = 0
 2137              		@ frame_needed = 0, uses_anonymous_args = 0
 2138 112c 04E02DE5 		str	lr, [sp, #-4]!
 2139              	.LCFI8:
 2140              		.cfi_def_cfa_offset 4
 2141              		.cfi_offset 14, -4
1514:main.c        **** 	if(!sd_raw_init())
 2142              		.loc 1 1514 0
 2143 1130 FEFFFFEB 		bl	sd_raw_init
 2144              	.LVL154:
 2145 1134 000050E3 		cmp	r0, #0
 2146 1138 0200001A 		bne	.L206
1515:main.c        **** 	{
1516:main.c        **** 		rprintf("SD Init Error\n\r");
 2147              		.loc 1 1516 0
 2148 113c 1C009FE5 		ldr	r0, .L212
 2149 1140 FEFFFFEB 		bl	rprintf
 2150              	.LVL155:
 2151              	.L207:
 2152 1144 FEFFFFEA 		b	.L207
 2153              	.L206:
1517:main.c        **** 		while(1);
1518:main.c        **** 	}
1519:main.c        **** 
1520:main.c        **** 	if(openroot())
 2154              		.loc 1 1520 0
 2155 1148 FEFFFFEB 		bl	openroot
 2156              	.LVL156:
 2157 114c 000050E3 		cmp	r0, #0
1521:main.c        **** 	{ 
1522:main.c        **** 		rprintf("SD OpenRoot Error\n\r");
 2158              		.loc 1 1522 0
 2159 1150 0C009F15 		ldrne	r0, .L212+4
 2160 1154 FEFFFF1B 		blne	rprintf
 2161              	.LVL157:
 2162              	.L205:
1523:main.c        **** 	}
1524:main.c        **** }
 2163              		.loc 1 1524 0
 2164 1158 04E09DE4 		ldr	lr, [sp], #4
 2165 115c 1EFF2FE1 		bx	lr
 2166              	.L213:
 2167              		.align	2
 2168              	.L212:
 2169 1160 07000000 		.word	.LC2
 2170 1164 17000000 		.word	.LC3
 2171              		.cfi_endproc
 2172              	.LFE18:
 2174              		.align	2
 2175              		.global	delay_ms
 2177              	delay_ms:
 2178              	.LFB19:
1525:main.c        **** 
1526:main.c        **** void delay_ms(int count)
1527:main.c        **** {
 2179              		.loc 1 1527 0
 2180              		.cfi_startproc
 2181              		@ Function supports interworking.
 2182              		@ args = 0, pretend = 0, frame = 0
 2183              		@ frame_needed = 0, uses_anonymous_args = 0
 2184              		@ link register save eliminated.
 2185              	.LVL158:
1528:main.c        **** 	int i;
1529:main.c        **** 	count *= 10000;
 2186              		.loc 1 1529 0
 2187 1168 1C309FE5 		ldr	r3, .L217
 2188 116c 930000E0 		mul	r0, r3, r0
 2189              	.LVL159:
1530:main.c        **** 	for(i = 0; i < count; i++)
 2190              		.loc 1 1530 0
 2191 1170 0030A0E3 		mov	r3, #0
 2192 1174 010000EA 		b	.L215
 2193              	.LVL160:
 2194              	.L216:
1531:main.c        **** 		asm volatile ("nop");
 2195              		.loc 1 1531 0 discriminator 2
 2196              	@ 1531 "main.c" 1
 2197 1178 0000A0E1 		nop
 2198              	@ 0 "" 2
1530:main.c        **** 	for(i = 0; i < count; i++)
 2199              		.loc 1 1530 0 discriminator 2
 2200 117c 013083E2 		add	r3, r3, #1
 2201              	.LVL161:
 2202              	.L215:
1530:main.c        **** 	for(i = 0; i < count; i++)
 2203              		.loc 1 1530 0 is_stmt 0 discriminator 1
 2204 1180 000053E1 		cmp	r3, r0
 2205 1184 FBFFFFBA 		blt	.L216
1532:main.c        **** }
 2206              		.loc 1 1532 0 is_stmt 1
 2207 1188 1EFF2FE1 		bx	lr
 2208              	.L218:
 2209              		.align	2
 2210              	.L217:
 2211 118c 10270000 		.word	10000
 2212              		.cfi_endproc
 2213              	.LFE19:
 2215              		.align	2
 2216              		.global	test
 2218              	test:
 2219              	.LFB16:
1428:main.c        **** 
 2220              		.loc 1 1428 0
 2221              		.cfi_startproc
 2222              		@ Function supports interworking.
 2223              		@ args = 0, pretend = 0, frame = 0
 2224              		@ frame_needed = 0, uses_anonymous_args = 0
 2225 1190 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 2226              	.LCFI9:
 2227              		.cfi_def_cfa_offset 24
 2228              		.cfi_offset 4, -24
 2229              		.cfi_offset 5, -20
 2230              		.cfi_offset 6, -16
 2231              		.cfi_offset 7, -12
 2232              		.cfi_offset 8, -8
 2233              		.cfi_offset 14, -4
1430:main.c        **** 	rprintf("ADC Test will begin in 5 seconds, hit stop button to terminate the test.\r\n\n");
 2234              		.loc 1 1430 0
 2235 1194 C0009FE5 		ldr	r0, .L223
 2236 1198 FEFFFFEB 		bl	rprintf
 2237              	.LVL162:
1431:main.c        **** 
 2238              		.loc 1 1431 0
 2239 119c BC009FE5 		ldr	r0, .L223+4
 2240 11a0 FEFFFFEB 		bl	rprintf
 2241              	.LVL163:
1433:main.c        **** 
 2242              		.loc 1 1433 0
 2243 11a4 B8009FE5 		ldr	r0, .L223+8
 2244 11a8 FEFFFFEB 		bl	delay_ms
 2245              	.LVL164:
1435:main.c        **** 	{
 2246              		.loc 1 1435 0
 2247 11ac B4809FE5 		ldr	r8, .L223+12
1438:main.c        **** 		AD_conversion(1);
 2248              		.loc 1 1438 0
 2249 11b0 B4409FE5 		ldr	r4, .L223+16
 2250 11b4 B4609FE5 		ldr	r6, .L223+20
1435:main.c        **** 	{
 2251              		.loc 1 1435 0
 2252 11b8 210000EA 		b	.L220
 2253              	.L221:
1442:main.c        **** 		AD_conversion(0);
 2254              		.loc 1 1442 0
 2255 11bc B0509FE5 		ldr	r5, .L223+24
1439:main.c        **** 
 2256              		.loc 1 1439 0
 2257 11c0 0100A0E3 		mov	r0, #1
1446:main.c        **** 		AD_conversion(0);
 2258              		.loc 1 1446 0
 2259 11c4 AC709FE5 		ldr	r7, .L223+28
1438:main.c        **** 		AD_conversion(1);
 2260              		.loc 1 1438 0
 2261 11c8 006084E5 		str	r6, [r4, #0]
1439:main.c        **** 
 2262              		.loc 1 1439 0
 2263 11cc FEFFFFEB 		bl	AD_conversion
 2264              	.LVL165:
1443:main.c        **** 		
 2265              		.loc 1 1443 0
 2266 11d0 0000A0E3 		mov	r0, #0
1442:main.c        **** 		AD_conversion(0);
 2267              		.loc 1 1442 0
 2268 11d4 006085E5 		str	r6, [r5, #0]
1443:main.c        **** 		
 2269              		.loc 1 1443 0
 2270 11d8 FEFFFFEB 		bl	AD_conversion
 2271              	.LVL166:
1447:main.c        **** 
 2272              		.loc 1 1447 0
 2273 11dc 0000A0E3 		mov	r0, #0
1446:main.c        **** 		AD_conversion(0);
 2274              		.loc 1 1446 0
 2275 11e0 007085E5 		str	r7, [r5, #0]
1447:main.c        **** 
 2276              		.loc 1 1447 0
 2277 11e4 FEFFFFEB 		bl	AD_conversion
 2278              	.LVL167:
1450:main.c        **** 		AD_conversion(0);
 2279              		.loc 1 1450 0
 2280 11e8 8C309FE5 		ldr	r3, .L223+32
1451:main.c        **** 
 2281              		.loc 1 1451 0
 2282 11ec 0000A0E3 		mov	r0, #0
1450:main.c        **** 		AD_conversion(0);
 2283              		.loc 1 1450 0
 2284 11f0 003085E5 		str	r3, [r5, #0]
1451:main.c        **** 
 2285              		.loc 1 1451 0
 2286 11f4 FEFFFFEB 		bl	AD_conversion
 2287              	.LVL168:
1455:main.c        **** 		
 2288              		.loc 1 1455 0
 2289 11f8 0100A0E3 		mov	r0, #1
1454:main.c        **** 		AD_conversion(1);
 2290              		.loc 1 1454 0
 2291 11fc 007084E5 		str	r7, [r4, #0]
1455:main.c        **** 		
 2292              		.loc 1 1455 0
 2293 1200 FEFFFFEB 		bl	AD_conversion
 2294              	.LVL169:
1458:main.c        **** 		AD_conversion(0);
 2295              		.loc 1 1458 0
 2296 1204 74309FE5 		ldr	r3, .L223+36
1459:main.c        **** 
 2297              		.loc 1 1459 0
 2298 1208 0000A0E3 		mov	r0, #0
1458:main.c        **** 		AD_conversion(0);
 2299              		.loc 1 1458 0
 2300 120c 003085E5 		str	r3, [r5, #0]
1459:main.c        **** 
 2301              		.loc 1 1459 0
 2302 1210 FEFFFFEB 		bl	AD_conversion
 2303              	.LVL170:
1462:main.c        **** 		AD_conversion(1);
 2304              		.loc 1 1462 0
 2305 1214 68309FE5 		ldr	r3, .L223+40
1463:main.c        **** 
 2306              		.loc 1 1463 0
 2307 1218 0100A0E3 		mov	r0, #1
1462:main.c        **** 		AD_conversion(1);
 2308              		.loc 1 1462 0
 2309 121c 003084E5 		str	r3, [r4, #0]
1463:main.c        **** 
 2310              		.loc 1 1463 0
 2311 1220 FEFFFFEB 		bl	AD_conversion
 2312              	.LVL171:
1466:main.c        **** 		AD_conversion(1);
 2313              		.loc 1 1466 0
 2314 1224 5C309FE5 		ldr	r3, .L223+44
1467:main.c        **** 
 2315              		.loc 1 1467 0
 2316 1228 0100A0E3 		mov	r0, #1
1466:main.c        **** 		AD_conversion(1);
 2317              		.loc 1 1466 0
 2318 122c 003084E5 		str	r3, [r4, #0]
1467:main.c        **** 
 2319              		.loc 1 1467 0
 2320 1230 FEFFFFEB 		bl	AD_conversion
 2321              	.LVL172:
1469:main.c        **** 		rprintf("\n\r");
 2322              		.loc 1 1469 0
 2323 1234 FA0FA0E3 		mov	r0, #1000
 2324 1238 FEFFFFEB 		bl	delay_ms
 2325              	.LVL173:
1470:main.c        **** 	}
 2326              		.loc 1 1470 0
 2327 123c 48009FE5 		ldr	r0, .L223+48
 2328 1240 FEFFFFEB 		bl	rprintf
 2329              	.LVL174:
 2330              	.L220:
1435:main.c        **** 	{
 2331              		.loc 1 1435 0 discriminator 1
 2332 1244 003098E5 		ldr	r3, [r8, #0]
 2333 1248 080013E3 		tst	r3, #8
 2334 124c DAFFFF1A 		bne	.L221
1473:main.c        **** 	while(1);
 2335              		.loc 1 1473 0
 2336 1250 38009FE5 		ldr	r0, .L223+52
 2337 1254 FEFFFFEB 		bl	rprintf
 2338              	.LVL175:
 2339              	.L222:
 2340 1258 FEFFFFEA 		b	.L222
 2341              	.L224:
 2342              		.align	2
 2343              	.L223:
 2344 125c 2B000000 		.word	.LC4
 2345 1260 47000000 		.word	.LC5
 2346 1264 88130000 		.word	5000
 2347 1268 008002E0 		.word	-536707072
 2348 126c 000006E0 		.word	-536477696
 2349 1270 08FF2000 		.word	2162440
 2350 1274 004003E0 		.word	-536657920
 2351 1278 04FF2000 		.word	2162436
 2352 127c 02FF2000 		.word	2162434
 2353 1280 10FF2000 		.word	2162448
 2354 1284 80FF2000 		.word	2162560
 2355 1288 40FF2000 		.word	2162496
 2356 128c 93000000 		.word	.LC6
 2357 1290 96000000 		.word	.LC7
 2358              		.cfi_endproc
 2359              	.LFE16:
 2361              		.align	2
 2362              		.global	Log_init
 2364              	Log_init:
 2365              	.LFB11:
1083:main.c        **** 	int x, mark = 0, ind = 0;
 2366              		.loc 1 1083 0
 2367              		.cfi_startproc
 2368              		@ Function supports interworking.
 2369              		@ args = 0, pretend = 0, frame = 0
 2370              		@ frame_needed = 0, uses_anonymous_args = 0
 2371              	.LVL176:
 2372 1294 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2373              	.LCFI10:
 2374              		.cfi_def_cfa_offset 36
 2375              		.cfi_offset 4, -36
 2376              		.cfi_offset 5, -32
 2377              		.cfi_offset 6, -28
 2378              		.cfi_offset 7, -24
 2379              		.cfi_offset 8, -20
 2380              		.cfi_offset 9, -16
 2381              		.cfi_offset 10, -12
 2382              		.cfi_offset 11, -8
 2383              		.cfi_offset 14, -4
1088:main.c        **** 	{
 2384              		.loc 1 1088 0
 2385 1298 08059FE5 		ldr	r0, .L293
 2386 129c FEFFFFEB 		bl	root_file_exists
 2387              	.LVL177:
 2388 12a0 000050E3 		cmp	r0, #0
 2389 12a4 00459FE5 		ldr	r4, .L293+4
1091:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
 2390              		.loc 1 1091 0
 2391 12a8 F8049FE5 		ldr	r0, .L293
1088:main.c        **** 	{
 2392              		.loc 1 1088 0
 2393 12ac 0C00000A 		beq	.L226
1091:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
 2394              		.loc 1 1091 0
 2395 12b0 FEFFFFEB 		bl	root_open
 2396              	.LVL178:
1092:main.c        **** 		stringBuf[stringSize] = '\0';
 2397              		.loc 1 1092 0
 2398 12b4 F4549FE5 		ldr	r5, .L293+8
 2399 12b8 022CA0E3 		mov	r2, #512
 2400 12bc 0510A0E1 		mov	r1, r5
1091:main.c        **** 		stringSize = fat_read_file(fd, (unsigned char *)stringBuf, 512);
 2401              		.loc 1 1091 0
 2402 12c0 000084E5 		str	r0, [r4, #0]
1092:main.c        **** 		stringBuf[stringSize] = '\0';
 2403              		.loc 1 1092 0
 2404 12c4 FEFFFFEB 		bl	fat_read_file
 2405              	.LVL179:
 2406 12c8 E4349FE5 		ldr	r3, .L293+12
 2407 12cc 000083E5 		str	r0, [r3, #0]
1093:main.c        **** 		fat_close_file(fd);
 2408              		.loc 1 1093 0
 2409 12d0 0030A0E3 		mov	r3, #0
 2410 12d4 0030C5E7 		strb	r3, [r5, r0]
1094:main.c        **** 	}
 2411              		.loc 1 1094 0
 2412 12d8 000094E5 		ldr	r0, [r4, #0]
 2413 12dc FEFFFFEB 		bl	fat_close_file
 2414              	.LVL180:
 2415 12e0 1F0000EA 		b	.L227
 2416              	.L226:
1099:main.c        **** 		if(fd == NULL)
 2417              		.loc 1 1099 0
 2418 12e4 FEFFFFEB 		bl	root_open_new
 2419              	.LVL181:
1100:main.c        **** 		{
 2420              		.loc 1 1100 0
 2421 12e8 000050E3 		cmp	r0, #0
1099:main.c        **** 		if(fd == NULL)
 2422              		.loc 1 1099 0
 2423 12ec 0050A0E1 		mov	r5, r0
 2424 12f0 000084E5 		str	r0, [r4, #0]
1100:main.c        **** 		{
 2425              		.loc 1 1100 0
 2426 12f4 0E00001A 		bne	.L228
1102:main.c        **** 		 	while(1)
 2427              		.loc 1 1102 0
 2428 12f8 B8049FE5 		ldr	r0, .L293+16
 2429 12fc FEFFFFEB 		bl	rprintf
 2430              	.LVL182:
 2431              	.LBB40:
 2432              	.LBB41:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 2433              		.loc 1 1077 0
 2434 1300 0450A0E3 		mov	r5, #4
 2435 1304 B0449FE5 		ldr	r4, .L293+20
 2436 1308 0570A0E1 		mov	r7, r5
 2437              	.L229:
 2438              	.LVL183:
 2439              	.LBE41:
 2440              	.LBE40:
1106:main.c        **** 				stat(0,OFF);
 2441              		.loc 1 1106 0 discriminator 1
 2442 130c 3200A0E3 		mov	r0, #50
 2443              	.LBB43:
 2444              	.LBB44:
 2445              	.LBB45:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 2446              		.loc 1 1072 0 discriminator 1
 2447 1310 026BA0E3 		mov	r6, #2048
 2448              	.LBE45:
 2449              	.LBE44:
 2450              	.LBE43:
 2451              	.LBB48:
 2452              	.LBB42:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 2453              		.loc 1 1077 0 discriminator 1
 2454 1314 0C7084E5 		str	r7, [r4, #12]
 2455              	.LBE42:
 2456              	.LBE48:
1106:main.c        **** 				stat(0,OFF);
 2457              		.loc 1 1106 0 discriminator 1
 2458 1318 FEFFFFEB 		bl	delay_ms
 2459              	.LVL184:
 2460              	.LBB49:
 2461              	.LBB50:
1078:main.c        **** 	}
 2462              		.loc 1 1078 0 discriminator 1
 2463 131c 045084E5 		str	r5, [r4, #4]
 2464              	.LVL185:
 2465              	.LBE50:
 2466              	.LBE49:
1109:main.c        **** 				stat(1,OFF);
 2467              		.loc 1 1109 0 discriminator 1
 2468 1320 3200A0E3 		mov	r0, #50
 2469              	.LBB51:
 2470              	.LBB47:
 2471              	.LBB46:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 2472              		.loc 1 1072 0 discriminator 1
 2473 1324 0C6084E5 		str	r6, [r4, #12]
 2474              	.LBE46:
 2475              	.LBE47:
 2476              	.LBE51:
1109:main.c        **** 				stat(1,OFF);
 2477              		.loc 1 1109 0 discriminator 1
 2478 1328 FEFFFFEB 		bl	delay_ms
 2479              	.LVL186:
 2480              	.LBB52:
 2481              	.LBB53:
 2482              	.LBB54:
1073:main.c        **** 	}
 2483              		.loc 1 1073 0 discriminator 1
 2484 132c 046084E5 		str	r6, [r4, #4]
 2485 1330 F5FFFFEA 		b	.L229
 2486              	.LVL187:
 2487              	.L228:
 2488              	.LBE54:
 2489              	.LBE53:
 2490              	.LBE52:
1114:main.c        **** 		stringSize = strlen(stringBuf);
 2491              		.loc 1 1114 0
 2492 1334 84149FE5 		ldr	r1, .L293+24
 2493 1338 70049FE5 		ldr	r0, .L293+8
 2494 133c FEFFFFEB 		bl	strcpy
 2495              	.LVL188:
1115:main.c        **** 		fat_write_file(fd, (unsigned char*)stringBuf, stringSize);
 2496              		.loc 1 1115 0
 2497 1340 68049FE5 		ldr	r0, .L293+8
 2498 1344 FEFFFFEB 		bl	strlen
 2499              	.LVL189:
 2500 1348 64349FE5 		ldr	r3, .L293+12
 2501 134c 0020A0E1 		mov	r2, r0
 2502 1350 000083E5 		str	r0, [r3, #0]
1116:main.c        **** 		sd_raw_sync();
 2503              		.loc 1 1116 0
 2504 1354 54149FE5 		ldr	r1, .L293+8
 2505 1358 0500A0E1 		mov	r0, r5
 2506 135c FEFFFFEB 		bl	fat_write_file
 2507              	.LVL190:
1117:main.c        **** 	}
 2508              		.loc 1 1117 0
 2509 1360 FEFFFFEB 		bl	sd_raw_sync
 2510              	.LVL191:
 2511              	.L227:
1083:main.c        **** 	int x, mark = 0, ind = 0;
 2512              		.loc 1 1083 0 discriminator 1
 2513 1364 0080A0E3 		mov	r8, #0
 2514 1368 54649FE5 		ldr	r6, .L293+28
 2515 136c 0840A0E1 		mov	r4, r8
 2516 1370 0870A0E1 		mov	r7, r8
 2517 1374 08A0A0E1 		mov	sl, r8
1120:main.c        **** 	{
 2518              		.loc 1 1120 0 discriminator 1
 2519 1378 34B49FE5 		ldr	fp, .L293+12
1216:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
 2520              		.loc 1 1216 0 discriminator 1
 2521 137c 44549FE5 		ldr	r5, .L293+32
1169:main.c        **** 				rprintf("frame = %d\n\r",frame);
 2522              		.loc 1 1169 0 discriminator 1
 2523 1380 44949FE5 		ldr	r9, .L293+36
 2524 1384 B00000EA 		b	.L230
 2525              	.LVL192:
 2526              	.L267:
1123:main.c        **** 		{
 2527              		.loc 1 1123 0
 2528 1388 0130F6E5 		ldrb	r3, [r6, #1]!	@ zero_extendqisi2
 2529              	.LVL193:
 2530 138c 0A0053E3 		cmp	r3, #10
 2531 1390 AC00001A 		bne	.L231
 2532              	.LVL194:
1126:main.c        **** 			if(ind == 1)
 2533              		.loc 1 1126 0
 2534 1394 017087E2 		add	r7, r7, #1
 2535              	.LVL195:
1127:main.c        **** 			{
 2536              		.loc 1 1127 0
 2537 1398 010057E3 		cmp	r7, #1
 2538 139c 0600001A 		bne	.L232
1129:main.c        **** 				rprintf("mode = %d\n\r",mode);
 2539              		.loc 1 1129 0
 2540 13a0 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
 2541 13a4 24349FE5 		ldr	r3, .L293+40
 2542 13a8 301041E2 		sub	r1, r1, #48
 2543 13ac FF1001E2 		and	r1, r1, #255
 2544 13b0 0510C3E5 		strb	r1, [r3, #5]
1130:main.c        **** 			}
 2545              		.loc 1 1130 0
 2546 13b4 18049FE5 		ldr	r0, .L293+44
 2547 13b8 A10000EA 		b	.L288
 2548              	.L232:
1132:main.c        **** 			{
 2549              		.loc 1 1132 0
 2550 13bc 020057E3 		cmp	r7, #2
1134:main.c        **** 				rprintf("asc = %c\n\r",asc);
 2551              		.loc 1 1134 0
 2552 13c0 02105605 		ldreqb	r1, [r6, #-2]	@ zero_extendqisi2
1135:main.c        **** 			}
 2553              		.loc 1 1135 0
 2554 13c4 0C049F05 		ldreq	r0, .L293+48
1134:main.c        **** 				rprintf("asc = %c\n\r",asc);
 2555              		.loc 1 1134 0
 2556 13c8 0510C505 		streqb	r1, [r5, #5]
 2557 13cc 9C00000A 		beq	.L288
 2558              	.L233:
1137:main.c        **** 			{
 2559              		.loc 1 1137 0
 2560 13d0 030057E3 		cmp	r7, #3
 2561 13d4 1C00001A 		bne	.L234
1139:main.c        **** 				else if(stringBuf[mark-2] == '2'){ baud = 2400; }
 2562              		.loc 1 1139 0
 2563 13d8 023056E5 		ldrb	r3, [r6, #-2]	@ zero_extendqisi2
 2564 13dc 310053E3 		cmp	r3, #49
 2565 13e0 4B3EA003 		moveq	r3, #1200
 2566 13e4 1400000A 		beq	.L287
 2567              	.L235:
1140:main.c        **** 				else if(stringBuf[mark-2] == '3'){ baud = 4800; }
 2568              		.loc 1 1140 0
 2569 13e8 320053E3 		cmp	r3, #50
 2570 13ec 963EA003 		moveq	r3, #2400
 2571 13f0 1100000A 		beq	.L287
 2572              	.L237:
1141:main.c        **** 				else if(stringBuf[mark-2] == '4'){ baud = 9600; }
 2573              		.loc 1 1141 0
 2574 13f4 330053E3 		cmp	r3, #51
 2575 13f8 4B3DA003 		moveq	r3, #4800
 2576 13fc 0E00000A 		beq	.L287
 2577              	.L238:
1142:main.c        **** 				else if(stringBuf[mark-2] == '5'){ baud = 19200; }
 2578              		.loc 1 1142 0
 2579 1400 340053E3 		cmp	r3, #52
 2580 1404 963DA003 		moveq	r3, #9600
 2581 1408 0B00000A 		beq	.L287
 2582              	.L239:
1143:main.c        **** 				else if(stringBuf[mark-2] == '6'){ baud = 38400; }
 2583              		.loc 1 1143 0
 2584 140c 350053E3 		cmp	r3, #53
 2585 1410 4B3CA003 		moveq	r3, #19200
 2586 1414 0800000A 		beq	.L287
 2587              	.L240:
1144:main.c        **** 				else if(stringBuf[mark-2] == '7'){ baud = 57600; }
 2588              		.loc 1 1144 0
 2589 1418 360053E3 		cmp	r3, #54
 2590 141c 963CA003 		moveq	r3, #38400
 2591 1420 0500000A 		beq	.L287
 2592              	.L241:
1145:main.c        **** 				else if(stringBuf[mark-2] == '8'){ baud = 115200; }
 2593              		.loc 1 1145 0
 2594 1424 370053E3 		cmp	r3, #55
 2595 1428 E13CA003 		moveq	r3, #57600
 2596 142c 0200000A 		beq	.L287
 2597              	.L242:
1146:main.c        **** 
 2598              		.loc 1 1146 0
 2599 1430 380053E3 		cmp	r3, #56
 2600 1434 0100001A 		bne	.L236
1146:main.c        **** 
 2601              		.loc 1 1146 0 is_stmt 0 discriminator 1
 2602 1438 9C339FE5 		ldr	r3, .L293+52
 2603              	.L287:
 2604 143c 103085E5 		str	r3, [r5, #16]
 2605              	.L236:
1148:main.c        **** 			}
 2606              		.loc 1 1148 0 is_stmt 1
 2607 1440 98039FE5 		ldr	r0, .L293+56
 2608 1444 101095E5 		ldr	r1, [r5, #16]
 2609 1448 7D0000EA 		b	.L288
 2610              	.L234:
1150:main.c        **** 			{
 2611              		.loc 1 1150 0
 2612 144c 040057E3 		cmp	r7, #4
 2613 1450 1700001A 		bne	.L243
1152:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
 2614              		.loc 1 1152 0
 2615 1454 022056E5 		ldrb	r2, [r6, #-2]	@ zero_extendqisi2
 2616 1458 031056E5 		ldrb	r1, [r6, #-3]	@ zero_extendqisi2
 2617 145c 912323E0 		mla	r3, r1, r3, r2
1153:main.c        **** 				{
 2618              		.loc 1 1153 0
 2619 1460 042056E5 		ldrb	r2, [r6, #-4]	@ zero_extendqisi2
 2620 1464 301042E2 		sub	r1, r2, #48
1152:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
 2621              		.loc 1 1152 0
 2622 1468 213E43E2 		sub	r3, r3, #528
1153:main.c        **** 				{
 2623              		.loc 1 1153 0
 2624 146c 090051E3 		cmp	r1, #9
1152:main.c        **** 				if((stringBuf[mark-4] >= 48) && (stringBuf[mark-4] < 58))
 2625              		.loc 1 1152 0
 2626 1470 143085E5 		str	r3, [r5, #20]
1153:main.c        **** 				{
 2627              		.loc 1 1153 0
 2628 1474 0B00008A 		bhi	.L245
1155:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
 2629              		.loc 1 1155 0
 2630 1478 6410A0E3 		mov	r1, #100
 2631 147c 913222E0 		mla	r2, r1, r2, r3
1156:main.c        **** 				}
 2632              		.loc 1 1156 0
 2633 1480 053056E5 		ldrb	r3, [r6, #-5]	@ zero_extendqisi2
 2634 1484 301043E2 		sub	r1, r3, #48
 2635 1488 090051E3 		cmp	r1, #9
1155:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
 2636              		.loc 1 1155 0
 2637 148c 4B2D42E2 		sub	r2, r2, #4800
1156:main.c        **** 				}
 2638              		.loc 1 1156 0
 2639 1490 FA1FA093 		movls	r1, #1000
 2640 1494 91232390 		mlals	r3, r1, r3, r2
 2641 1498 BB3C4392 		subls	r3, r3, #47872
 2642 149c 80304392 		subls	r3, r3, #128
1155:main.c        **** 					if((stringBuf[mark-5] >= 48) && (stringBuf[mark-5] < 58)){ freq += (stringBuf[mark-5]-48)*1000
 2643              		.loc 1 1155 0
 2644 14a0 142085E5 		str	r2, [r5, #20]
1156:main.c        **** 				}
 2645              		.loc 1 1156 0
 2646 14a4 14308595 		strls	r3, [r5, #20]
 2647              	.L245:
1158:main.c        **** 			}
 2648              		.loc 1 1158 0
 2649 14a8 34039FE5 		ldr	r0, .L293+60
 2650 14ac 141095E5 		ldr	r1, [r5, #20]
 2651 14b0 630000EA 		b	.L288
 2652              	.L243:
1160:main.c        **** 			{
 2653              		.loc 1 1160 0
 2654 14b4 050057E3 		cmp	r7, #5
1162:main.c        **** 				
 2655              		.loc 1 1162 0
 2656 14b8 02105605 		ldreqb	r1, [r6, #-2]	@ zero_extendqisi2
1164:main.c        **** 			}
 2657              		.loc 1 1164 0
 2658 14bc 24039F05 		ldreq	r0, .L293+64
1162:main.c        **** 				
 2659              		.loc 1 1162 0
 2660 14c0 0010C505 		streqb	r1, [r5, #0]
 2661 14c4 5E00000A 		beq	.L288
 2662              	.L247:
1166:main.c        **** 			{
 2663              		.loc 1 1166 0
 2664 14c8 060057E3 		cmp	r7, #6
 2665 14cc 0F00001A 		bne	.L248
1168:main.c        **** 				if(frame > 510){ frame = 510; } // up to 510 characters
 2666              		.loc 1 1168 0
 2667 14d0 022056E5 		ldrb	r2, [r6, #-2]	@ zero_extendqisi2
 2668 14d4 031056E5 		ldrb	r1, [r6, #-3]	@ zero_extendqisi2
 2669 14d8 532D42E2 		sub	r2, r2, #5312
 2670 14dc 102042E2 		sub	r2, r2, #16
 2671 14e0 932122E0 		mla	r2, r3, r1, r2
 2672 14e4 043056E5 		ldrb	r3, [r6, #-4]	@ zero_extendqisi2
 2673 14e8 6410A0E3 		mov	r1, #100
 2674 14ec 912323E0 		mla	r3, r1, r3, r2
 2675 14f0 0338A0E1 		mov	r3, r3, asl #16
1169:main.c        **** 				rprintf("frame = %d\n\r",frame);
 2676              		.loc 1 1169 0
 2677 14f4 430859E1 		cmp	r9, r3, asr #16
 2678 14f8 2328A0E1 		mov	r2, r3, lsr #16
1168:main.c        **** 				if(frame > 510){ frame = 510; } // up to 510 characters
 2679              		.loc 1 1168 0
 2680 14fc B220C5A1 		strgeh	r2, [r5, #2]	@ movhi
1169:main.c        **** 				rprintf("frame = %d\n\r",frame);
 2681              		.loc 1 1169 0
 2682 1500 B290C5B1 		strlth	r9, [r5, #2]	@ movhi
1170:main.c        **** 			}
 2683              		.loc 1 1170 0
 2684 1504 E0029FE5 		ldr	r0, .L293+68
 2685 1508 F210D5E1 		ldrsh	r1, [r5, #2]
 2686 150c 4C0000EA 		b	.L288
 2687              	.L248:
1172:main.c        **** 			{
 2688              		.loc 1 1172 0
 2689 1510 070057E3 		cmp	r7, #7
 2690 1514 0600001A 		bne	.L251
1174:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
 2691              		.loc 1 1174 0
 2692 1518 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1175:main.c        **** 				rprintf("ad1_3 = %c\n\r",ad1_3);
 2693              		.loc 1 1175 0
 2694 151c 590051E3 		cmp	r1, #89
 2695 1520 01408402 		addeq	r4, r4, #1
 2696              	.LVL196:
1174:main.c        **** 				if(ad1_3 == 'Y'){ temp2++; }
 2697              		.loc 1 1174 0
 2698 1524 0410C5E5 		strb	r1, [r5, #4]
1175:main.c        **** 				rprintf("ad1_3 = %c\n\r",ad1_3);
 2699              		.loc 1 1175 0
 2700 1528 FF400402 		andeq	r4, r4, #255
 2701              	.LVL197:
1176:main.c        **** 			}
 2702              		.loc 1 1176 0
 2703 152c BC029FE5 		ldr	r0, .L293+72
 2704 1530 430000EA 		b	.L288
 2705              	.L251:
1178:main.c        **** 			{
 2706              		.loc 1 1178 0
 2707 1534 080057E3 		cmp	r7, #8
 2708 1538 0600001A 		bne	.L253
1180:main.c        **** 				if(ad0_3 == 'Y'){ temp2++; }
 2709              		.loc 1 1180 0
 2710 153c 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1181:main.c        **** 				rprintf("ad0_3 = %c\n\r",ad0_3);
 2711              		.loc 1 1181 0
 2712 1540 590051E3 		cmp	r1, #89
 2713 1544 01408402 		addeq	r4, r4, #1
 2714              	.LVL198:
1180:main.c        **** 				if(ad0_3 == 'Y'){ temp2++; }
 2715              		.loc 1 1180 0
 2716 1548 0610C5E5 		strb	r1, [r5, #6]
1181:main.c        **** 				rprintf("ad0_3 = %c\n\r",ad0_3);
 2717              		.loc 1 1181 0
 2718 154c FF400402 		andeq	r4, r4, #255
 2719              	.LVL199:
1182:main.c        **** 			}
 2720              		.loc 1 1182 0
 2721 1550 9C029FE5 		ldr	r0, .L293+76
 2722 1554 3A0000EA 		b	.L288
 2723              	.L253:
1184:main.c        **** 			{
 2724              		.loc 1 1184 0
 2725 1558 090057E3 		cmp	r7, #9
 2726 155c 0600001A 		bne	.L255
1186:main.c        **** 				if(ad0_2 == 'Y'){ temp2++; }
 2727              		.loc 1 1186 0
 2728 1560 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1187:main.c        **** 				rprintf("ad0_2 = %c\n\r",ad0_2);
 2729              		.loc 1 1187 0
 2730 1564 590051E3 		cmp	r1, #89
 2731 1568 01408402 		addeq	r4, r4, #1
 2732              	.LVL200:
1186:main.c        **** 				if(ad0_2 == 'Y'){ temp2++; }
 2733              		.loc 1 1186 0
 2734 156c 0710C5E5 		strb	r1, [r5, #7]
1187:main.c        **** 				rprintf("ad0_2 = %c\n\r",ad0_2);
 2735              		.loc 1 1187 0
 2736 1570 FF400402 		andeq	r4, r4, #255
 2737              	.LVL201:
1188:main.c        **** 			}
 2738              		.loc 1 1188 0
 2739 1574 7C029FE5 		ldr	r0, .L293+80
 2740 1578 310000EA 		b	.L288
 2741              	.L255:
1190:main.c        **** 			{
 2742              		.loc 1 1190 0
 2743 157c 0A0057E3 		cmp	r7, #10
 2744 1580 0600001A 		bne	.L257
1192:main.c        **** 				if(ad0_1 == 'Y'){ temp2++; }
 2745              		.loc 1 1192 0
 2746 1584 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1193:main.c        **** 				rprintf("ad0_1 = %c\n\r",ad0_1);
 2747              		.loc 1 1193 0
 2748 1588 590051E3 		cmp	r1, #89
 2749 158c 01408402 		addeq	r4, r4, #1
 2750              	.LVL202:
1192:main.c        **** 				if(ad0_1 == 'Y'){ temp2++; }
 2751              		.loc 1 1192 0
 2752 1590 0810C5E5 		strb	r1, [r5, #8]
1193:main.c        **** 				rprintf("ad0_1 = %c\n\r",ad0_1);
 2753              		.loc 1 1193 0
 2754 1594 FF400402 		andeq	r4, r4, #255
 2755              	.LVL203:
1194:main.c        **** 			}
 2756              		.loc 1 1194 0
 2757 1598 5C029FE5 		ldr	r0, .L293+84
 2758 159c 280000EA 		b	.L288
 2759              	.L257:
1196:main.c        **** 			{
 2760              		.loc 1 1196 0
 2761 15a0 0B0057E3 		cmp	r7, #11
 2762 15a4 0600001A 		bne	.L259
1198:main.c        **** 				if(ad1_2 == 'Y'){ temp2++; }
 2763              		.loc 1 1198 0
 2764 15a8 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1199:main.c        **** 				rprintf("ad1_2 = %c\n\r",ad1_2);
 2765              		.loc 1 1199 0
 2766 15ac 590051E3 		cmp	r1, #89
 2767 15b0 01408402 		addeq	r4, r4, #1
 2768              	.LVL204:
1198:main.c        **** 				if(ad1_2 == 'Y'){ temp2++; }
 2769              		.loc 1 1198 0
 2770 15b4 0910C5E5 		strb	r1, [r5, #9]
1199:main.c        **** 				rprintf("ad1_2 = %c\n\r",ad1_2);
 2771              		.loc 1 1199 0
 2772 15b8 FF400402 		andeq	r4, r4, #255
 2773              	.LVL205:
1200:main.c        **** 			}
 2774              		.loc 1 1200 0
 2775 15bc 3C029FE5 		ldr	r0, .L293+88
 2776 15c0 1F0000EA 		b	.L288
 2777              	.L259:
1202:main.c        **** 			{
 2778              		.loc 1 1202 0
 2779 15c4 0C0057E3 		cmp	r7, #12
 2780 15c8 0600001A 		bne	.L261
1204:main.c        **** 				if(ad0_4 == 'Y'){ temp2++; }
 2781              		.loc 1 1204 0
 2782 15cc 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1205:main.c        **** 				rprintf("ad0_4 = %c\n\r",ad0_4);
 2783              		.loc 1 1205 0
 2784 15d0 590051E3 		cmp	r1, #89
 2785 15d4 01408402 		addeq	r4, r4, #1
 2786              	.LVL206:
1204:main.c        **** 				if(ad0_4 == 'Y'){ temp2++; }
 2787              		.loc 1 1204 0
 2788 15d8 0A10C5E5 		strb	r1, [r5, #10]
1205:main.c        **** 				rprintf("ad0_4 = %c\n\r",ad0_4);
 2789              		.loc 1 1205 0
 2790 15dc FF400402 		andeq	r4, r4, #255
 2791              	.LVL207:
1206:main.c        **** 			}
 2792              		.loc 1 1206 0
 2793 15e0 1C029FE5 		ldr	r0, .L293+92
 2794 15e4 160000EA 		b	.L288
 2795              	.L261:
1208:main.c        **** 			{
 2796              		.loc 1 1208 0
 2797 15e8 0D0057E3 		cmp	r7, #13
 2798 15ec 0600001A 		bne	.L263
1210:main.c        **** 				if(ad1_7 == 'Y'){ temp2++; }
 2799              		.loc 1 1210 0
 2800 15f0 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1211:main.c        **** 				rprintf("ad1_7 = %c\n\r",ad1_7);
 2801              		.loc 1 1211 0
 2802 15f4 590051E3 		cmp	r1, #89
 2803 15f8 01408402 		addeq	r4, r4, #1
 2804              	.LVL208:
1210:main.c        **** 				if(ad1_7 == 'Y'){ temp2++; }
 2805              		.loc 1 1210 0
 2806 15fc 0B10C5E5 		strb	r1, [r5, #11]
1211:main.c        **** 				rprintf("ad1_7 = %c\n\r",ad1_7);
 2807              		.loc 1 1211 0
 2808 1600 FF400402 		andeq	r4, r4, #255
 2809              	.LVL209:
1212:main.c        **** 			}
 2810              		.loc 1 1212 0
 2811 1604 FC019FE5 		ldr	r0, .L293+96
 2812 1608 0D0000EA 		b	.L288
 2813              	.L263:
1214:main.c        **** 			{
 2814              		.loc 1 1214 0
 2815 160c 0E0057E3 		cmp	r7, #14
 2816 1610 0600001A 		bne	.L265
1216:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
 2817              		.loc 1 1216 0
 2818 1614 021056E5 		ldrb	r1, [r6, #-2]	@ zero_extendqisi2
1217:main.c        **** 				rprintf("ad1_6 = %c\n\r",ad1_6);
 2819              		.loc 1 1217 0
 2820 1618 590051E3 		cmp	r1, #89
 2821 161c 01408402 		addeq	r4, r4, #1
 2822              	.LVL210:
1216:main.c        **** 				if(ad1_6 == 'Y'){ temp2++; }
 2823              		.loc 1 1216 0
 2824 1620 0C10C5E5 		strb	r1, [r5, #12]
1217:main.c        **** 				rprintf("ad1_6 = %c\n\r",ad1_6);
 2825              		.loc 1 1217 0
 2826 1624 FF400402 		andeq	r4, r4, #255
 2827              	.LVL211:
1218:main.c        **** 			}
 2828              		.loc 1 1218 0
 2829 1628 DC019FE5 		ldr	r0, .L293+100
 2830 162c 040000EA 		b	.L288
 2831              	.L265:
1220:main.c        **** 			{
 2832              		.loc 1 1220 0
 2833 1630 0F0057E3 		cmp	r7, #15
 2834 1634 0300001A 		bne	.L231
1222:main.c        **** 				rprintf("safety = %c\n\r",safety);
 2835              		.loc 1 1222 0
 2836 1638 028056E5 		ldrb	r8, [r6, #-2]	@ zero_extendqisi2
 2837              	.LVL212:
1223:main.c        **** 			}
 2838              		.loc 1 1223 0
 2839 163c CC019FE5 		ldr	r0, .L293+104
 2840 1640 0810A0E1 		mov	r1, r8
 2841              	.LVL213:
 2842              	.L288:
 2843 1644 FEFFFFEB 		bl	rprintf
 2844              	.LVL214:
 2845              	.L231:
1120:main.c        **** 	{
 2846              		.loc 1 1120 0
 2847 1648 01A08AE2 		add	sl, sl, #1
 2848              	.LVL215:
 2849              	.L230:
1120:main.c        **** 	{
 2850              		.loc 1 1120 0 is_stmt 0 discriminator 1
 2851 164c 00309BE5 		ldr	r3, [fp, #0]
 2852 1650 03005AE1 		cmp	sl, r3
 2853 1654 4BFFFFBA 		blt	.L267
1228:main.c        **** 	{
 2854              		.loc 1 1228 0 is_stmt 1
 2855 1658 590058E3 		cmp	r8, #89
 2856 165c 4D00001A 		bne	.L268
1230:main.c        **** 		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
 2857              		.loc 1 1230 0
 2858 1660 0A0054E3 		cmp	r4, #10
 2859 1664 0500001A 		bne	.L269
1230:main.c        **** 		else if((temp2 == 9) && (freq > 166)){ freq = 166; }
 2860              		.loc 1 1230 0 is_stmt 0 discriminator 1
 2861 1668 58319FE5 		ldr	r3, .L293+32
 2862 166c 142093E5 		ldr	r2, [r3, #20]
 2863 1670 960052E3 		cmp	r2, #150
 2864 1674 9620A0C3 		movgt	r2, #150
 2865 1678 070000CA 		bgt	.L289
 2866 167c 470000EA 		b	.L225
 2867              	.L269:
1231:main.c        **** 		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
 2868              		.loc 1 1231 0 is_stmt 1
 2869 1680 090054E3 		cmp	r4, #9
 2870 1684 0600001A 		bne	.L272
1231:main.c        **** 		else if((temp2 == 8) && (freq > 187)){ freq = 187; }
 2871              		.loc 1 1231 0 is_stmt 0 discriminator 1
 2872 1688 38319FE5 		ldr	r3, .L293+32
 2873 168c 142093E5 		ldr	r2, [r3, #20]
 2874 1690 A60052E3 		cmp	r2, #166
 2875 1694 410000DA 		ble	.L225
 2876 1698 A620A0E3 		mov	r2, #166
 2877              	.L289:
 2878 169c 142083E5 		str	r2, [r3, #20]
 2879 16a0 3E0000EA 		b	.L225
 2880              	.L272:
1232:main.c        **** 		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
 2881              		.loc 1 1232 0 is_stmt 1
 2882 16a4 080054E3 		cmp	r4, #8
 2883 16a8 0500001A 		bne	.L273
1232:main.c        **** 		else if((temp2 == 7) && (freq > 214)){ freq = 214; }
 2884              		.loc 1 1232 0 is_stmt 0 discriminator 1
 2885 16ac 14319FE5 		ldr	r3, .L293+32
 2886 16b0 142093E5 		ldr	r2, [r3, #20]
 2887 16b4 BB0052E3 		cmp	r2, #187
 2888 16b8 BB20A0C3 		movgt	r2, #187
 2889 16bc F6FFFFCA 		bgt	.L289
 2890 16c0 360000EA 		b	.L225
 2891              	.L273:
1233:main.c        **** 		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
 2892              		.loc 1 1233 0 is_stmt 1
 2893 16c4 070054E3 		cmp	r4, #7
 2894 16c8 0500001A 		bne	.L275
1233:main.c        **** 		else if((temp2 == 6) && (freq > 250)){ freq = 250; }
 2895              		.loc 1 1233 0 is_stmt 0 discriminator 1
 2896 16cc F4309FE5 		ldr	r3, .L293+32
 2897 16d0 142093E5 		ldr	r2, [r3, #20]
 2898 16d4 D60052E3 		cmp	r2, #214
 2899 16d8 D620A0C3 		movgt	r2, #214
 2900 16dc EEFFFFCA 		bgt	.L289
 2901 16e0 2E0000EA 		b	.L225
 2902              	.L275:
1234:main.c        **** 		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
 2903              		.loc 1 1234 0 is_stmt 1
 2904 16e4 060054E3 		cmp	r4, #6
 2905 16e8 0500001A 		bne	.L270
1234:main.c        **** 		else if((temp2 == 5) && (freq > 300)){ freq = 300; }
 2906              		.loc 1 1234 0 is_stmt 0 discriminator 1
 2907 16ec D4309FE5 		ldr	r3, .L293+32
 2908 16f0 142093E5 		ldr	r2, [r3, #20]
 2909 16f4 FA0052E3 		cmp	r2, #250
 2910 16f8 FA20A0C3 		movgt	r2, #250
 2911 16fc E6FFFFCA 		bgt	.L289
 2912 1700 260000EA 		b	.L225
 2913              	.L270:
1235:main.c        **** 		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
 2914              		.loc 1 1235 0 is_stmt 1
 2915 1704 050054E3 		cmp	r4, #5
 2916 1708 0500001A 		bne	.L278
1235:main.c        **** 		else if((temp2 == 4) && (freq > 375)){ freq = 375; }
 2917              		.loc 1 1235 0 is_stmt 0 discriminator 1
 2918 170c B4309FE5 		ldr	r3, .L293+32
 2919 1710 142093E5 		ldr	r2, [r3, #20]
 2920 1714 4B0F52E3 		cmp	r2, #300
 2921 1718 4B2FA0C3 		movgt	r2, #300
 2922 171c DEFFFFCA 		bgt	.L289
 2923 1720 1E0000EA 		b	.L225
 2924              	.L278:
1236:main.c        **** 		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
 2925              		.loc 1 1236 0 is_stmt 1
 2926 1724 040054E3 		cmp	r4, #4
1236:main.c        **** 		else if((temp2 == 3) && (freq > 500)){ freq = 500; }
 2927              		.loc 1 1236 0 is_stmt 0 discriminator 1
 2928 1728 98309F05 		ldreq	r3, .L293+32
 2929 172c E0209F05 		ldreq	r2, .L293+108
 2930 1730 0F00000A 		beq	.L291
 2931              	.L274:
1237:main.c        **** 		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
 2932              		.loc 1 1237 0 is_stmt 1
 2933 1734 030054E3 		cmp	r4, #3
 2934 1738 0500001A 		bne	.L276
1237:main.c        **** 		else if((temp2 == 2) && (freq > 750)){ freq = 750; }
 2935              		.loc 1 1237 0 is_stmt 0 discriminator 1
 2936 173c 84309FE5 		ldr	r3, .L293+32
 2937 1740 142093E5 		ldr	r2, [r3, #20]
 2938 1744 7D0F52E3 		cmp	r2, #500
 2939 1748 7D2FA0C3 		movgt	r2, #500
 2940 174c D2FFFFCA 		bgt	.L289
 2941 1750 120000EA 		b	.L225
 2942              	.L276:
1238:main.c        **** 		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
 2943              		.loc 1 1238 0 is_stmt 1
 2944 1754 020054E3 		cmp	r4, #2
1238:main.c        **** 		else if((temp2 == 1) && (freq > 1500)){ freq = 1500; }
 2945              		.loc 1 1238 0 is_stmt 0 discriminator 1
 2946 1758 68309F05 		ldreq	r3, .L293+32
 2947 175c B4209F05 		ldreq	r2, .L293+112
 2948 1760 0300000A 		beq	.L291
 2949              	.L277:
1239:main.c        **** 		else if((temp2 == 0)){ freq = 100; }
 2950              		.loc 1 1239 0 is_stmt 1
 2951 1764 010054E3 		cmp	r4, #1
 2952 1768 0500001A 		bne	.L279
1239:main.c        **** 		else if((temp2 == 0)){ freq = 100; }
 2953              		.loc 1 1239 0 is_stmt 0 discriminator 1
 2954 176c 54309FE5 		ldr	r3, .L293+32
 2955 1770 A4209FE5 		ldr	r2, .L293+116
 2956              	.L291:
 2957 1774 141093E5 		ldr	r1, [r3, #20]
 2958 1778 020051E1 		cmp	r1, r2
 2959 177c 070000DA 		ble	.L225
 2960 1780 C5FFFFEA 		b	.L289
 2961              	.L279:
1240:main.c        **** 	}
 2962              		.loc 1 1240 0 is_stmt 1
 2963 1784 000054E3 		cmp	r4, #0
 2964 1788 0400001A 		bne	.L225
1240:main.c        **** 	}
 2965              		.loc 1 1240 0 is_stmt 0 discriminator 1
 2966 178c 6420A0E3 		mov	r2, #100
 2967 1790 30309FE5 		ldr	r3, .L293+32
 2968 1794 C0FFFFEA 		b	.L289
 2969              	.L268:
1243:main.c        **** 
 2970              		.loc 1 1243 0 is_stmt 1
 2971 1798 540058E3 		cmp	r8, #84
1243:main.c        **** 
 2972              		.loc 1 1243 0 is_stmt 0 discriminator 1
 2973 179c FEFFFF0B 		bleq	test
 2974              	.LVL216:
 2975              	.L225:
1245:main.c        **** 
 2976              		.loc 1 1245 0 is_stmt 1
 2977 17a0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2978 17a4 1EFF2FE1 		bx	lr
 2979              	.L294:
 2980              		.align	2
 2981              	.L293:
 2982 17a8 B7000000 		.word	.LC8
 2983 17ac 00000000 		.word	fd
 2984 17b0 00000000 		.word	stringBuf
 2985 17b4 00000000 		.word	stringSize
 2986 17b8 C2000000 		.word	.LC9
 2987 17bc 008002E0 		.word	-536707072
 2988 17c0 ED000000 		.word	.LC10
 2989 17c4 FFFFFFFF 		.word	stringBuf-1
 2990 17c8 00000000 		.word	.LANCHOR1
 2991 17cc FE010000 		.word	510
 2992 17d0 00000000 		.word	.LANCHOR0
 2993 17d4 AE010000 		.word	.LC11
 2994 17d8 BA010000 		.word	.LC12
 2995 17dc 00C20100 		.word	115200
 2996 17e0 C5010000 		.word	.LC13
 2997 17e4 D1010000 		.word	.LC14
 2998 17e8 DD010000 		.word	.LC15
 2999 17ec E9010000 		.word	.LC16
 3000 17f0 F6010000 		.word	.LC17
 3001 17f4 03020000 		.word	.LC18
 3002 17f8 10020000 		.word	.LC19
 3003 17fc 1D020000 		.word	.LC20
 3004 1800 2A020000 		.word	.LC21
 3005 1804 37020000 		.word	.LC22
 3006 1808 44020000 		.word	.LC23
 3007 180c 51020000 		.word	.LC24
 3008 1810 5E020000 		.word	.LC25
 3009 1814 77010000 		.word	375
 3010 1818 EE020000 		.word	750
 3011 181c DC050000 		.word	1500
 3012              		.cfi_endproc
 3013              	.LFE11:
 3015              		.align	2
 3016              		.global	GetADCValue
 3018              	GetADCValue:
 3019              	.LFB21:
1533:main.c        **** 
1534:main.c        **** /********************** LogADC *****************************
1535:main.c        **** *  Called each time GPS data is logged to generate ADC data
1536:main.c        **** * and log it
1537:main.c        **** ************************************************************/
1538:main.c        **** void LogADC(void)
1539:main.c        **** {
1540:main.c        **** 	
1541:main.c        **** 	// reset TMR0 interrupt
1542:main.c        **** 	T0IR = 1;
1543:main.c        **** 	
1544:main.c        **** 	// reset ADC log buffer pointer to beginning
1545:main.c        **** 	ADC_in = 0;
1546:main.c        **** 
1547:main.c        **** 	//ADC_1 - ad0_3
1548:main.c        **** 	if(ad0_3 == 'Y')
1549:main.c        **** 		GetADCValue(ADC_1);
1550:main.c        **** 		
1551:main.c        **** 	// ADC_2 - ad0_2
1552:main.c        **** 	if(ad0_2 == 'Y')
1553:main.c        **** 		GetADCValue(ADC_2);
1554:main.c        **** 	
1555:main.c        **** 	// ADC_3 - ad0_1
1556:main.c        **** 	if(ad0_1 == 'Y')
1557:main.c        **** 		GetADCValue(ADC_3);
1558:main.c        **** 	
1559:main.c        **** 	// ADC_4 - ad0_4
1560:main.c        **** 	if(ad0_4 == 'Y')
1561:main.c        **** 		GetADCValue(ADC_4);
1562:main.c        **** 	
1563:main.c        **** 	// ADC_5 - ad1_7
1564:main.c        **** 	if(ad1_7 == 'Y')
1565:main.c        **** 		GetADCValue(ADC_5);
1566:main.c        **** 		
1567:main.c        **** 	// ADC_6 - ad1_6
1568:main.c        **** 	if(ad1_6 == 'Y')
1569:main.c        **** 		GetADCValue(ADC_6);
1570:main.c        **** 		
1571:main.c        **** 	// ADC_7 - ad1_2
1572:main.c        **** 	if(ad1_2 == 'Y')
1573:main.c        **** 		GetADCValue(ADC_7);
1574:main.c        **** 		
1575:main.c        **** 	// ADC_8 - ad1_3
1576:main.c        **** 	if(ad1_3 == 'Y')
1577:main.c        **** 		GetADCValue(ADC_8);
1578:main.c        **** 		
1579:main.c        **** 	// if no ADC pins were chosen then write that
1580:main.c        **** 	// if ADC pins were chosen there is a trailing ',' that should be
1581:main.c        **** 	// removed
1582:main.c        **** 	if(ADC_in == 0)	// no ADC pins were selected for reading
1583:main.c        **** 	{
1584:main.c        **** 		// write a warning message (ADC + GPS was chosen but not used)
1585:main.c        **** 		ADC_array[ADC_in] = 'N';
1586:main.c        **** 		ADC_in++;
1587:main.c        **** 		ADC_array[ADC_in] = 'O';
1588:main.c        **** 		ADC_in++;
1589:main.c        **** 		ADC_array[ADC_in] = ' ';
1590:main.c        **** 		ADC_in++;
1591:main.c        **** 		ADC_array[ADC_in] = 'A';
1592:main.c        **** 		ADC_in++;
1593:main.c        **** 		ADC_array[ADC_in] = 'D';
1594:main.c        **** 		ADC_in++;
1595:main.c        **** 		ADC_array[ADC_in] = 'C ';
1596:main.c        **** 		ADC_in++;
1597:main.c        **** 	}
1598:main.c        **** 	else
1599:main.c        **** 	{
1600:main.c        **** 		ADC_in--;	// back up over trailing ','
1601:main.c        **** 	}
1602:main.c        **** 		
1603:main.c        **** 	// add CR/LF and string terminator
1604:main.c        **** 	ADC_array[ADC_in] = 13;
1605:main.c        **** 	ADC_in++;
1606:main.c        **** 	ADC_array[ADC_in] = 10;
1607:main.c        **** 	ADC_in++;
1608:main.c        **** 	ADC_array[ADC_in] = 0;
1609:main.c        **** 	ADC_in++;
1610:main.c        **** 			
1611:main.c        **** 	VICVectAddr= 0;
1612:main.c        **** 	
1613:main.c        **** 	// set microSD write size
1614:main.c        **** 	ADCStringSize = ADC_in;
1615:main.c        **** 	// set ADC logging flag
1616:main.c        **** 	log_adc = 1;
1617:main.c        **** }
1618:main.c        **** 
1619:main.c        **** /****************************** GetADCValue ******************************
1620:main.c        **** *	Retrieves an ADC value for the ADC pin in 'adc.'
1621:main.c        **** *************************************************************************/
1622:main.c        **** void GetADCValue(int adc)
1623:main.c        **** {
 3020              		.loc 1 1623 0
 3021              		.cfi_startproc
 3022              		@ Function supports interworking.
 3023              		@ args = 0, pretend = 0, frame = 4
 3024              		@ frame_needed = 0, uses_anonymous_args = 0
 3025              	.LVL217:
 3026 1820 11402DE9 		stmfd	sp!, {r0, r4, lr}
 3027              	.LCFI11:
 3028              		.cfi_def_cfa_offset 12
 3029              		.cfi_offset 0, -12
 3030              		.cfi_offset 4, -8
 3031              		.cfi_offset 14, -4
1624:main.c        **** 	int temp;	// holds 16-bit ADC value (includes some flag bits)
1625:main.c        **** 	int temp2;	// holds converted (necessary bit shift) ADC value
1626:main.c        **** 	char temp_buff[4];	// holds ascii ADC value - needed for int -> char conversion
1627:main.c        **** 	short a;	// used to convert ADC value for writing as text if NOT using ASCII
1628:main.c        **** 	
1629:main.c        **** 	switch (adc)
 3032              		.loc 1 1629 0
 3033 1824 010040E2 		sub	r0, r0, #1
 3034              	.LVL218:
 3035 1828 070050E3 		cmp	r0, #7
 3036 182c 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 3037 1830 610000EA 		b	.L296
 3038              	.L305:
 3039 1834 54180000 		.word	.L297
 3040 1838 80180000 		.word	.L298
 3041 183c AC180000 		.word	.L299
 3042 1840 D8180000 		.word	.L300
 3043 1844 04190000 		.word	.L301
 3044 1848 30190000 		.word	.L302
 3045 184c 5C190000 		.word	.L303
 3046 1850 88190000 		.word	.L304
 3047              	.L297:
1630:main.c        **** 	{
1631:main.c        **** 		// AD0.3
1632:main.c        **** 		case ADC_1:
1633:main.c        **** 			AD0CR = 0x00020FF08; // AD0.3
 3048              		.loc 1 1633 0
 3049 1854 F0229FE5 		ldr	r2, .L333
 3050 1858 F0129FE5 		ldr	r1, .L333+4
 3051 185c 001082E5 		str	r1, [r2, #0]
1634:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3052              		.loc 1 1634 0
 3053 1860 001092E5 		ldr	r1, [r2, #0]
 3054 1864 011481E3 		orr	r1, r1, #16777216
 3055 1868 001082E5 		str	r1, [r2, #0]
1635:main.c        **** 			while((temp & 0x80000000) == 0)	// wait for ADC to finish conversion
 3056              		.loc 1 1635 0
 3057 186c 000000EA 		b	.L306
 3058              	.LVL219:
 3059              	.L307:
1636:main.c        **** 			{
1637:main.c        **** 				temp = AD0DR;
 3060              		.loc 1 1637 0
 3061 1870 043092E5 		ldr	r3, [r2, #4]
 3062              	.LVL220:
 3063              	.L306:
1635:main.c        **** 			while((temp & 0x80000000) == 0)	// wait for ADC to finish conversion
 3064              		.loc 1 1635 0 discriminator 1
 3065 1874 000053E3 		cmp	r3, #0
 3066 1878 FCFFFFAA 		bge	.L307
 3067 187c 4B0000EA 		b	.L331
 3068              	.LVL221:
 3069              	.L298:
1638:main.c        **** 			}				
1639:main.c        **** 			AD0CR = 0x00000000;	// stop ADC conversion			
1640:main.c        **** 			break;
1641:main.c        **** 			
1642:main.c        **** 		// AD0.2	
1643:main.c        **** 		case ADC_2:
1644:main.c        **** 			AD0CR = 0x00020FF04; // AD0.2
 3070              		.loc 1 1644 0
 3071 1880 C4229FE5 		ldr	r2, .L333
 3072 1884 C8129FE5 		ldr	r1, .L333+8
 3073 1888 001082E5 		str	r1, [r2, #0]
1645:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3074              		.loc 1 1645 0
 3075 188c 001092E5 		ldr	r1, [r2, #0]
 3076 1890 011481E3 		orr	r1, r1, #16777216
 3077 1894 001082E5 		str	r1, [r2, #0]
1646:main.c        **** 			while((temp & 0x80000000) == 0)
 3078              		.loc 1 1646 0
 3079 1898 000000EA 		b	.L309
 3080              	.LVL222:
 3081              	.L310:
1647:main.c        **** 			{
1648:main.c        **** 				temp = AD0DR;
 3082              		.loc 1 1648 0
 3083 189c 043092E5 		ldr	r3, [r2, #4]
 3084              	.LVL223:
 3085              	.L309:
1646:main.c        **** 			while((temp & 0x80000000) == 0)
 3086              		.loc 1 1646 0 discriminator 1
 3087 18a0 000053E3 		cmp	r3, #0
 3088 18a4 FCFFFFAA 		bge	.L310
 3089 18a8 400000EA 		b	.L331
 3090              	.LVL224:
 3091              	.L299:
1649:main.c        **** 			}
1650:main.c        **** 			AD0CR = 0x00000000;		
1651:main.c        **** 		break;
1652:main.c        **** 		
1653:main.c        **** 		// AD0.1
1654:main.c        **** 		case ADC_3:
1655:main.c        **** 			AD0CR = 0x00020FF02; // AD0.1
 3092              		.loc 1 1655 0
 3093 18ac 98229FE5 		ldr	r2, .L333
 3094 18b0 A0129FE5 		ldr	r1, .L333+12
 3095 18b4 001082E5 		str	r1, [r2, #0]
1656:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3096              		.loc 1 1656 0
 3097 18b8 001092E5 		ldr	r1, [r2, #0]
 3098 18bc 011481E3 		orr	r1, r1, #16777216
 3099 18c0 001082E5 		str	r1, [r2, #0]
1657:main.c        **** 			while((temp & 0x80000000) == 0)
 3100              		.loc 1 1657 0
 3101 18c4 000000EA 		b	.L311
 3102              	.LVL225:
 3103              	.L312:
1658:main.c        **** 			{
1659:main.c        **** 				temp = AD0DR;
 3104              		.loc 1 1659 0
 3105 18c8 043092E5 		ldr	r3, [r2, #4]
 3106              	.LVL226:
 3107              	.L311:
1657:main.c        **** 			while((temp & 0x80000000) == 0)
 3108              		.loc 1 1657 0 discriminator 1
 3109 18cc 000053E3 		cmp	r3, #0
 3110 18d0 FCFFFFAA 		bge	.L312
 3111 18d4 350000EA 		b	.L331
 3112              	.LVL227:
 3113              	.L300:
1660:main.c        **** 			}
1661:main.c        **** 			AD0CR = 0x00000000;		
1662:main.c        **** 		break;
1663:main.c        **** 		
1664:main.c        **** 		// AD0.4
1665:main.c        **** 		case ADC_4:
1666:main.c        **** 			AD0CR = 0x00020FF10; // AD0.4
 3114              		.loc 1 1666 0
 3115 18d8 6C229FE5 		ldr	r2, .L333
 3116 18dc 78129FE5 		ldr	r1, .L333+16
 3117 18e0 001082E5 		str	r1, [r2, #0]
1667:main.c        **** 			AD0CR |= 0x01000000; // start conversion
 3118              		.loc 1 1667 0
 3119 18e4 001092E5 		ldr	r1, [r2, #0]
 3120 18e8 011481E3 		orr	r1, r1, #16777216
 3121 18ec 001082E5 		str	r1, [r2, #0]
1668:main.c        **** 			while((temp & 0x80000000) == 0)
 3122              		.loc 1 1668 0
 3123 18f0 000000EA 		b	.L313
 3124              	.LVL228:
 3125              	.L314:
1669:main.c        **** 			{
1670:main.c        **** 				temp = AD0DR;
 3126              		.loc 1 1670 0
 3127 18f4 043092E5 		ldr	r3, [r2, #4]
 3128              	.LVL229:
 3129              	.L313:
1668:main.c        **** 			while((temp & 0x80000000) == 0)
 3130              		.loc 1 1668 0 discriminator 1
 3131 18f8 000053E3 		cmp	r3, #0
 3132 18fc FCFFFFAA 		bge	.L314
 3133 1900 2A0000EA 		b	.L331
 3134              	.LVL230:
 3135              	.L301:
1671:main.c        **** 			}
1672:main.c        **** 			AD0CR = 0x00000000;		
1673:main.c        **** 		break;
1674:main.c        **** 		
1675:main.c        **** 		// AD1.7
1676:main.c        **** 		case ADC_5:
1677:main.c        **** 			AD1CR = 0x00020FF80; // AD1.7
 3136              		.loc 1 1677 0
 3137 1904 54229FE5 		ldr	r2, .L333+20
 3138 1908 54129FE5 		ldr	r1, .L333+24
 3139 190c 001082E5 		str	r1, [r2, #0]
1678:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3140              		.loc 1 1678 0
 3141 1910 001092E5 		ldr	r1, [r2, #0]
 3142 1914 011481E3 		orr	r1, r1, #16777216
 3143 1918 001082E5 		str	r1, [r2, #0]
1679:main.c        **** 			while((temp & 0x80000000) == 0)
 3144              		.loc 1 1679 0
 3145 191c 000000EA 		b	.L315
 3146              	.LVL231:
 3147              	.L316:
1680:main.c        **** 			{
1681:main.c        **** 				temp = AD1DR;
 3148              		.loc 1 1681 0
 3149 1920 043092E5 		ldr	r3, [r2, #4]
 3150              	.LVL232:
 3151              	.L315:
1679:main.c        **** 			while((temp & 0x80000000) == 0)
 3152              		.loc 1 1679 0 discriminator 1
 3153 1924 000053E3 		cmp	r3, #0
 3154 1928 FCFFFFAA 		bge	.L316
 3155 192c 1F0000EA 		b	.L331
 3156              	.LVL233:
 3157              	.L302:
1682:main.c        **** 			}
1683:main.c        **** 			AD1CR = 0x00000000;		
1684:main.c        **** 		break;
1685:main.c        **** 		
1686:main.c        **** 		// AD1.6
1687:main.c        **** 		case ADC_6:
1688:main.c        **** 			AD1CR = 0x00020FF40; // AD1.3
 3158              		.loc 1 1688 0
 3159 1930 28229FE5 		ldr	r2, .L333+20
 3160 1934 2C129FE5 		ldr	r1, .L333+28
 3161 1938 001082E5 		str	r1, [r2, #0]
1689:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3162              		.loc 1 1689 0
 3163 193c 001092E5 		ldr	r1, [r2, #0]
 3164 1940 011481E3 		orr	r1, r1, #16777216
 3165 1944 001082E5 		str	r1, [r2, #0]
1690:main.c        **** 			while((temp & 0x80000000) == 0)
 3166              		.loc 1 1690 0
 3167 1948 000000EA 		b	.L317
 3168              	.LVL234:
 3169              	.L318:
1691:main.c        **** 			{
1692:main.c        **** 				temp = AD1DR;
 3170              		.loc 1 1692 0
 3171 194c 043092E5 		ldr	r3, [r2, #4]
 3172              	.LVL235:
 3173              	.L317:
1690:main.c        **** 			while((temp & 0x80000000) == 0)
 3174              		.loc 1 1690 0 discriminator 1
 3175 1950 000053E3 		cmp	r3, #0
 3176 1954 FCFFFFAA 		bge	.L318
 3177 1958 140000EA 		b	.L331
 3178              	.LVL236:
 3179              	.L303:
1693:main.c        **** 			}
1694:main.c        **** 			AD1CR = 0x00000000;		
1695:main.c        **** 		break;
1696:main.c        **** 		
1697:main.c        **** 		// AD1.2
1698:main.c        **** 		case ADC_7:
1699:main.c        **** 			AD1CR = 0x00020FF04; // AD1.2
 3180              		.loc 1 1699 0
 3181 195c FC219FE5 		ldr	r2, .L333+20
 3182 1960 EC119FE5 		ldr	r1, .L333+8
 3183 1964 001082E5 		str	r1, [r2, #0]
1700:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3184              		.loc 1 1700 0
 3185 1968 001092E5 		ldr	r1, [r2, #0]
 3186 196c 011481E3 		orr	r1, r1, #16777216
 3187 1970 001082E5 		str	r1, [r2, #0]
1701:main.c        **** 			while((temp & 0x80000000) == 0)
 3188              		.loc 1 1701 0
 3189 1974 000000EA 		b	.L319
 3190              	.LVL237:
 3191              	.L320:
1702:main.c        **** 			{
1703:main.c        **** 				temp = AD1DR;
 3192              		.loc 1 1703 0
 3193 1978 043092E5 		ldr	r3, [r2, #4]
 3194              	.LVL238:
 3195              	.L319:
1701:main.c        **** 			while((temp & 0x80000000) == 0)
 3196              		.loc 1 1701 0 discriminator 1
 3197 197c 000053E3 		cmp	r3, #0
 3198 1980 FCFFFFAA 		bge	.L320
 3199 1984 090000EA 		b	.L331
 3200              	.LVL239:
 3201              	.L304:
1704:main.c        **** 			}
1705:main.c        **** 			AD1CR = 0x00000000;
1706:main.c        **** 		break;
1707:main.c        **** 		
1708:main.c        **** 		// AD1.3
1709:main.c        **** 		case ADC_8:
1710:main.c        **** 			AD1CR = 0x00020FF08; // AD1.3
 3202              		.loc 1 1710 0
 3203 1988 D0219FE5 		ldr	r2, .L333+20
 3204 198c BC119FE5 		ldr	r1, .L333+4
 3205 1990 001082E5 		str	r1, [r2, #0]
1711:main.c        **** 			AD1CR |= 0x01000000; // start conversion
 3206              		.loc 1 1711 0
 3207 1994 001092E5 		ldr	r1, [r2, #0]
 3208 1998 011481E3 		orr	r1, r1, #16777216
 3209 199c 001082E5 		str	r1, [r2, #0]
1712:main.c        **** 			while((temp & 0x80000000) == 0)
 3210              		.loc 1 1712 0
 3211 19a0 000000EA 		b	.L321
 3212              	.LVL240:
 3213              	.L322:
1713:main.c        **** 			{
1714:main.c        **** 				temp = AD1DR;
 3214              		.loc 1 1714 0
 3215 19a4 043092E5 		ldr	r3, [r2, #4]
 3216              	.LVL241:
 3217              	.L321:
1712:main.c        **** 			while((temp & 0x80000000) == 0)
 3218              		.loc 1 1712 0 discriminator 1
 3219 19a8 000053E3 		cmp	r3, #0
 3220 19ac FCFFFFAA 		bge	.L322
 3221              	.L331:
1715:main.c        **** 			}
1716:main.c        **** 			AD1CR = 0x00000000;	
 3222              		.loc 1 1716 0
 3223 19b0 0010A0E3 		mov	r1, #0
 3224 19b4 001082E5 		str	r1, [r2, #0]
1717:main.c        **** 		break;
 3225              		.loc 1 1717 0
 3226 19b8 0F0000EA 		b	.L308
 3227              	.LVL242:
 3228              	.L296:
1718:main.c        **** 		
1719:main.c        **** 		// should never get here - logic error
1720:main.c        **** 		default:
1721:main.c        **** 			ADC_array[ADC_in] = 'e';
 3229              		.loc 1 1721 0
 3230 19bc A8119FE5 		ldr	r1, .L333+32
 3231 19c0 B630D1E1 		ldrh	r3, [r1, #6]
 3232 19c4 A4219FE5 		ldr	r2, .L333+36
 3233 19c8 0308A0E1 		mov	r0, r3, asl #16
 3234              	.LVL243:
 3235 19cc 65C0A0E3 		mov	ip, #101
 3236 19d0 40C8C2E7 		strb	ip, [r2, r0, asr #16]
1722:main.c        **** 			ADC_in++;
 3237              		.loc 1 1722 0
 3238 19d4 01C083E2 		add	ip, r3, #1
1723:main.c        **** 			ADC_array[ADC_in] = 'r';
 3239              		.loc 1 1723 0
 3240 19d8 0CC8A0E1 		mov	ip, ip, asl #16
 3241 19dc 7200A0E3 		mov	r0, #114
 3242 19e0 4C08C2E7 		strb	r0, [r2, ip, asr #16]
1724:main.c        **** 			ADC_in++;
 3243              		.loc 1 1724 0
 3244 19e4 02C083E2 		add	ip, r3, #2
1725:main.c        **** 			ADC_array[ADC_in] = 'r';
 3245              		.loc 1 1725 0
 3246 19e8 0CC8A0E1 		mov	ip, ip, asl #16
1726:main.c        **** 			ADC_in++;
 3247              		.loc 1 1726 0
 3248 19ec 033083E2 		add	r3, r3, #3
1725:main.c        **** 			ADC_array[ADC_in] = 'r';
 3249              		.loc 1 1725 0
 3250 19f0 4C08C2E7 		strb	r0, [r2, ip, asr #16]
 3251              		.loc 1 1726 0
 3252 19f4 B630C1E1 		strh	r3, [r1, #6]	@ movhi
 3253 19f8 510000EA 		b	.L295
 3254              	.LVL244:
 3255              	.L308:
1727:main.c        **** 			return;
1728:main.c        **** 		break;
1729:main.c        **** 	}
1730:main.c        **** 	
1731:main.c        **** 	//	convert ADC value - bit shift required (some bits are flags, not part
1732:main.c        **** 	//  of actual ADC value) 15:6 create the 10 bit ADC value
1733:main.c        **** 	temp &= 0x0000FFC0;	// strip all bits except 15:6
 3256              		.loc 1 1733 0
 3257 19fc 70019FE5 		ldr	r0, .L333+40
 3258 1a00 000003E0 		and	r0, r3, r0
 3259              	.LVL245:
1734:main.c        **** 	temp2 = temp / 0x00000040; // shift bit right 6 places
1735:main.c        **** 
1736:main.c        **** 	// convert value to characters
1737:main.c        **** 	
1738:main.c        **** 	if(asc == 'Y' || asc ==',')
 3260              		.loc 1 1738 0
 3261 1a04 6C319FE5 		ldr	r3, .L333+44
 3262 1a08 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 3263 1a0c 590053E3 		cmp	r3, #89
 3264 1a10 2C005313 		cmpne	r3, #44
1734:main.c        **** 	temp2 = temp / 0x00000040; // shift bit right 6 places
 3265              		.loc 1 1734 0
 3266 1a14 4003A0E1 		mov	r0, r0, asr #6
 3267              	.LVL246:
 3268              		.loc 1 1738 0
 3269 1a18 3C00001A 		bne	.L324
1739:main.c        **** 	{
1740:main.c        **** 		itoa(temp2, 10, temp_buff);
 3270              		.loc 1 1740 0
 3271 1a1c 0A10A0E3 		mov	r1, #10
 3272 1a20 0D20A0E1 		mov	r2, sp
 3273 1a24 FEFFFFEB 		bl	itoa
 3274              	.LVL247:
1741:main.c        **** 		if(temp_buff[0] >= 48 && temp_buff[0] <= 57)
 3275              		.loc 1 1741 0
 3276 1a28 0010DDE5 		ldrb	r1, [sp, #0]	@ zero_extendqisi2
 3277 1a2c 303041E2 		sub	r3, r1, #48
 3278 1a30 090053E3 		cmp	r3, #9
 3279 1a34 0600008A 		bhi	.L325
1742:main.c        **** 		{
1743:main.c        **** 			ADC_array[ADC_in] = temp_buff[0];
 3280              		.loc 1 1743 0
 3281 1a38 2C319FE5 		ldr	r3, .L333+32
 3282 1a3c B620D3E1 		ldrh	r2, [r3, #6]
 3283 1a40 28019FE5 		ldr	r0, .L333+36
 3284 1a44 02C8A0E1 		mov	ip, r2, asl #16
1744:main.c        **** 			ADC_in++;
 3285              		.loc 1 1744 0
 3286 1a48 012082E2 		add	r2, r2, #1
1743:main.c        **** 			ADC_in++;
 3287              		.loc 1 1743 0
 3288 1a4c 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3289              		.loc 1 1744 0
 3290 1a50 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3291              	.L325:
1745:main.c        **** 		}
1746:main.c        **** 		if(temp_buff[1] >= 48 && temp_buff[1] <= 57)
 3292              		.loc 1 1746 0
 3293 1a54 0110DDE5 		ldrb	r1, [sp, #1]	@ zero_extendqisi2
 3294 1a58 303041E2 		sub	r3, r1, #48
 3295 1a5c 090053E3 		cmp	r3, #9
 3296 1a60 0600008A 		bhi	.L326
1747:main.c        **** 		{
1748:main.c        **** 			ADC_array[ADC_in] = temp_buff[1];
 3297              		.loc 1 1748 0
 3298 1a64 00319FE5 		ldr	r3, .L333+32
 3299 1a68 B620D3E1 		ldrh	r2, [r3, #6]
 3300 1a6c FC009FE5 		ldr	r0, .L333+36
 3301 1a70 02C8A0E1 		mov	ip, r2, asl #16
1749:main.c        **** 			ADC_in++;
 3302              		.loc 1 1749 0
 3303 1a74 012082E2 		add	r2, r2, #1
1748:main.c        **** 			ADC_in++;
 3304              		.loc 1 1748 0
 3305 1a78 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3306              		.loc 1 1749 0
 3307 1a7c B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3308              	.L326:
1750:main.c        **** 		}
1751:main.c        **** 		if(temp_buff[2] >= 48 && temp_buff[2] <= 57)
 3309              		.loc 1 1751 0
 3310 1a80 0210DDE5 		ldrb	r1, [sp, #2]	@ zero_extendqisi2
 3311 1a84 303041E2 		sub	r3, r1, #48
 3312 1a88 090053E3 		cmp	r3, #9
 3313 1a8c 0600008A 		bhi	.L327
1752:main.c        **** 		{
1753:main.c        **** 			ADC_array[ADC_in] = temp_buff[2];
 3314              		.loc 1 1753 0
 3315 1a90 D4309FE5 		ldr	r3, .L333+32
 3316 1a94 B620D3E1 		ldrh	r2, [r3, #6]
 3317 1a98 D0009FE5 		ldr	r0, .L333+36
 3318 1a9c 02C8A0E1 		mov	ip, r2, asl #16
1754:main.c        **** 			ADC_in++;
 3319              		.loc 1 1754 0
 3320 1aa0 012082E2 		add	r2, r2, #1
1753:main.c        **** 			ADC_in++;
 3321              		.loc 1 1753 0
 3322 1aa4 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3323              		.loc 1 1754 0
 3324 1aa8 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3325              	.L327:
1755:main.c        **** 		}
1756:main.c        **** 		if(temp_buff[3] >= 48 && temp_buff[3] <= 57)
 3326              		.loc 1 1756 0
 3327 1aac 0310DDE5 		ldrb	r1, [sp, #3]	@ zero_extendqisi2
 3328 1ab0 303041E2 		sub	r3, r1, #48
 3329 1ab4 090053E3 		cmp	r3, #9
 3330 1ab8 0600008A 		bhi	.L328
1757:main.c        **** 		{
1758:main.c        **** 			ADC_array[ADC_in] = temp_buff[3];
 3331              		.loc 1 1758 0
 3332 1abc A8309FE5 		ldr	r3, .L333+32
 3333 1ac0 B620D3E1 		ldrh	r2, [r3, #6]
 3334 1ac4 A4009FE5 		ldr	r0, .L333+36
 3335 1ac8 02C8A0E1 		mov	ip, r2, asl #16
1759:main.c        **** 			ADC_in++;
 3336              		.loc 1 1759 0
 3337 1acc 012082E2 		add	r2, r2, #1
1758:main.c        **** 			ADC_in++;
 3338              		.loc 1 1758 0
 3339 1ad0 4C18C0E7 		strb	r1, [r0, ip, asr #16]
 3340              		.loc 1 1759 0
 3341 1ad4 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3342              	.L328:
1760:main.c        **** 		}
1761:main.c        **** 
1762:main.c        **** 		if(asc == ',')
 3343              		.loc 1 1762 0
 3344 1ad8 98309FE5 		ldr	r3, .L333+44
 3345 1adc 0500D3E5 		ldrb	r0, [r3, #5]	@ zero_extendqisi2
 3346 1ae0 84309FE5 		ldr	r3, .L333+32
1763:main.c        **** 		{
1764:main.c        **** 			ADC_array[ADC_in] = ',';
 3347              		.loc 1 1764 0
 3348 1ae4 B620D3E1 		ldrh	r2, [r3, #6]
1762:main.c        **** 		{
 3349              		.loc 1 1762 0
 3350 1ae8 2C0050E3 		cmp	r0, #44
 3351 1aec 7C109FE5 		ldr	r1, .L333+36
 3352              		.loc 1 1764 0
 3353 1af0 02C8A001 		moveq	ip, r2, asl #16
1765:main.c        **** 			ADC_in++;
1766:main.c        **** 		}
1767:main.c        **** 		else
1768:main.c        **** 		{
1769:main.c        **** 			ADC_array[ADC_in] = 0;
 3354              		.loc 1 1769 0
 3355 1af4 0208A011 		movne	r0, r2, asl #16
 3356 1af8 00C0A013 		movne	ip, #0
1770:main.c        **** 			ADC_in++;
 3357              		.loc 1 1770 0
 3358 1afc 012082E2 		add	r2, r2, #1
1764:main.c        **** 			ADC_in++;
 3359              		.loc 1 1764 0
 3360 1b00 4C08C107 		streqb	r0, [r1, ip, asr #16]
1769:main.c        **** 			ADC_in++;
 3361              		.loc 1 1769 0
 3362 1b04 40C8C117 		strneb	ip, [r1, r0, asr #16]
 3363              		.loc 1 1770 0
 3364 1b08 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 3365 1b0c 0C0000EA 		b	.L295
 3366              	.LVL248:
 3367              	.L324:
1771:main.c        **** 		}
1772:main.c        **** 	}
1773:main.c        **** 	else if(asc == 'N')
 3368              		.loc 1 1773 0
 3369 1b10 4E0053E3 		cmp	r3, #78
 3370 1b14 0A00001A 		bne	.L295
 3371              	.LVL249:
1774:main.c        **** 	{
1775:main.c        **** 		a = ((short)temp2 & 0xFF00) / 0x00000100;
1776:main.c        **** 		ADC_array[ADC_in] = (char)a;
 3372              		.loc 1 1776 0
 3373 1b18 4C209FE5 		ldr	r2, .L333+32
 3374 1b1c B630D2E1 		ldrh	r3, [r2, #6]
 3375 1b20 48109FE5 		ldr	r1, .L333+36
 3376 1b24 03C8A0E1 		mov	ip, r3, asl #16
1775:main.c        **** 		ADC_array[ADC_in] = (char)a;
 3377              		.loc 1 1775 0
 3378 1b28 2044A0E1 		mov	r4, r0, lsr #8
 3379              		.loc 1 1776 0
 3380 1b2c 4C48C1E7 		strb	r4, [r1, ip, asr #16]
1777:main.c        **** 		ADC_in++;
 3381              		.loc 1 1777 0
 3382 1b30 01C083E2 		add	ip, r3, #1
1778:main.c        **** 		ADC_array[ADC_in] = (char)temp2 & 0xFF;
 3383              		.loc 1 1778 0
 3384 1b34 0CC8A0E1 		mov	ip, ip, asl #16
1779:main.c        **** 		ADC_in++;
 3385              		.loc 1 1779 0
 3386 1b38 023083E2 		add	r3, r3, #2
1778:main.c        **** 		ADC_array[ADC_in] = (char)temp2 & 0xFF;
 3387              		.loc 1 1778 0
 3388 1b3c 4C08C1E7 		strb	r0, [r1, ip, asr #16]
 3389              		.loc 1 1779 0
 3390 1b40 B630C2E1 		strh	r3, [r2, #6]	@ movhi
 3391              	.LVL250:
 3392              	.L295:
1780:main.c        **** 	}
1781:main.c        **** }
 3393              		.loc 1 1781 0
 3394 1b44 1840BDE8 		ldmfd	sp!, {r3, r4, lr}
 3395 1b48 1EFF2FE1 		bx	lr
 3396              	.L334:
 3397              		.align	2
 3398              	.L333:
 3399 1b4c 004003E0 		.word	-536657920
 3400 1b50 08FF2000 		.word	2162440
 3401 1b54 04FF2000 		.word	2162436
 3402 1b58 02FF2000 		.word	2162434
 3403 1b5c 10FF2000 		.word	2162448
 3404 1b60 000006E0 		.word	-536477696
 3405 1b64 80FF2000 		.word	2162560
 3406 1b68 40FF2000 		.word	2162496
 3407 1b6c 00000000 		.word	.LANCHOR0
 3408 1b70 00000000 		.word	ADC_array
 3409 1b74 C0FF0000 		.word	65472
 3410 1b78 00000000 		.word	.LANCHOR1
 3411              		.cfi_endproc
 3412              	.LFE21:
 3414              		.align	2
 3415              		.global	LogADC
 3417              	LogADC:
 3418              	.LFB20:
1539:main.c        **** 	
 3419              		.loc 1 1539 0
 3420              		.cfi_startproc
 3421              		@ Function supports interworking.
 3422              		@ args = 0, pretend = 0, frame = 0
 3423              		@ frame_needed = 0, uses_anonymous_args = 0
 3424 1b7c 10402DE9 		stmfd	sp!, {r4, lr}
 3425              	.LCFI12:
 3426              		.cfi_def_cfa_offset 8
 3427              		.cfi_offset 4, -8
 3428              		.cfi_offset 14, -4
1542:main.c        **** 	
 3429              		.loc 1 1542 0
 3430 1b80 5C319FE5 		ldr	r3, .L347
 3431 1b84 0100A0E3 		mov	r0, #1
 3432 1b88 000083E5 		str	r0, [r3, #0]
1548:main.c        **** 		GetADCValue(ADC_1);
 3433              		.loc 1 1548 0
 3434 1b8c 54419FE5 		ldr	r4, .L347+4
1545:main.c        **** 
 3435              		.loc 1 1545 0
 3436 1b90 54319FE5 		ldr	r3, .L347+8
 3437 1b94 0020A0E3 		mov	r2, #0
 3438 1b98 B620C3E1 		strh	r2, [r3, #6]	@ movhi
1548:main.c        **** 		GetADCValue(ADC_1);
 3439              		.loc 1 1548 0
 3440 1b9c 0630D4E5 		ldrb	r3, [r4, #6]	@ zero_extendqisi2
 3441 1ba0 590053E3 		cmp	r3, #89
1549:main.c        **** 		
 3442              		.loc 1 1549 0
 3443 1ba4 FEFFFF0B 		bleq	GetADCValue
 3444              	.LVL251:
 3445              	.L336:
1552:main.c        **** 		GetADCValue(ADC_2);
 3446              		.loc 1 1552 0
 3447 1ba8 0730D4E5 		ldrb	r3, [r4, #7]	@ zero_extendqisi2
 3448 1bac 590053E3 		cmp	r3, #89
1553:main.c        **** 	
 3449              		.loc 1 1553 0
 3450 1bb0 0200A003 		moveq	r0, #2
 3451 1bb4 FEFFFF0B 		bleq	GetADCValue
 3452              	.LVL252:
 3453              	.L337:
1556:main.c        **** 		GetADCValue(ADC_3);
 3454              		.loc 1 1556 0
 3455 1bb8 0830D4E5 		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 3456 1bbc 590053E3 		cmp	r3, #89
1557:main.c        **** 	
 3457              		.loc 1 1557 0
 3458 1bc0 0300A003 		moveq	r0, #3
 3459 1bc4 FEFFFF0B 		bleq	GetADCValue
 3460              	.LVL253:
 3461              	.L338:
1560:main.c        **** 		GetADCValue(ADC_4);
 3462              		.loc 1 1560 0
 3463 1bc8 18419FE5 		ldr	r4, .L347+4
 3464 1bcc 0A30D4E5 		ldrb	r3, [r4, #10]	@ zero_extendqisi2
 3465 1bd0 590053E3 		cmp	r3, #89
1561:main.c        **** 	
 3466              		.loc 1 1561 0
 3467 1bd4 0400A003 		moveq	r0, #4
 3468 1bd8 FEFFFF0B 		bleq	GetADCValue
 3469              	.LVL254:
 3470              	.L339:
1564:main.c        **** 		GetADCValue(ADC_5);
 3471              		.loc 1 1564 0
 3472 1bdc 0B30D4E5 		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 3473 1be0 590053E3 		cmp	r3, #89
1565:main.c        **** 		
 3474              		.loc 1 1565 0
 3475 1be4 0500A003 		moveq	r0, #5
 3476 1be8 FEFFFF0B 		bleq	GetADCValue
 3477              	.LVL255:
 3478              	.L340:
1568:main.c        **** 		GetADCValue(ADC_6);
 3479              		.loc 1 1568 0
 3480 1bec 0C30D4E5 		ldrb	r3, [r4, #12]	@ zero_extendqisi2
 3481 1bf0 590053E3 		cmp	r3, #89
1569:main.c        **** 		
 3482              		.loc 1 1569 0
 3483 1bf4 0600A003 		moveq	r0, #6
 3484 1bf8 FEFFFF0B 		bleq	GetADCValue
 3485              	.LVL256:
 3486              	.L341:
1572:main.c        **** 		GetADCValue(ADC_7);
 3487              		.loc 1 1572 0
 3488 1bfc E4309FE5 		ldr	r3, .L347+4
 3489 1c00 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 3490 1c04 590052E3 		cmp	r2, #89
 3491 1c08 0340A0E1 		mov	r4, r3
1573:main.c        **** 		
 3492              		.loc 1 1573 0
 3493 1c0c 0700A003 		moveq	r0, #7
 3494 1c10 FEFFFF0B 		bleq	GetADCValue
 3495              	.LVL257:
 3496              	.L342:
1576:main.c        **** 		GetADCValue(ADC_8);
 3497              		.loc 1 1576 0
 3498 1c14 0430D4E5 		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 3499 1c18 590053E3 		cmp	r3, #89
1577:main.c        **** 		
 3500              		.loc 1 1577 0
 3501 1c1c 0800A003 		moveq	r0, #8
 3502 1c20 FEFFFF0B 		bleq	GetADCValue
 3503              	.LVL258:
 3504              	.L343:
1582:main.c        **** 	{
 3505              		.loc 1 1582 0
 3506 1c24 C0209FE5 		ldr	r2, .L347+8
 3507 1c28 B630D2E1 		ldrh	r3, [r2, #6]
 3508 1c2c 000053E3 		cmp	r3, #0
1600:main.c        **** 	}
 3509              		.loc 1 1600 0
 3510 1c30 01304312 		subne	r3, r3, #1
1582:main.c        **** 	{
 3511              		.loc 1 1582 0
 3512 1c34 0D00001A 		bne	.L346
1585:main.c        **** 		ADC_in++;
 3513              		.loc 1 1585 0
 3514 1c38 B0309FE5 		ldr	r3, .L347+12
 3515 1c3c 4E10A0E3 		mov	r1, #78
 3516 1c40 0010C3E5 		strb	r1, [r3, #0]
1591:main.c        **** 		ADC_in++;
 3517              		.loc 1 1591 0
 3518 1c44 4100A0E3 		mov	r0, #65
1587:main.c        **** 		ADC_in++;
 3519              		.loc 1 1587 0
 3520 1c48 4F10A0E3 		mov	r1, #79
 3521 1c4c 0110C3E5 		strb	r1, [r3, #1]
1591:main.c        **** 		ADC_in++;
 3522              		.loc 1 1591 0
 3523 1c50 0300C3E5 		strb	r0, [r3, #3]
1589:main.c        **** 		ADC_in++;
 3524              		.loc 1 1589 0
 3525 1c54 2010A0E3 		mov	r1, #32
1593:main.c        **** 		ADC_in++;
 3526              		.loc 1 1593 0
 3527 1c58 4400A0E3 		mov	r0, #68
1589:main.c        **** 		ADC_in++;
 3528              		.loc 1 1589 0
 3529 1c5c 0210C3E5 		strb	r1, [r3, #2]
1593:main.c        **** 		ADC_in++;
 3530              		.loc 1 1593 0
 3531 1c60 0400C3E5 		strb	r0, [r3, #4]
1595:main.c        **** 		ADC_in++;
 3532              		.loc 1 1595 0
 3533 1c64 0510C3E5 		strb	r1, [r3, #5]
1596:main.c        **** 	}
 3534              		.loc 1 1596 0
 3535 1c68 0630A0E3 		mov	r3, #6
 3536 1c6c FFFFFFEA 		b	.L346
 3537              	.L346:
1600:main.c        **** 	}
 3538              		.loc 1 1600 0
 3539 1c70 B630C2E1 		strh	r3, [r2, #6]	@ movhi
1604:main.c        **** 	ADC_in++;
 3540              		.loc 1 1604 0
 3541 1c74 70209FE5 		ldr	r2, .L347+8
 3542 1c78 B630D2E1 		ldrh	r3, [r2, #6]
 3543 1c7c 6C109FE5 		ldr	r1, .L347+12
 3544 1c80 0308A0E1 		mov	r0, r3, asl #16
 3545 1c84 0DC0A0E3 		mov	ip, #13
 3546 1c88 40C8C1E7 		strb	ip, [r1, r0, asr #16]
1605:main.c        **** 	ADC_array[ADC_in] = 10;
 3547              		.loc 1 1605 0
 3548 1c8c 010083E2 		add	r0, r3, #1
1606:main.c        **** 	ADC_in++;
 3549              		.loc 1 1606 0
 3550 1c90 0008A0E1 		mov	r0, r0, asl #16
 3551 1c94 0AC0A0E3 		mov	ip, #10
 3552 1c98 40C8C1E7 		strb	ip, [r1, r0, asr #16]
1607:main.c        **** 	ADC_array[ADC_in] = 0;
 3553              		.loc 1 1607 0
 3554 1c9c 02C083E2 		add	ip, r3, #2
1609:main.c        **** 			
 3555              		.loc 1 1609 0
 3556 1ca0 033083E2 		add	r3, r3, #3
1608:main.c        **** 	ADC_in++;
 3557              		.loc 1 1608 0
 3558 1ca4 0000A0E3 		mov	r0, #0
 3559 1ca8 0CC8A0E1 		mov	ip, ip, asl #16
1609:main.c        **** 			
 3560              		.loc 1 1609 0
 3561 1cac 0338A0E1 		mov	r3, r3, asl #16
1608:main.c        **** 	ADC_in++;
 3562              		.loc 1 1608 0
 3563 1cb0 4C08C1E7 		strb	r0, [r1, ip, asr #16]
1609:main.c        **** 			
 3564              		.loc 1 1609 0
 3565 1cb4 2338A0E1 		mov	r3, r3, lsr #16
1611:main.c        **** 	
 3566              		.loc 1 1611 0
 3567 1cb8 0010E0E3 		mvn	r1, #0
1609:main.c        **** 			
 3568              		.loc 1 1609 0
 3569 1cbc B630C2E1 		strh	r3, [r2, #6]	@ movhi
1611:main.c        **** 	
 3570              		.loc 1 1611 0
 3571 1cc0 CF0F01E5 		str	r0, [r1, #-4047]
1614:main.c        **** 	// set ADC logging flag
 3572              		.loc 1 1614 0
 3573 1cc4 0338A0E1 		mov	r3, r3, asl #16
 3574 1cc8 24109FE5 		ldr	r1, .L347+16
 3575 1ccc 4338A0E1 		mov	r3, r3, asr #16
 3576 1cd0 003081E5 		str	r3, [r1, #0]
1616:main.c        **** }
 3577              		.loc 1 1616 0
 3578 1cd4 0130A0E3 		mov	r3, #1
 3579 1cd8 0830C2E5 		strb	r3, [r2, #8]
1617:main.c        **** 
 3580              		.loc 1 1617 0
 3581 1cdc 1040BDE8 		ldmfd	sp!, {r4, lr}
 3582 1ce0 1EFF2FE1 		bx	lr
 3583              	.L348:
 3584              		.align	2
 3585              	.L347:
 3586 1ce4 004000E0 		.word	-536854528
 3587 1ce8 00000000 		.word	.LANCHOR1
 3588 1cec 00000000 		.word	.LANCHOR0
 3589 1cf0 00000000 		.word	ADC_array
 3590 1cf4 00000000 		.word	ADCStringSize
 3591              		.cfi_endproc
 3592              	.LFE20:
 3594              		.align	2
 3595              		.global	mode_action
 3597              	mode_action:
 3598              	.LFB15:
1322:main.c        **** 	int j;
 3599              		.loc 1 1322 0
 3600              		.cfi_startproc
 3601              		@ Function supports interworking.
 3602              		@ args = 0, pretend = 0, frame = 0
 3603              		@ frame_needed = 0, uses_anonymous_args = 0
 3604 1cf8 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 3605              	.LCFI13:
 3606              		.cfi_def_cfa_offset 20
 3607              		.cfi_offset 4, -20
 3608              		.cfi_offset 5, -16
 3609              		.cfi_offset 6, -12
 3610              		.cfi_offset 7, -8
 3611              		.cfi_offset 14, -4
1328:main.c        **** 		{
 3612              		.loc 1 1328 0
 3613 1cfc CC519FE5 		ldr	r5, .L381
 3614              	.LBB143:
 3615              	.LBB144:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3616              		.loc 1 1077 0
 3617 1d00 CC419FE5 		ldr	r4, .L381+4
 3618              	.LBE144:
 3619              	.LBE143:
1332:main.c        **** 			{
 3620              		.loc 1 1332 0
 3621 1d04 CC619FE5 		ldr	r6, .L381+8
 3622              	.L365:
1328:main.c        **** 		{
 3623              		.loc 1 1328 0
 3624 1d08 0230D5E5 		ldrb	r3, [r5, #2]	@ zero_extendqisi2
 3625 1d0c 010053E3 		cmp	r3, #1
 3626 1d10 1A00001A 		bne	.L350
 3627              	.LVL259:
1332:main.c        **** 			{
 3628              		.loc 1 1332 0
 3629 1d14 C0319FE5 		ldr	r3, .L381+12
 3630              	.LBB146:
 3631              	.LBB145:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3632              		.loc 1 1077 0
 3633 1d18 0470A0E3 		mov	r7, #4
 3634 1d1c 0C7084E5 		str	r7, [r4, #12]
 3635              	.LBE145:
 3636              	.LBE146:
1332:main.c        **** 			{
 3637              		.loc 1 1332 0
 3638 1d20 000096E5 		ldr	r0, [r6, #0]
 3639 1d24 B4119FE5 		ldr	r1, .L381+16
 3640 1d28 002093E5 		ldr	r2, [r3, #0]
 3641 1d2c FEFFFFEB 		bl	fat_write_file
 3642              	.LVL260:
 3643 1d30 000050E3 		cmp	r0, #0
 3644 1d34 0D0000AA 		bge	.L351
 3645              	.LBB147:
 3646              	.LBB148:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3647              		.loc 1 1077 0
 3648 1d38 94319FE5 		ldr	r3, .L381+4
 3649              	.LBE148:
 3650              	.LBE147:
 3651              	.LBB150:
 3652              	.LBB151:
 3653              	.LBB152:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3654              		.loc 1 1072 0
 3655 1d3c 020BA0E3 		mov	r0, #2048
 3656 1d40 0310A0E1 		mov	r1, r3
 3657              	.L376:
 3658              	.LVL261:
 3659              	.LBE152:
 3660              	.LBE151:
 3661              	.LBE150:
 3662              	.LBB155:
 3663              	.LBB149:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3664              		.loc 1 1077 0
 3665 1d44 0C7083E5 		str	r7, [r3, #12]
 3666              	.LVL262:
 3667 1d48 94219FE5 		ldr	r2, .L381+20
 3668              	.LVL263:
 3669              	.L352:
 3670              	.LBE149:
 3671              	.LBE155:
1337:main.c        **** 					stat(0,OFF);
 3672              		.loc 1 1337 0
 3673 1d4c 012052E2 		subs	r2, r2, #1
 3674              	.LBB156:
 3675              	.LBB157:
1078:main.c        **** 	}
 3676              		.loc 1 1078 0
 3677 1d50 047081E5 		str	r7, [r1, #4]
 3678              	.LBE157:
 3679              	.LBE156:
1337:main.c        **** 					stat(0,OFF);
 3680              		.loc 1 1337 0
 3681 1d54 FCFFFF1A 		bne	.L352
 3682              	.LVL264:
 3683              	.LBB158:
 3684              	.LBB154:
 3685              	.LBB153:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3686              		.loc 1 1072 0
 3687 1d58 0C0081E5 		str	r0, [r1, #12]
 3688              	.LVL265:
 3689 1d5c 80219FE5 		ldr	r2, .L381+20
 3690              	.LVL266:
 3691              	.L353:
 3692              	.LBE153:
 3693              	.LBE154:
 3694              	.LBE158:
1340:main.c        **** 					stat(1,OFF);
 3695              		.loc 1 1340 0
 3696 1d60 012052E2 		subs	r2, r2, #1
 3697              	.LBB159:
 3698              	.LBB160:
 3699              	.LBB161:
1073:main.c        **** 	}
 3700              		.loc 1 1073 0
 3701 1d64 040083E5 		str	r0, [r3, #4]
 3702              	.LBE161:
 3703              	.LBE160:
 3704              	.LBE159:
1340:main.c        **** 					stat(1,OFF);
 3705              		.loc 1 1340 0
 3706 1d68 FCFFFF1A 		bne	.L353
 3707 1d6c F4FFFFEA 		b	.L376
 3708              	.LVL267:
 3709              	.L351:
1345:main.c        **** 			stat(0,OFF);
 3710              		.loc 1 1345 0
 3711 1d70 FEFFFFEB 		bl	sd_raw_sync
 3712              	.LVL268:
1347:main.c        **** 		}
 3713              		.loc 1 1347 0
 3714 1d74 0030A0E3 		mov	r3, #0
 3715              	.LBB162:
 3716              	.LBB163:
1078:main.c        **** 	}
 3717              		.loc 1 1078 0
 3718 1d78 047084E5 		str	r7, [r4, #4]
 3719              	.LBE163:
 3720              	.LBE162:
1347:main.c        **** 		}
 3721              		.loc 1 1347 0
 3722 1d7c 0230C5E5 		strb	r3, [r5, #2]
 3723              	.LVL269:
 3724              	.L350:
1351:main.c        **** 		{
 3725              		.loc 1 1351 0
 3726 1d80 0330D5E5 		ldrb	r3, [r5, #3]	@ zero_extendqisi2
 3727 1d84 010053E3 		cmp	r3, #1
 3728 1d88 1B00001A 		bne	.L355
 3729              	.LVL270:
1355:main.c        **** 			{
 3730              		.loc 1 1355 0
 3731 1d8c 48319FE5 		ldr	r3, .L381+12
 3732              	.LBB164:
 3733              	.LBB165:
 3734              	.LBB166:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3735              		.loc 1 1072 0
 3736 1d90 027BA0E3 		mov	r7, #2048
 3737 1d94 0C7084E5 		str	r7, [r4, #12]
 3738              	.LBE166:
 3739              	.LBE165:
 3740              	.LBE164:
1355:main.c        **** 			{
 3741              		.loc 1 1355 0
 3742 1d98 000096E5 		ldr	r0, [r6, #0]
 3743 1d9c 44119FE5 		ldr	r1, .L381+24
 3744 1da0 002093E5 		ldr	r2, [r3, #0]
 3745 1da4 FEFFFFEB 		bl	fat_write_file
 3746              	.LVL271:
 3747 1da8 000050E3 		cmp	r0, #0
 3748 1dac 0D0000AA 		bge	.L356
 3749              	.LBB167:
 3750              	.LBB168:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3751              		.loc 1 1077 0
 3752 1db0 1C319FE5 		ldr	r3, .L381+4
 3753 1db4 0410A0E3 		mov	r1, #4
 3754 1db8 0300A0E1 		mov	r0, r3
 3755              	.L377:
 3756              	.LVL272:
 3757 1dbc 0C1083E5 		str	r1, [r3, #12]
 3758              	.LVL273:
 3759 1dc0 1C219FE5 		ldr	r2, .L381+20
 3760              	.LVL274:
 3761              	.L357:
 3762              	.LBE168:
 3763              	.LBE167:
1360:main.c        **** 					stat(0,OFF);
 3764              		.loc 1 1360 0
 3765 1dc4 012052E2 		subs	r2, r2, #1
 3766              	.LBB169:
 3767              	.LBB170:
1078:main.c        **** 	}
 3768              		.loc 1 1078 0
 3769 1dc8 041080E5 		str	r1, [r0, #4]
 3770              	.LBE170:
 3771              	.LBE169:
1360:main.c        **** 					stat(0,OFF);
 3772              		.loc 1 1360 0
 3773 1dcc FCFFFF1A 		bne	.L357
 3774              	.LVL275:
 3775              	.LBB171:
 3776              	.LBB172:
 3777              	.LBB173:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3778              		.loc 1 1072 0
 3779 1dd0 0C7080E5 		str	r7, [r0, #12]
 3780              	.LVL276:
 3781 1dd4 08219FE5 		ldr	r2, .L381+20
 3782              	.LVL277:
 3783              	.L358:
 3784              	.LBE173:
 3785              	.LBE172:
 3786              	.LBE171:
1363:main.c        **** 					stat(1,OFF);
 3787              		.loc 1 1363 0
 3788 1dd8 012052E2 		subs	r2, r2, #1
 3789              	.LBB174:
 3790              	.LBB175:
 3791              	.LBB176:
1073:main.c        **** 	}
 3792              		.loc 1 1073 0
 3793 1ddc 047083E5 		str	r7, [r3, #4]
 3794              	.LBE176:
 3795              	.LBE175:
 3796              	.LBE174:
1363:main.c        **** 					stat(1,OFF);
 3797              		.loc 1 1363 0
 3798 1de0 FCFFFF1A 		bne	.L358
 3799 1de4 F4FFFFEA 		b	.L377
 3800              	.LVL278:
 3801              	.L356:
1368:main.c        **** 			stat(1,OFF);
 3802              		.loc 1 1368 0
 3803 1de8 FEFFFFEB 		bl	sd_raw_sync
 3804              	.LVL279:
 3805              	.LBB177:
 3806              	.LBB178:
 3807              	.LBB179:
1073:main.c        **** 	}
 3808              		.loc 1 1073 0
 3809 1dec 047084E5 		str	r7, [r4, #4]
 3810              	.LBE179:
 3811              	.LBE178:
 3812              	.LBE177:
1370:main.c        **** 			LogADC();
 3813              		.loc 1 1370 0
 3814 1df0 0030A0E3 		mov	r3, #0
 3815 1df4 0330C5E5 		strb	r3, [r5, #3]
1371:main.c        **** 		}
 3816              		.loc 1 1371 0
 3817 1df8 FEFFFFEB 		bl	LogADC
 3818              	.LVL280:
 3819              	.L355:
1375:main.c        **** 		{
 3820              		.loc 1 1375 0
 3821 1dfc 0830D5E5 		ldrb	r3, [r5, #8]	@ zero_extendqisi2
 3822 1e00 010053E3 		cmp	r3, #1
 3823 1e04 1A00001A 		bne	.L360
 3824              	.LVL281:
1379:main.c        **** 			{
 3825              		.loc 1 1379 0
 3826 1e08 DC309FE5 		ldr	r3, .L381+28
 3827              	.LBB180:
 3828              	.LBB181:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3829              		.loc 1 1077 0
 3830 1e0c 0470A0E3 		mov	r7, #4
 3831 1e10 0C7084E5 		str	r7, [r4, #12]
 3832              	.LBE181:
 3833              	.LBE180:
1379:main.c        **** 			{
 3834              		.loc 1 1379 0
 3835 1e14 000096E5 		ldr	r0, [r6, #0]
 3836 1e18 D0109FE5 		ldr	r1, .L381+32
 3837 1e1c 002093E5 		ldr	r2, [r3, #0]
 3838 1e20 FEFFFFEB 		bl	fat_write_file
 3839              	.LVL282:
 3840 1e24 000050E3 		cmp	r0, #0
 3841 1e28 0D0000AA 		bge	.L361
 3842              	.LBB182:
 3843              	.LBB183:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3844              		.loc 1 1077 0
 3845 1e2c A0309FE5 		ldr	r3, .L381+4
 3846              	.LBE183:
 3847              	.LBE182:
 3848              	.LBB185:
 3849              	.LBB186:
 3850              	.LBB187:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3851              		.loc 1 1072 0
 3852 1e30 020BA0E3 		mov	r0, #2048
 3853 1e34 0310A0E1 		mov	r1, r3
 3854              	.L378:
 3855              	.LVL283:
 3856              	.LBE187:
 3857              	.LBE186:
 3858              	.LBE185:
 3859              	.LBB190:
 3860              	.LBB184:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3861              		.loc 1 1077 0
 3862 1e38 0C7083E5 		str	r7, [r3, #12]
 3863              	.LVL284:
 3864 1e3c A0209FE5 		ldr	r2, .L381+20
 3865              	.LVL285:
 3866              	.L362:
 3867              	.LBE184:
 3868              	.LBE190:
1384:main.c        **** 					stat(0,OFF);
 3869              		.loc 1 1384 0
 3870 1e40 012052E2 		subs	r2, r2, #1
 3871              	.LBB191:
 3872              	.LBB192:
1078:main.c        **** 	}
 3873              		.loc 1 1078 0
 3874 1e44 047081E5 		str	r7, [r1, #4]
 3875              	.LBE192:
 3876              	.LBE191:
1384:main.c        **** 					stat(0,OFF);
 3877              		.loc 1 1384 0
 3878 1e48 FCFFFF1A 		bne	.L362
 3879              	.LVL286:
 3880              	.LBB193:
 3881              	.LBB189:
 3882              	.LBB188:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3883              		.loc 1 1072 0
 3884 1e4c 0C0081E5 		str	r0, [r1, #12]
 3885              	.LVL287:
 3886 1e50 8C209FE5 		ldr	r2, .L381+20
 3887              	.LVL288:
 3888              	.L363:
 3889              	.LBE188:
 3890              	.LBE189:
 3891              	.LBE193:
1387:main.c        **** 					stat(1,OFF);
 3892              		.loc 1 1387 0
 3893 1e54 012052E2 		subs	r2, r2, #1
 3894              	.LBB194:
 3895              	.LBB195:
 3896              	.LBB196:
1073:main.c        **** 	}
 3897              		.loc 1 1073 0
 3898 1e58 040083E5 		str	r0, [r3, #4]
 3899              	.LBE196:
 3900              	.LBE195:
 3901              	.LBE194:
1387:main.c        **** 					stat(1,OFF);
 3902              		.loc 1 1387 0
 3903 1e5c FCFFFF1A 		bne	.L363
 3904 1e60 F4FFFFEA 		b	.L378
 3905              	.LVL289:
 3906              	.L361:
1391:main.c        **** 			stat(0,OFF);
 3907              		.loc 1 1391 0
 3908 1e64 FEFFFFEB 		bl	sd_raw_sync
 3909              	.LVL290:
1393:main.c        **** 		}
 3910              		.loc 1 1393 0
 3911 1e68 0030A0E3 		mov	r3, #0
 3912              	.LBB197:
 3913              	.LBB198:
1078:main.c        **** 	}
 3914              		.loc 1 1078 0
 3915 1e6c 047084E5 		str	r7, [r4, #4]
 3916              	.LBE198:
 3917              	.LBE197:
1393:main.c        **** 		}
 3918              		.loc 1 1393 0
 3919 1e70 0830C5E5 		strb	r3, [r5, #8]
 3920              	.LVL291:
 3921              	.L360:
1398:main.c        **** 		{
 3922              		.loc 1 1398 0
 3923 1e74 003094E5 		ldr	r3, [r4, #0]
 3924 1e78 080013E3 		tst	r3, #8
 3925 1e7c A1FFFF1A 		bne	.L365
1400:main.c        **** 			// write whatever is left in the data buffer to the microSD
 3926              		.loc 1 1400 0
 3927 1e80 0030E0E3 		mvn	r3, #0
 3928 1e84 EB3F03E5 		str	r3, [r3, #-4075]
1402:main.c        **** 			{
 3929              		.loc 1 1402 0
 3930 1e88 40309FE5 		ldr	r3, .L381
 3931 1e8c F020D3E1 		ldrsh	r2, [r3, #0]
 3932 1e90 40309FE5 		ldr	r3, .L381+8
 3933 1e94 020C52E3 		cmp	r2, #512
1404:main.c        **** 				sd_raw_sync();
 3934              		.loc 1 1404 0
 3935 1e98 000093E5 		ldr	r0, [r3, #0]
 3936 1e9c 3C109FB5 		ldrlt	r1, .L381+16
1409:main.c        **** 				sd_raw_sync();
 3937              		.loc 1 1409 0
 3938 1ea0 40109FA5 		ldrge	r1, .L381+24
 3939 1ea4 022C42A2 		subge	r2, r2, #512
 3940 1ea8 FEFFFFEB 		bl	fat_write_file
 3941              	.LVL292:
1410:main.c        **** 			}
 3942              		.loc 1 1410 0
 3943 1eac FEFFFFEB 		bl	sd_raw_sync
 3944              	.LVL293:
 3945              	.LBB199:
 3946              	.LBB200:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3947              		.loc 1 1077 0
 3948 1eb0 1C309FE5 		ldr	r3, .L381+4
 3949 1eb4 0410A0E3 		mov	r1, #4
 3950              	.LBE200:
 3951              	.LBE199:
 3952              	.LBB202:
 3953              	.LBB203:
 3954              	.LBB204:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3955              		.loc 1 1072 0
 3956 1eb8 022BA0E3 		mov	r2, #2048
 3957              	.L379:
 3958              	.LVL294:
 3959              	.LBE204:
 3960              	.LBE203:
 3961              	.LBE202:
 3962              	.LBB207:
 3963              	.LBB201:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 3964              		.loc 1 1077 0
 3965 1ebc 0C1083E5 		str	r1, [r3, #12]
 3966              	.LVL295:
 3967              	.LBE201:
 3968              	.LBE207:
 3969              	.LBB208:
 3970              	.LBB209:
1078:main.c        **** 	}
 3971              		.loc 1 1078 0
 3972 1ec0 041083E5 		str	r1, [r3, #4]
 3973              	.LVL296:
 3974              	.LBE209:
 3975              	.LBE208:
 3976              	.LBB210:
 3977              	.LBB206:
 3978              	.LBB205:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 3979              		.loc 1 1072 0
 3980 1ec4 0C2083E5 		str	r2, [r3, #12]
 3981              	.LVL297:
 3982              	.LBE205:
 3983              	.LBE206:
 3984              	.LBE210:
 3985              	.LBB211:
 3986              	.LBB212:
 3987              	.LBB213:
1073:main.c        **** 	}
 3988              		.loc 1 1073 0
 3989 1ec8 042083E5 		str	r2, [r3, #4]
 3990 1ecc FAFFFFEA 		b	.L379
 3991              	.L382:
 3992              		.align	2
 3993              	.L381:
 3994 1ed0 00000000 		.word	.LANCHOR0
 3995 1ed4 008002E0 		.word	-536707072
 3996 1ed8 00000000 		.word	handle
 3997 1edc 00000000 		.word	stringSize
 3998 1ee0 00000000 		.word	RX_array1
 3999 1ee4 20A10700 		.word	500000
 4000 1ee8 00000000 		.word	RX_array2
 4001 1eec 00000000 		.word	ADCStringSize
 4002 1ef0 00000000 		.word	ADC_array
 4003              	.LBE213:
 4004              	.LBE212:
 4005              	.LBE211:
 4006              		.cfi_endproc
 4007              	.LFE15:
 4009              		.global	__divsi3
 4010              		.align	2
 4011              		.global	mode_2
 4013              	mode_2:
 4014              	.LFB14:
1285:main.c        **** 	rprintf("MODE 2\n\r");	
 4015              		.loc 1 1285 0
 4016              		.cfi_startproc
 4017              		@ Function supports interworking.
 4018              		@ args = 0, pretend = 0, frame = 0
 4019              		@ frame_needed = 0, uses_anonymous_args = 0
 4020 1ef4 10402DE9 		stmfd	sp!, {r4, lr}
 4021              	.LCFI14:
 4022              		.cfi_def_cfa_offset 8
 4023              		.cfi_offset 4, -8
 4024              		.cfi_offset 14, -4
1286:main.c        **** 	enableIRQ();
 4025              		.loc 1 1286 0
 4026 1ef8 78009FE5 		ldr	r0, .L384
 4027 1efc FEFFFFEB 		bl	rprintf
 4028              	.LVL298:
1287:main.c        **** 	// Timer0  interrupt is an IRQ interrupt
 4029              		.loc 1 1287 0
 4030 1f00 FEFFFFEB 		bl	enableIRQ
 4031              	.LVL299:
1289:main.c        **** 	// Enable Timer0 interrupt
 4032              		.loc 1 1289 0
 4033 1f04 0030E0E3 		mvn	r3, #0
 4034 1f08 F32F13E5 		ldr	r2, [r3, #-4083]
 4035 1f0c 1020C2E3 		bic	r2, r2, #16
 4036 1f10 F32F03E5 		str	r2, [r3, #-4083]
1291:main.c        **** 	// Use slot 2 for UART0 interrupt
 4037              		.loc 1 1291 0
 4038 1f14 EF2F13E5 		ldr	r2, [r3, #-4079]
 4039 1f18 102082E3 		orr	r2, r2, #16
 4040 1f1c EF2F03E5 		str	r2, [r3, #-4079]
1293:main.c        **** 	// Set the address of ISR for slot 1
 4041              		.loc 1 1293 0
 4042 1f20 2420A0E3 		mov	r2, #36
 4043 1f24 F72D03E5 		str	r2, [r3, #-3575]
1295:main.c        **** 
 4044              		.loc 1 1295 0
 4045 1f28 4C209FE5 		ldr	r2, .L384+4
1297:main.c        **** 	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
 4046              		.loc 1 1297 0
 4047 1f2c 4C409FE5 		ldr	r4, .L384+8
1295:main.c        **** 
 4048              		.loc 1 1295 0
 4049 1f30 F72E03E5 		str	r2, [r3, #-3831]
1297:main.c        **** 	T0MCR = 0x00000003;	// On match reset the counter and generate interrupt
 4050              		.loc 1 1297 0
 4051 1f34 0230A0E3 		mov	r3, #2
 4052 1f38 043084E5 		str	r3, [r4, #4]
1298:main.c        **** 	T0MR0 = 58982400 / freq;
 4053              		.loc 1 1298 0
 4054 1f3c 0330A0E3 		mov	r3, #3
 4055 1f40 143084E5 		str	r3, [r4, #20]
1299:main.c        **** 
 4056              		.loc 1 1299 0
 4057 1f44 38309FE5 		ldr	r3, .L384+12
 4058 1f48 E107A0E3 		mov	r0, #58982400
 4059 1f4c 141093E5 		ldr	r1, [r3, #20]
 4060 1f50 FEFFFFEB 		bl	__divsi3
 4061              	.LVL300:
1301:main.c        **** 
 4062              		.loc 1 1301 0
 4063 1f54 0030A0E3 		mov	r3, #0
1299:main.c        **** 
 4064              		.loc 1 1299 0
 4065 1f58 180084E5 		str	r0, [r4, #24]
1301:main.c        **** 
 4066              		.loc 1 1301 0
 4067 1f5c 0C3084E5 		str	r3, [r4, #12]
1303:main.c        **** 
 4068              		.loc 1 1303 0
 4069 1f60 0130A0E3 		mov	r3, #1
 4070 1f64 043084E5 		str	r3, [r4, #4]
1305:main.c        **** 	mode_action();
 4071              		.loc 1 1305 0
 4072 1f68 18309FE5 		ldr	r3, .L384+16
 4073 1f6c 022CA0E3 		mov	r2, #512
 4074 1f70 002083E5 		str	r2, [r3, #0]
1306:main.c        **** }
 4075              		.loc 1 1306 0
 4076 1f74 FEFFFFEB 		bl	mode_action
 4077              	.LVL301:
 4078              	.L385:
 4079              		.align	2
 4080              	.L384:
 4081 1f78 6C020000 		.word	.LC26
 4082 1f7c 00000000 		.word	MODE2ISR
 4083 1f80 004000E0 		.word	-536854528
 4084 1f84 00000000 		.word	.LANCHOR1
 4085 1f88 00000000 		.word	stringSize
 4086              		.cfi_endproc
 4087              	.LFE14:
 4089              		.align	2
 4090              		.global	mode_1
 4092              	mode_1:
 4093              	.LFB13:
1270:main.c        **** 	rprintf("MODE 1\n\r");	
 4094              		.loc 1 1270 0
 4095              		.cfi_startproc
 4096              		@ Function supports interworking.
 4097              		@ args = 0, pretend = 0, frame = 0
 4098              		@ frame_needed = 0, uses_anonymous_args = 0
 4099 1f8c 10402DE9 		stmfd	sp!, {r4, lr}
 4100              	.LCFI15:
 4101              		.cfi_def_cfa_offset 8
 4102              		.cfi_offset 4, -8
 4103              		.cfi_offset 14, -4
1273:main.c        **** 	stringSize = frame + 2;
 4104              		.loc 1 1273 0
 4105 1f90 24409FE5 		ldr	r4, .L387
1271:main.c        **** 
 4106              		.loc 1 1271 0
 4107 1f94 24009FE5 		ldr	r0, .L387+4
 4108 1f98 FEFFFFEB 		bl	rprintf
 4109              	.LVL302:
1273:main.c        **** 	stringSize = frame + 2;
 4110              		.loc 1 1273 0
 4111 1f9c 100094E5 		ldr	r0, [r4, #16]
 4112 1fa0 0210A0E3 		mov	r1, #2
 4113 1fa4 FEFFFFEB 		bl	setup_uart0
 4114              	.LVL303:
1274:main.c        **** 
 4115              		.loc 1 1274 0
 4116 1fa8 F220D4E1 		ldrsh	r2, [r4, #2]
 4117 1fac 10309FE5 		ldr	r3, .L387+8
 4118 1fb0 022082E2 		add	r2, r2, #2
 4119 1fb4 002083E5 		str	r2, [r3, #0]
1276:main.c        **** }
 4120              		.loc 1 1276 0
 4121 1fb8 FEFFFFEB 		bl	mode_action
 4122              	.LVL304:
 4123              	.L388:
 4124              		.align	2
 4125              	.L387:
 4126 1fbc 00000000 		.word	.LANCHOR1
 4127 1fc0 75020000 		.word	.LC27
 4128 1fc4 00000000 		.word	stringSize
 4129              		.cfi_endproc
 4130              	.LFE13:
 4132              		.align	2
 4133              		.global	mode_0
 4135              	mode_0:
 4136              	.LFB12:
1254:main.c        **** 	rprintf("MODE 0\n\r");
 4137              		.loc 1 1254 0
 4138              		.cfi_startproc
 4139              		@ Function supports interworking.
 4140              		@ args = 0, pretend = 0, frame = 0
 4141              		@ frame_needed = 0, uses_anonymous_args = 0
 4142 1fc8 04E02DE5 		str	lr, [sp, #-4]!
 4143              	.LCFI16:
 4144              		.cfi_def_cfa_offset 4
 4145              		.cfi_offset 14, -4
1255:main.c        **** 	setup_uart0(baud,1);
 4146              		.loc 1 1255 0
 4147 1fcc 20009FE5 		ldr	r0, .L390
 4148 1fd0 FEFFFFEB 		bl	rprintf
 4149              	.LVL305:
1256:main.c        **** 	stringSize = 512;
 4150              		.loc 1 1256 0
 4151 1fd4 1C309FE5 		ldr	r3, .L390+4
 4152 1fd8 0110A0E3 		mov	r1, #1
 4153 1fdc 100093E5 		ldr	r0, [r3, #16]
 4154 1fe0 FEFFFFEB 		bl	setup_uart0
 4155              	.LVL306:
1257:main.c        **** 	mode_action();
 4156              		.loc 1 1257 0
 4157 1fe4 10309FE5 		ldr	r3, .L390+8
 4158 1fe8 022CA0E3 		mov	r2, #512
 4159 1fec 002083E5 		str	r2, [r3, #0]
1258:main.c        **** 	//rprintf("Exit mode 0\n\r");
 4160              		.loc 1 1258 0
 4161 1ff0 FEFFFFEB 		bl	mode_action
 4162              	.LVL307:
 4163              	.L391:
 4164              		.align	2
 4165              	.L390:
 4166 1ff4 7E020000 		.word	.LC28
 4167 1ff8 00000000 		.word	.LANCHOR1
 4168 1ffc 00000000 		.word	stringSize
 4169              		.cfi_endproc
 4170              	.LFE12:
 4172              		.section	.text.startup,"ax",%progbits
 4173              		.align	2
 4174              		.global	main
 4176              	main:
 4177              	.LFB0:
 147:main.c        **** 	int i;
 4178              		.loc 1 147 0
 4179              		.cfi_startproc
 4180              		@ Function supports interworking.
 4181              		@ args = 0, pretend = 0, frame = 44
 4182              		@ frame_needed = 0, uses_anonymous_args = 0
 4183              	.LVL308:
 4184 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 4185              	.LCFI17:
 4186              		.cfi_def_cfa_offset 24
 4187              		.cfi_offset 4, -24
 4188              		.cfi_offset 5, -20
 4189              		.cfi_offset 6, -16
 4190              		.cfi_offset 7, -12
 4191              		.cfi_offset 8, -8
 4192              		.cfi_offset 14, -4
 4193 0004 2CD04DE2 		sub	sp, sp, #44
 4194              	.LCFI18:
 4195              		.cfi_def_cfa_offset 68
 152:main.c        **** 	
 4196              		.loc 1 152 0
 4197 0008 FEFFFFEB 		bl	enableFIQ
 4198              	.LVL309:
 154:main.c        **** 	
 4199              		.loc 1 154 0
 4200 000c FEFFFFEB 		bl	Initialize
 4201              	.LVL310:
 156:main.c        **** 
 4202              		.loc 1 156 0
 4203 0010 960DA0E3 		mov	r0, #9600
 4204 0014 0010A0E3 		mov	r1, #0
 4205 0018 FEFFFFEB 		bl	setup_uart0
 4206              	.LVL311:
 158:main.c        **** 
 4207              		.loc 1 158 0
 4208 001c FEFFFFEB 		bl	fat_initialize
 4209              	.LVL312:
 4210              	.LBB273:
 4211              	.LBB274:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4212              		.loc 1 1077 0
 4213 0020 0460A0E3 		mov	r6, #4
 4214 0024 BC419FE5 		ldr	r4, .L410
 4215              	.LBE274:
 4216              	.LBE273:
 158:main.c        **** 
 4217              		.loc 1 158 0
 4218 0028 0550A0E3 		mov	r5, #5
 4219              	.LBB277:
 4220              	.LBB275:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4221              		.loc 1 1077 0
 4222 002c 0680A0E1 		mov	r8, r6
 4223              	.LVL313:
 4224              	.L393:
 4225              	.LBE275:
 4226              	.LBE277:
 165:main.c        **** 		stat(0,OFF);
 4227              		.loc 1 165 0
 4228 0030 3200A0E3 		mov	r0, #50
 4229              	.LBB278:
 4230              	.LBB279:
 4231              	.LBB280:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4232              		.loc 1 1072 0
 4233 0034 027BA0E3 		mov	r7, #2048
 4234              	.LBE280:
 4235              	.LBE279:
 4236              	.LBE278:
 4237              	.LBB283:
 4238              	.LBB276:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4239              		.loc 1 1077 0
 4240 0038 0C8084E5 		str	r8, [r4, #12]
 4241              	.LBE276:
 4242              	.LBE283:
 165:main.c        **** 		stat(0,OFF);
 4243              		.loc 1 165 0
 4244 003c FEFFFFEB 		bl	delay_ms
 4245              	.LVL314:
 4246              	.LBB284:
 4247              	.LBB285:
1078:main.c        **** 	}
 4248              		.loc 1 1078 0
 4249 0040 046084E5 		str	r6, [r4, #4]
 4250              	.LVL315:
 4251              	.LBE285:
 4252              	.LBE284:
 168:main.c        **** 		stat(1,OFF);
 4253              		.loc 1 168 0
 4254 0044 3200A0E3 		mov	r0, #50
 4255              	.LBB286:
 4256              	.LBB282:
 4257              	.LBB281:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4258              		.loc 1 1072 0
 4259 0048 0C7084E5 		str	r7, [r4, #12]
 4260              	.LBE281:
 4261              	.LBE282:
 4262              	.LBE286:
 168:main.c        **** 		stat(1,OFF);
 4263              		.loc 1 168 0
 4264 004c FEFFFFEB 		bl	delay_ms
 4265              	.LVL316:
 162:main.c        **** 	{
 4266              		.loc 1 162 0
 4267 0050 015055E2 		subs	r5, r5, #1
 4268              	.LBB287:
 4269              	.LBB288:
 4270              	.LBB289:
1073:main.c        **** 	}
 4271              		.loc 1 1073 0
 4272 0054 047084E5 		str	r7, [r4, #4]
 4273              	.LBE289:
 4274              	.LBE288:
 4275              	.LBE287:
 162:main.c        **** 	{
 4276              		.loc 1 162 0
 4277 0058 F4FFFF1A 		bne	.L393
 175:main.c        **** 	while(root_file_exists(name))
 4278              		.loc 1 175 0
 4279 005c 0C508DE2 		add	r5, sp, #12
 172:main.c        **** 
 4280              		.loc 1 172 0
 4281 0060 FEFFFFEB 		bl	Log_init
 4282              	.LVL317:
 175:main.c        **** 	while(root_file_exists(name))
 4283              		.loc 1 175 0
 4284 0064 0500A0E1 		mov	r0, r5
 4285 0068 7C119FE5 		ldr	r1, .L410+4
 4286 006c 0120A0E3 		mov	r2, #1
 4287 0070 FEFFFFEB 		bl	string_printf
 4288              	.LVL318:
 174:main.c        **** 	string_printf(name,"LOG%02d.txt",count);
 4289              		.loc 1 174 0
 4290 0074 0140A0E3 		mov	r4, #1
 176:main.c        **** 	{
 4291              		.loc 1 176 0
 4292 0078 150000EA 		b	.L394
 4293              	.LVL319:
 4294              	.L397:
 178:main.c        **** 		if(count == 250) 
 4295              		.loc 1 178 0
 4296 007c 014084E2 		add	r4, r4, #1
 4297              	.LVL320:
 179:main.c        **** 		{
 4298              		.loc 1 179 0
 4299 0080 FA0054E3 		cmp	r4, #250
 4300 0084 0E00001A 		bne	.L395
 181:main.c        **** 			while(1)
 4301              		.loc 1 181 0
 4302 0088 60019FE5 		ldr	r0, .L410+8
 4303 008c FEFFFFEB 		bl	rprintf
 4304              	.LVL321:
 4305              	.LBB290:
 4306              	.LBB291:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4307              		.loc 1 1077 0
 4308 0090 0450A0E3 		mov	r5, #4
 4309 0094 4C419FE5 		ldr	r4, .L410
 4310              	.LVL322:
 4311 0098 0570A0E1 		mov	r7, r5
 4312              	.L396:
 4313              	.LVL323:
 4314              	.LBE291:
 4315              	.LBE290:
 4316              	.LBB293:
 4317              	.LBB294:
 4318              	.LBB295:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4319              		.loc 1 1072 0 discriminator 1
 4320 009c 026BA0E3 		mov	r6, #2048
 4321              	.LBE295:
 4322              	.LBE294:
 4323              	.LBE293:
 4324              	.LBB298:
 4325              	.LBB292:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4326              		.loc 1 1077 0 discriminator 1
 4327 00a0 0C7084E5 		str	r7, [r4, #12]
 4328              	.LVL324:
 4329              	.LBE292:
 4330              	.LBE298:
 186:main.c        **** 				stat(0,OFF);
 4331              		.loc 1 186 0 discriminator 1
 4332 00a4 FA0FA0E3 		mov	r0, #1000
 4333              	.LBB299:
 4334              	.LBB297:
 4335              	.LBB296:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4336              		.loc 1 1072 0 discriminator 1
 4337 00a8 0C6084E5 		str	r6, [r4, #12]
 4338              	.LBE296:
 4339              	.LBE297:
 4340              	.LBE299:
 186:main.c        **** 				stat(0,OFF);
 4341              		.loc 1 186 0 discriminator 1
 4342 00ac FEFFFFEB 		bl	delay_ms
 4343              	.LVL325:
 4344              	.LBB300:
 4345              	.LBB301:
1078:main.c        **** 	}
 4346              		.loc 1 1078 0 discriminator 1
 4347 00b0 045084E5 		str	r5, [r4, #4]
 4348              	.LVL326:
 4349              	.LBE301:
 4350              	.LBE300:
 189:main.c        **** 			}
 4351              		.loc 1 189 0 discriminator 1
 4352 00b4 FA0FA0E3 		mov	r0, #1000
 4353              	.LBB302:
 4354              	.LBB303:
 4355              	.LBB304:
1073:main.c        **** 	}
 4356              		.loc 1 1073 0 discriminator 1
 4357 00b8 046084E5 		str	r6, [r4, #4]
 4358              	.LBE304:
 4359              	.LBE303:
 4360              	.LBE302:
 189:main.c        **** 			}
 4361              		.loc 1 189 0 discriminator 1
 4362 00bc FEFFFFEB 		bl	delay_ms
 4363              	.LVL327:
 4364 00c0 F5FFFFEA 		b	.L396
 4365              	.LVL328:
 4366              	.L395:
 193:main.c        **** 	}
 4367              		.loc 1 193 0
 4368 00c4 0500A0E1 		mov	r0, r5
 4369 00c8 1C119FE5 		ldr	r1, .L410+4
 4370 00cc 0420A0E1 		mov	r2, r4
 4371 00d0 FEFFFFEB 		bl	string_printf
 4372              	.LVL329:
 4373              	.L394:
 176:main.c        **** 	{
 4374              		.loc 1 176 0 discriminator 1
 4375 00d4 0500A0E1 		mov	r0, r5
 4376 00d8 FEFFFFEB 		bl	root_file_exists
 4377              	.LVL330:
 4378 00dc 000050E3 		cmp	r0, #0
 4379 00e0 E5FFFF1A 		bne	.L397
 196:main.c        **** 		
 4380              		.loc 1 196 0
 4381 00e4 0500A0E1 		mov	r0, r5
 4382 00e8 FEFFFFEB 		bl	root_open_new
 4383              	.LVL331:
 4384 00ec 00619FE5 		ldr	r6, .L410+12
 4385 00f0 000086E5 		str	r0, [r6, #0]
 199:main.c        **** 	
 4386              		.loc 1 199 0
 4387 00f4 FEFFFFEB 		bl	sd_raw_sync
 4388              	.LVL332:
 202:main.c        **** 	{
 4389              		.loc 1 202 0
 4390 00f8 F8309FE5 		ldr	r3, .L410+16
 4391 00fc 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 4392 0100 020053E3 		cmp	r3, #2
 4393 0104 2B00001A 		bne	.L398
 4394              	.LBB305:
 205:main.c        **** 		mybuf[1] = ad0_3;
 4395              		.loc 1 205 0
 4396 0108 EC309FE5 		ldr	r3, .L410+20
 4397 010c 0420D3E5 		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 4398 0110 0020CDE5 		strb	r2, [sp, #0]
 206:main.c        **** 		mybuf[2] = ad0_2;
 4399              		.loc 1 206 0
 4400 0114 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 4401 0118 0120CDE5 		strb	r2, [sp, #1]
 207:main.c        **** 		mybuf[3] = ad0_1;
 4402              		.loc 1 207 0
 4403 011c 0720D3E5 		ldrb	r2, [r3, #7]	@ zero_extendqisi2
 4404 0120 0220CDE5 		strb	r2, [sp, #2]
 208:main.c        **** 		mybuf[4] = ad1_2;
 4405              		.loc 1 208 0
 4406 0124 0820D3E5 		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 4407 0128 0320CDE5 		strb	r2, [sp, #3]
 209:main.c        **** 		mybuf[5] = ad0_4;
 4408              		.loc 1 209 0
 4409 012c 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 4410 0130 0420CDE5 		strb	r2, [sp, #4]
 210:main.c        **** 		mybuf[6] = ad1_7;
 4411              		.loc 1 210 0
 4412 0134 0A20D3E5 		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 4413 0138 0520CDE5 		strb	r2, [sp, #5]
 211:main.c        **** 		mybuf[7] = ad1_6;
 4414              		.loc 1 211 0
 4415 013c 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 212:main.c        **** 		mybuf[8] = 13;
 4416              		.loc 1 212 0
 4417 0140 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 4418              	.LBB306:
 4419              	.LBB307:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4420              		.loc 1 1077 0
 4421 0144 9C409FE5 		ldr	r4, .L410
 4422              	.LVL333:
 4423              	.LBE307:
 4424              	.LBE306:
 211:main.c        **** 		mybuf[7] = ad1_6;
 4425              		.loc 1 211 0
 4426 0148 0620CDE5 		strb	r2, [sp, #6]
 212:main.c        **** 		mybuf[8] = 13;
 4427              		.loc 1 212 0
 4428 014c 0730CDE5 		strb	r3, [sp, #7]
 214:main.c        **** 	
 4429              		.loc 1 214 0
 4430 0150 0A20A0E3 		mov	r2, #10
 213:main.c        **** 		mybuf[9] = 10;	
 4431              		.loc 1 213 0
 4432 0154 0D30A0E3 		mov	r3, #13
 4433              	.LBB310:
 4434              	.LBB308:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4435              		.loc 1 1077 0
 4436 0158 0450A0E3 		mov	r5, #4
 4437              	.LBE308:
 4438              	.LBE310:
 213:main.c        **** 		mybuf[9] = 10;	
 4439              		.loc 1 213 0
 4440 015c 0830CDE5 		strb	r3, [sp, #8]
 214:main.c        **** 	
 4441              		.loc 1 214 0
 4442 0160 0920CDE5 		strb	r2, [sp, #9]
 4443              	.LVL334:
 218:main.c        **** 		{
 4444              		.loc 1 218 0
 4445 0164 000096E5 		ldr	r0, [r6, #0]
 4446              	.LBB311:
 4447              	.LBB309:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4448              		.loc 1 1077 0
 4449 0168 0C5084E5 		str	r5, [r4, #12]
 4450              	.LBE309:
 4451              	.LBE311:
 218:main.c        **** 		{
 4452              		.loc 1 218 0
 4453 016c 0D10A0E1 		mov	r1, sp
 4454 0170 FEFFFFEB 		bl	fat_write_file
 4455              	.LVL335:
 4456 0174 000050E3 		cmp	r0, #0
 4457 0178 0C0000AA 		bge	.L399
 4458 017c 0420A0E1 		mov	r2, r4
 4459              	.LBB312:
 4460              	.LBB313:
 4461              	.LBB314:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4462              		.loc 1 1072 0
 4463 0180 021BA0E3 		mov	r1, #2048
 4464              	.L409:
 4465              	.LVL336:
 4466              	.LBE314:
 4467              	.LBE313:
 4468              	.LBE312:
 4469              	.LBB317:
 4470              	.LBB318:
1077:main.c        **** 		else { IOSET0 = 0x00000004; } // Off
 4471              		.loc 1 1077 0
 4472 0184 0C5084E5 		str	r5, [r4, #12]
 4473              	.LVL337:
 4474 0188 70309FE5 		ldr	r3, .L410+24
 4475              	.LVL338:
 4476              	.L400:
 4477              	.LBE318:
 4478              	.LBE317:
 4479              	.LBB319:
 223:main.c        **** 				stat(0,OFF);
 4480              		.loc 1 223 0
 4481 018c 013053E2 		subs	r3, r3, #1
 4482              	.LBB320:
 4483              	.LBB321:
1078:main.c        **** 	}
 4484              		.loc 1 1078 0
 4485 0190 045082E5 		str	r5, [r2, #4]
 4486              	.LBE321:
 4487              	.LBE320:
 223:main.c        **** 				stat(0,OFF);
 4488              		.loc 1 223 0
 4489 0194 FCFFFF1A 		bne	.L400
 4490              	.LVL339:
 4491              	.LBE319:
 4492              	.LBB322:
 4493              	.LBB316:
 4494              	.LBB315:
1072:main.c        **** 		else { IOSET0 = 0x00000800; } // Off
 4495              		.loc 1 1072 0
 4496 0198 0C1082E5 		str	r1, [r2, #12]
 4497              	.LVL340:
 4498 019c 5C309FE5 		ldr	r3, .L410+24
 4499              	.LVL341:
 4500              	.L401:
 4501              	.LBE315:
 4502              	.LBE316:
 4503              	.LBE322:
 4504              	.LBB323:
 226:main.c        **** 				stat(1,OFF);
 4505              		.loc 1 226 0
 4506 01a0 013053E2 		subs	r3, r3, #1
 4507              	.LBB324:
 4508              	.LBB325:
 4509              	.LBB326:
1073:main.c        **** 	}
 4510              		.loc 1 1073 0
 4511 01a4 041084E5 		str	r1, [r4, #4]
 4512              	.LBE326:
 4513              	.LBE325:
 4514              	.LBE324:
 226:main.c        **** 				stat(1,OFF);
 4515              		.loc 1 226 0
 4516 01a8 FCFFFF1A 		bne	.L401
 4517 01ac F4FFFFEA 		b	.L409
 4518              	.LVL342:
 4519              	.L399:
 4520              	.LBE323:
 231:main.c        **** 		stat(0,OFF);
 4521              		.loc 1 231 0
 4522 01b0 FEFFFFEB 		bl	sd_raw_sync
 4523              	.LVL343:
 4524              	.LBB327:
 4525              	.LBB328:
1078:main.c        **** 	}
 4526              		.loc 1 1078 0
 4527 01b4 045084E5 		str	r5, [r4, #4]
 4528              	.LVL344:
 4529              	.L398:
 4530              	.LBE328:
 4531              	.LBE327:
 4532              	.LBE305:
 235:main.c        **** 	else if(mode == 1){ mode_1(); }
 4533              		.loc 1 235 0
 4534 01b8 38309FE5 		ldr	r3, .L410+16
 4535 01bc 0530D3E5 		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 4536 01c0 000053E3 		cmp	r3, #0
 235:main.c        **** 	else if(mode == 1){ mode_1(); }
 4537              		.loc 1 235 0 is_stmt 0 discriminator 1
 4538 01c4 FEFFFF0B 		bleq	mode_0
 4539              	.LVL345:
 4540              	.L403:
 236:main.c        **** 	else if(mode == 2){ mode_2(); }
 4541              		.loc 1 236 0 is_stmt 1
 4542 01c8 010053E3 		cmp	r3, #1
 236:main.c        **** 	else if(mode == 2){ mode_2(); }
 4543              		.loc 1 236 0 is_stmt 0 discriminator 1
 4544 01cc FEFFFF0B 		bleq	mode_1
 4545              	.LVL346:
 4546              	.L404:
 237:main.c        **** 
 4547              		.loc 1 237 0 is_stmt 1
 4548 01d0 020053E3 		cmp	r3, #2
 237:main.c        **** 
 4549              		.loc 1 237 0 is_stmt 0 discriminator 1
 4550 01d4 FEFFFF0B 		bleq	mode_2
 4551              	.LVL347:
 4552              	.L405:
 240:main.c        **** 
 4553              		.loc 1 240 0 is_stmt 1
 4554 01d8 0000A0E3 		mov	r0, #0
 4555 01dc 2CD08DE2 		add	sp, sp, #44
 4556 01e0 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 4557 01e4 1EFF2FE1 		bx	lr
 4558              	.L411:
 4559              		.align	2
 4560              	.L410:
 4561 01e8 008002E0 		.word	-536707072
 4562 01ec 87020000 		.word	.LC29
 4563 01f0 93020000 		.word	.LC30
 4564 01f4 00000000 		.word	handle
 4565 01f8 00000000 		.word	.LANCHOR0
 4566 01fc 00000000 		.word	.LANCHOR1
 4567 0200 20A10700 		.word	500000
 4568              		.cfi_endproc
 4569              	.LFE0:
 4571              		.text
 4572              		.align	2
 4573              		.global	GetGPSDateTime
 4575              	GetGPSDateTime:
 4576              	.LFB22:
1782:main.c        **** 
1783:main.c        **** 
1784:main.c        **** /********************** GetGPSDateTime *********************************
1785:main.c        **** *  Each time the UART interrupt receives a 10 or 13 (end of line - pick one)r
1786:main.c        **** * it will call this function to strip off the date & time from the NMEA
1787:main.c        **** * sentence.
1788:main.c        **** *  Consideration should be given to situations when the most frequent NMEA
1789:main.c        **** * sentence is placed across the first and second buffer. Easiest solution 
1790:main.c        **** * would be to verify NMEA sentence length and make sure counter (RX_in) is
1791:main.c        **** * past or at a full packet
1792:main.c        **** * ? knowing an end of NMEA sentence has just occurred
1793:main.c        **** * ? see which ADC buffer is in use
1794:main.c        **** * ? reverse through buffer to find '$' if not found, just return
1795:main.c        **** * ? otherwise see if it's GGA (time) or RMC (time, date, and active)
1796:main.c        **** * ? if not, then continue
1797:main.c        **** * ? if so, then if GGA just get time (2nd field, just after 1st comma)
1798:main.c        **** * ? if so, then if RMC get:
1799:main.c        **** * ?    - time (2nd field, just after 1st comma)
1800:main.c        **** * ?    - active (3rd field, just after 2nd comma)
1801:main.c        **** * ?    - date (10th field, just after 9th comma)
1802:main.c        **** ************************************************************************/
1803:main.c        **** void GetGPSDateTime(void)
1804:main.c        **** {
 4577              		.loc 1 1804 0
 4578              		.cfi_startproc
 4579              		@ Function supports interworking.
 4580              		@ args = 0, pretend = 0, frame = 0
 4581              		@ frame_needed = 0, uses_anonymous_args = 0
 4582              		@ link register save eliminated.
 4583 2000 1EFF2FE1 		bx	lr
 4584              		.cfi_endproc
 4585              	.LFE22:
 4587              		.global	log_gps
 4588              		.global	gps_valid
 4589              		.comm	stringBuf,256,1
 4590              		.comm	fd,4,4
 4591              		.comm	handle,4,4
 4592              		.comm	ADCStringSize,4,4
 4593              		.comm	stringSize,4,4
 4594              		.global	get_frame
 4595              		.global	log_adc
 4596              		.global	ADC_in
 4597              		.global	RX_in
 4598              		.global	log_array2
 4599              		.global	log_array1
 4600              		.comm	ADC_array,512,1
 4601              		.comm	RX_array2,512,1
 4602              		.comm	RX_array1,512,1
 4603              		.section	.rodata.str1.1,"aMS",%progbits,1
 4604              	.LC0:
 4605 0000 256400   		.ascii	"%d\000"
 4606              	.LC1:
 4607 0003 20202000 		.ascii	"   \000"
 4608              	.LC2:
 4609 0007 53442049 		.ascii	"SD Init Error\012\015\000"
 4609      6E697420 
 4609      4572726F 
 4609      720A0D00 
 4610              	.LC3:
 4611 0017 5344204F 		.ascii	"SD OpenRoot Error\012\015\000"
 4611      70656E52 
 4611      6F6F7420 
 4611      4572726F 
 4611      720A0D00 
 4612              	.LC4:
 4613 002b 0A0D4C6F 		.ascii	"\012\015Logomatic V2 Test Code:\012\015\000"
 4613      676F6D61 
 4613      74696320 
 4613      56322054 
 4613      65737420 
 4614              	.LC5:
 4615 0047 41444320 		.ascii	"ADC Test will begin in 5 seconds, hit stop button t"
 4615      54657374 
 4615      2077696C 
 4615      6C206265 
 4615      67696E20 
 4616 007a 6F207465 		.ascii	"o terminate the test.\015\012\012\000"
 4616      726D696E 
 4616      61746520 
 4616      74686520 
 4616      74657374 
 4617              	.LC6:
 4618 0093 0A0D00   		.ascii	"\012\015\000"
 4619              	.LC7:
 4620 0096 0A0D5465 		.ascii	"\012\015Test complete, locking up...\012\015\000"
 4620      73742063 
 4620      6F6D706C 
 4620      6574652C 
 4620      206C6F63 
 4621              	.LC8:
 4622 00b7 4C4F4743 		.ascii	"LOGCON.txt\000"
 4622      4F4E2E74 
 4622      787400
 4623              	.LC9:
 4624 00c2 4572726F 		.ascii	"Error creating LOGCON.txt, locking up...\012\015\000"
 4624      72206372 
 4624      65617469 
 4624      6E67204C 
 4624      4F47434F 
 4625              	.LC10:
 4626 00ed 4D4F4445 		.ascii	"MODE = 0\015\012ASCII = N\015\012Baud = 4\015\012Fr"
 4626      203D2030 
 4626      0D0A4153 
 4626      43494920 
 4626      3D204E0D 
 4627 010e 65717565 		.ascii	"equency = 100\015\012Trigger Character = $\015\012T"
 4627      6E637920 
 4627      3D203130 
 4627      300D0A54 
 4627      72696767 
 4628 0135 65787420 		.ascii	"ext Frame = 100\015\012AD0.3 = N\015\012AD0.2 = N\015"
 4628      4672616D 
 4628      65203D20 
 4628      3130300D 
 4628      0A414430 
 4629 015b 0A414430 		.ascii	"\012AD0.1 = N\015\012AD0.4 = N\015\012AD1.7 = N\015"
 4629      2E31203D 
 4629      204E0D0A 
 4629      4144302E 
 4629      34203D20 
 4630 017c 0A414431 		.ascii	"\012AD1.6 = N\015\012AD1.2 = N\015\012AD1.3 = N\015"
 4630      2E36203D 
 4630      204E0D0A 
 4630      4144312E 
 4630      32203D20 
 4631 019d 0A536166 		.ascii	"\012Saftey On = Y\015\012\000"
 4631      74657920 
 4631      4F6E203D 
 4631      20590D0A 
 4631      00
 4632              	.LC11:
 4633 01ae 6D6F6465 		.ascii	"mode = %d\012\015\000"
 4633      203D2025 
 4633      640A0D00 
 4634              	.LC12:
 4635 01ba 61736320 		.ascii	"asc = %c\012\015\000"
 4635      3D202563 
 4635      0A0D00
 4636              	.LC13:
 4637 01c5 62617564 		.ascii	"baud = %d\012\015\000"
 4637      203D2025 
 4637      640A0D00 
 4638              	.LC14:
 4639 01d1 66726571 		.ascii	"freq = %d\012\015\000"
 4639      203D2025 
 4639      640A0D00 
 4640              	.LC15:
 4641 01dd 74726967 		.ascii	"trig = %c\012\015\000"
 4641      203D2025 
 4641      630A0D00 
 4642              	.LC16:
 4643 01e9 6672616D 		.ascii	"frame = %d\012\015\000"
 4643      65203D20 
 4643      25640A0D 
 4643      00
 4644              	.LC17:
 4645 01f6 6164315F 		.ascii	"ad1_3 = %c\012\015\000"
 4645      33203D20 
 4645      25630A0D 
 4645      00
 4646              	.LC18:
 4647 0203 6164305F 		.ascii	"ad0_3 = %c\012\015\000"
 4647      33203D20 
 4647      25630A0D 
 4647      00
 4648              	.LC19:
 4649 0210 6164305F 		.ascii	"ad0_2 = %c\012\015\000"
 4649      32203D20 
 4649      25630A0D 
 4649      00
 4650              	.LC20:
 4651 021d 6164305F 		.ascii	"ad0_1 = %c\012\015\000"
 4651      31203D20 
 4651      25630A0D 
 4651      00
 4652              	.LC21:
 4653 022a 6164315F 		.ascii	"ad1_2 = %c\012\015\000"
 4653      32203D20 
 4653      25630A0D 
 4653      00
 4654              	.LC22:
 4655 0237 6164305F 		.ascii	"ad0_4 = %c\012\015\000"
 4655      34203D20 
 4655      25630A0D 
 4655      00
 4656              	.LC23:
 4657 0244 6164315F 		.ascii	"ad1_7 = %c\012\015\000"
 4657      37203D20 
 4657      25630A0D 
 4657      00
 4658              	.LC24:
 4659 0251 6164315F 		.ascii	"ad1_6 = %c\012\015\000"
 4659      36203D20 
 4659      25630A0D 
 4659      00
 4660              	.LC25:
 4661 025e 73616665 		.ascii	"safety = %c\012\015\000"
 4661      7479203D 
 4661      2025630A 
 4661      0D00
 4662              	.LC26:
 4663 026c 4D4F4445 		.ascii	"MODE 2\012\015\000"
 4663      20320A0D 
 4663      00
 4664              	.LC27:
 4665 0275 4D4F4445 		.ascii	"MODE 1\012\015\000"
 4665      20310A0D 
 4665      00
 4666              	.LC28:
 4667 027e 4D4F4445 		.ascii	"MODE 0\012\015\000"
 4667      20300A0D 
 4667      00
 4668              	.LC29:
 4669 0287 4C4F4725 		.ascii	"LOG%02d.txt\000"
 4669      3032642E 
 4669      74787400 
 4670              	.LC30:
 4671 0293 546F6F20 		.ascii	"Too Many Logs!\012\015\000"
 4671      4D616E79 
 4671      204C6F67 
 4671      73210A0D 
 4671      00
 4672              		.data
 4673              		.align	2
 4674              		.set	.LANCHOR1,. + 0
 4677              	trig:
 4678 0000 24       		.byte	36
 4679 0001 00       		.space	1
 4682              	frame:
 4683 0002 6400     		.short	100
 4686              	ad1_3:
 4687 0004 4E       		.byte	78
 4690              	asc:
 4691 0005 4E       		.byte	78
 4694              	ad0_3:
 4695 0006 4E       		.byte	78
 4698              	ad0_2:
 4699 0007 4E       		.byte	78
 4702              	ad0_1:
 4703 0008 4E       		.byte	78
 4706              	ad1_2:
 4707 0009 4E       		.byte	78
 4710              	ad0_4:
 4711 000a 4E       		.byte	78
 4714              	ad1_7:
 4715 000b 4E       		.byte	78
 4718              	ad1_6:
 4719 000c 4E       		.byte	78
 4720 000d 000000   		.space	3
 4723              	baud:
 4724 0010 80250000 		.word	9600
 4727              	freq:
 4728 0014 64000000 		.word	100
 4729              		.bss
 4730              		.align	2
 4731              		.set	.LANCHOR0,. + 0
 4734              	RX_in:
 4735 0000 0000     		.space	2
 4738              	log_array1:
 4739 0002 00       		.space	1
 4742              	log_array2:
 4743 0003 00       		.space	1
 4746              	get_frame:
 4747 0004 00       		.space	1
 4750              	mode:
 4751 0005 00       		.space	1
 4754              	ADC_in:
 4755 0006 0000     		.space	2
 4758              	log_adc:
 4759 0008 00       		.space	1
 4760 0009 000000   		.space	3
 4763              	log_gps:
 4764 000c 00000000 		.space	4
 4767              	gps_valid:
 4768 0010 00000000 		.space	4
 4769              		.text
 4770              	.Letext0:
 4771              		.file 2 "/opt/local/lib/gcc/arm-elf/4.7.3/include/stddef.h"
 4772              		.file 3 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/stdint.h"
 4773              		.file 4 "../lib/rprintf.h"
 4774              		.file 5 "../LPCUSB/armVIC.h"
 4775              		.file 6 "../lib/sd_raw.h"
 4776              		.file 7 "../lib/rootdir.h"
 4777              		.file 8 "../lib/itoa.h"
 4778              		.file 9 "../lib/fat.h"
 4779              		.file 10 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:5      .text:0000000000000000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:7      .text:0000000000000000 UART0ISR
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:82     .text:0000000000000090 $d
                            *COM*:0000000000000200 RX_array1
                            *COM*:0000000000000200 RX_array2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:89     .text:00000000000000a0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:91     .text:00000000000000a0 UART0ISR_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:220    .text:00000000000001b8 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:228    .text:00000000000001cc $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:230    .text:00000000000001cc MODE2ISR
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1594   .text:0000000000000dd4 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1612   .text:0000000000000e10 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1615   .text:0000000000000e10 Initialize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1659   .text:0000000000000e68 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1666   .text:0000000000000e78 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1669   .text:0000000000000e78 feed
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1688   .text:0000000000000e90 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1692   .text:0000000000000e94 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1695   .text:0000000000000e94 FIQ_Routine
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1736   .text:0000000000000ebc $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1740   .text:0000000000000ec0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1743   .text:0000000000000ec0 SWI_Routine
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1760   .text:0000000000000ec4 UNDEF_Routine
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1789   .text:0000000000000edc $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1793   .text:0000000000000ee0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1796   .text:0000000000000ee0 setup_uart0
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1978   .text:0000000000001048 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1986   .text:000000000000105c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:1989   .text:000000000000105c stat
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2024   .text:0000000000001088 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2028   .text:000000000000108c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2031   .text:000000000000108c AD_conversion
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2120   .text:0000000000001118 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2128   .text:000000000000112c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2131   .text:000000000000112c fat_initialize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2169   .text:0000000000001160 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2174   .text:0000000000001168 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2177   .text:0000000000001168 delay_ms
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2211   .text:000000000000118c $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2215   .text:0000000000001190 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2218   .text:0000000000001190 test
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2344   .text:000000000000125c $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2361   .text:0000000000001294 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2364   .text:0000000000001294 Log_init
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:2982   .text:00000000000017a8 $d
                            *COM*:0000000000000004 fd
                            *COM*:0000000000000100 stringBuf
                            *COM*:0000000000000004 stringSize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3015   .text:0000000000001820 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3018   .text:0000000000001820 GetADCValue
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3039   .text:0000000000001834 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3049   .text:0000000000001854 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3399   .text:0000000000001b4c $d
                            *COM*:0000000000000200 ADC_array
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3414   .text:0000000000001b7c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3417   .text:0000000000001b7c LogADC
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3586   .text:0000000000001ce4 $d
                            *COM*:0000000000000004 ADCStringSize
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3594   .text:0000000000001cf8 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3597   .text:0000000000001cf8 mode_action
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:3994   .text:0000000000001ed0 $d
                            *COM*:0000000000000004 handle
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4010   .text:0000000000001ef4 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4013   .text:0000000000001ef4 mode_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4081   .text:0000000000001f78 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4089   .text:0000000000001f8c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4092   .text:0000000000001f8c mode_1
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4126   .text:0000000000001fbc $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4132   .text:0000000000001fc8 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4135   .text:0000000000001fc8 mode_0
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4166   .text:0000000000001ff4 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4173   .text.startup:0000000000000000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4176   .text.startup:0000000000000000 main
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4561   .text.startup:00000000000001e8 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4572   .text:0000000000002000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4575   .text:0000000000002000 GetGPSDateTime
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4763   .bss:000000000000000c log_gps
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4767   .bss:0000000000000010 gps_valid
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4746   .bss:0000000000000004 get_frame
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4758   .bss:0000000000000008 log_adc
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4754   .bss:0000000000000006 ADC_in
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4734   .bss:0000000000000000 RX_in
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4742   .bss:0000000000000003 log_array2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4738   .bss:0000000000000002 log_array1
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4673   .data:0000000000000000 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4677   .data:0000000000000000 trig
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4682   .data:0000000000000002 frame
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4686   .data:0000000000000004 ad1_3
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4690   .data:0000000000000005 asc
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4694   .data:0000000000000006 ad0_3
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4698   .data:0000000000000007 ad0_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4702   .data:0000000000000008 ad0_1
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4706   .data:0000000000000009 ad1_2
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4710   .data:000000000000000a ad0_4
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4714   .data:000000000000000b ad1_7
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4718   .data:000000000000000c ad1_6
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4723   .data:0000000000000010 baud
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4727   .data:0000000000000014 freq
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4730   .bss:0000000000000000 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccZVYYqM.s:4750   .bss:0000000000000005 mode
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
itoa
rprintf_devopen
putc_serial0
enableIRQ
rprintf
sd_raw_init
openroot
root_file_exists
root_open
fat_read_file
fat_close_file
root_open_new
strcpy
strlen
fat_write_file
sd_raw_sync
__divsi3
enableFIQ
string_printf
