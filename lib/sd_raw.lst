   1              		.file	"sd_raw.c"
   2              		.text
   3              	.Ltext0:
   4              		.cfi_sections	.debug_frame
   5              		.align	2
   7              	sd_raw_send_byte:
   8              	.LFB3:
   9              		.file 1 "../lib/sd_raw.c"
   1:../lib/sd_raw.c **** 
   2:../lib/sd_raw.c **** /*
   3:../lib/sd_raw.c ****  * Copyright (c) 2006-2011 by Roland Riegel <feedback@roland-riegel.de>
   4:../lib/sd_raw.c ****  *
   5:../lib/sd_raw.c ****  * This file is free software; you can redistribute it and/or modify
   6:../lib/sd_raw.c ****  * it under the terms of either the GNU General Public License version 2
   7:../lib/sd_raw.c ****  * or the GNU Lesser General Public License version 2.1, both as
   8:../lib/sd_raw.c ****  * published by the Free Software Foundation.
   9:../lib/sd_raw.c ****  */
  10:../lib/sd_raw.c **** 
  11:../lib/sd_raw.c **** #include <string.h>
  12:../lib/sd_raw.c **** #include "LPC214x.h"
  13:../lib/sd_raw.c **** #include "sd_raw.h"
  14:../lib/sd_raw.c **** 
  15:../lib/sd_raw.c **** /**
  16:../lib/sd_raw.c ****  * \addtogroup sd_raw MMC/SD/SDHC card raw access
  17:../lib/sd_raw.c ****  *
  18:../lib/sd_raw.c ****  * This module implements read and write access to MMC, SD
  19:../lib/sd_raw.c ****  * and SDHC cards. It serves as a low-level driver for the
  20:../lib/sd_raw.c ****  * higher level modules such as partition and file system
  21:../lib/sd_raw.c ****  * access.
  22:../lib/sd_raw.c ****  *
  23:../lib/sd_raw.c ****  * @{
  24:../lib/sd_raw.c ****  */
  25:../lib/sd_raw.c **** /**
  26:../lib/sd_raw.c ****  * \file
  27:../lib/sd_raw.c ****  * MMC/SD/SDHC raw access implementation (license: GPLv2 or LGPLv2.1)
  28:../lib/sd_raw.c ****  *
  29:../lib/sd_raw.c ****  * \author Roland Riegel
  30:../lib/sd_raw.c ****  */
  31:../lib/sd_raw.c **** 
  32:../lib/sd_raw.c **** /**
  33:../lib/sd_raw.c ****  * \addtogroup sd_raw_config MMC/SD configuration
  34:../lib/sd_raw.c ****  * Preprocessor defines to configure the MMC/SD support.
  35:../lib/sd_raw.c ****  */
  36:../lib/sd_raw.c **** 
  37:../lib/sd_raw.c **** /**
  38:../lib/sd_raw.c ****  * @}
  39:../lib/sd_raw.c ****  */
  40:../lib/sd_raw.c **** 
  41:../lib/sd_raw.c **** /* commands available in SPI mode */
  42:../lib/sd_raw.c **** 
  43:../lib/sd_raw.c **** /* CMD0: response R1 */
  44:../lib/sd_raw.c **** #define CMD_GO_IDLE_STATE 0x00
  45:../lib/sd_raw.c **** /* CMD1: response R1 */
  46:../lib/sd_raw.c **** #define CMD_SEND_OP_COND 0x01
  47:../lib/sd_raw.c **** /* CMD8: response R7 */
  48:../lib/sd_raw.c **** #define CMD_SEND_IF_COND 0x08
  49:../lib/sd_raw.c **** /* CMD9: response R1 */
  50:../lib/sd_raw.c **** #define CMD_SEND_CSD 0x09
  51:../lib/sd_raw.c **** /* CMD10: response R1 */
  52:../lib/sd_raw.c **** #define CMD_SEND_CID 0x0a
  53:../lib/sd_raw.c **** /* CMD12: response R1 */
  54:../lib/sd_raw.c **** #define CMD_STOP_TRANSMISSION 0x0c
  55:../lib/sd_raw.c **** /* CMD13: response R2 */
  56:../lib/sd_raw.c **** #define CMD_SEND_STATUS 0x0d
  57:../lib/sd_raw.c **** /* CMD16: arg0[31:0]: block length, response R1 */
  58:../lib/sd_raw.c **** #define CMD_SET_BLOCKLEN 0x10
  59:../lib/sd_raw.c **** /* CMD17: arg0[31:0]: data address, response R1 */
  60:../lib/sd_raw.c **** #define CMD_READ_SINGLE_BLOCK 0x11
  61:../lib/sd_raw.c **** /* CMD18: arg0[31:0]: data address, response R1 */
  62:../lib/sd_raw.c **** #define CMD_READ_MULTIPLE_BLOCK 0x12
  63:../lib/sd_raw.c **** /* CMD24: arg0[31:0]: data address, response R1 */
  64:../lib/sd_raw.c **** #define CMD_WRITE_SINGLE_BLOCK 0x18
  65:../lib/sd_raw.c **** /* CMD25: arg0[31:0]: data address, response R1 */
  66:../lib/sd_raw.c **** #define CMD_WRITE_MULTIPLE_BLOCK 0x19
  67:../lib/sd_raw.c **** /* CMD27: response R1 */
  68:../lib/sd_raw.c **** #define CMD_PROGRAM_CSD 0x1b
  69:../lib/sd_raw.c **** /* CMD28: arg0[31:0]: data address, response R1b */
  70:../lib/sd_raw.c **** #define CMD_SET_WRITE_PROT 0x1c
  71:../lib/sd_raw.c **** /* CMD29: arg0[31:0]: data address, response R1b */
  72:../lib/sd_raw.c **** #define CMD_CLR_WRITE_PROT 0x1d
  73:../lib/sd_raw.c **** /* CMD30: arg0[31:0]: write protect data address, response R1 */
  74:../lib/sd_raw.c **** #define CMD_SEND_WRITE_PROT 0x1e
  75:../lib/sd_raw.c **** /* CMD32: arg0[31:0]: data address, response R1 */
  76:../lib/sd_raw.c **** #define CMD_TAG_SECTOR_START 0x20
  77:../lib/sd_raw.c **** /* CMD33: arg0[31:0]: data address, response R1 */
  78:../lib/sd_raw.c **** #define CMD_TAG_SECTOR_END 0x21
  79:../lib/sd_raw.c **** /* CMD34: arg0[31:0]: data address, response R1 */
  80:../lib/sd_raw.c **** #define CMD_UNTAG_SECTOR 0x22
  81:../lib/sd_raw.c **** /* CMD35: arg0[31:0]: data address, response R1 */
  82:../lib/sd_raw.c **** #define CMD_TAG_ERASE_GROUP_START 0x23
  83:../lib/sd_raw.c **** /* CMD36: arg0[31:0]: data address, response R1 */
  84:../lib/sd_raw.c **** #define CMD_TAG_ERASE_GROUP_END 0x24
  85:../lib/sd_raw.c **** /* CMD37: arg0[31:0]: data address, response R1 */
  86:../lib/sd_raw.c **** #define CMD_UNTAG_ERASE_GROUP 0x25
  87:../lib/sd_raw.c **** /* CMD38: arg0[31:0]: stuff bits, response R1b */
  88:../lib/sd_raw.c **** #define CMD_ERASE 0x26
  89:../lib/sd_raw.c **** /* ACMD41: arg0[31:0]: OCR contents, response R1 */
  90:../lib/sd_raw.c **** #define CMD_SD_SEND_OP_COND 0x29
  91:../lib/sd_raw.c **** /* CMD42: arg0[31:0]: stuff bits, response R1b */
  92:../lib/sd_raw.c **** #define CMD_LOCK_UNLOCK 0x2a
  93:../lib/sd_raw.c **** /* CMD55: arg0[31:0]: stuff bits, response R1 */
  94:../lib/sd_raw.c **** #define CMD_APP 0x37
  95:../lib/sd_raw.c **** /* CMD58: arg0[31:0]: stuff bits, response R3 */
  96:../lib/sd_raw.c **** #define CMD_READ_OCR 0x3a
  97:../lib/sd_raw.c **** /* CMD59: arg0[31:1]: stuff bits, arg0[0:0]: crc option, response R1 */
  98:../lib/sd_raw.c **** #define CMD_CRC_ON_OFF 0x3b
  99:../lib/sd_raw.c **** 
 100:../lib/sd_raw.c **** /* command responses */
 101:../lib/sd_raw.c **** /* R1: size 1 byte */
 102:../lib/sd_raw.c **** #define R1_IDLE_STATE 0
 103:../lib/sd_raw.c **** #define R1_ERASE_RESET 1
 104:../lib/sd_raw.c **** #define R1_ILL_COMMAND 2
 105:../lib/sd_raw.c **** #define R1_COM_CRC_ERR 3
 106:../lib/sd_raw.c **** #define R1_ERASE_SEQ_ERR 4
 107:../lib/sd_raw.c **** #define R1_ADDR_ERR 5
 108:../lib/sd_raw.c **** #define R1_PARAM_ERR 6
 109:../lib/sd_raw.c **** /* R1b: equals R1, additional busy bytes */
 110:../lib/sd_raw.c **** /* R2: size 2 bytes */
 111:../lib/sd_raw.c **** #define R2_CARD_LOCKED 0
 112:../lib/sd_raw.c **** #define R2_WP_ERASE_SKIP 1
 113:../lib/sd_raw.c **** #define R2_ERR 2
 114:../lib/sd_raw.c **** #define R2_CARD_ERR 3
 115:../lib/sd_raw.c **** #define R2_CARD_ECC_FAIL 4
 116:../lib/sd_raw.c **** #define R2_WP_VIOLATION 5
 117:../lib/sd_raw.c **** #define R2_INVAL_ERASE 6
 118:../lib/sd_raw.c **** #define R2_OUT_OF_RANGE 7
 119:../lib/sd_raw.c **** #define R2_CSD_OVERWRITE 7
 120:../lib/sd_raw.c **** #define R2_IDLE_STATE (R1_IDLE_STATE + 8)
 121:../lib/sd_raw.c **** #define R2_ERASE_RESET (R1_ERASE_RESET + 8)
 122:../lib/sd_raw.c **** #define R2_ILL_COMMAND (R1_ILL_COMMAND + 8)
 123:../lib/sd_raw.c **** #define R2_COM_CRC_ERR (R1_COM_CRC_ERR + 8)
 124:../lib/sd_raw.c **** #define R2_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 8)
 125:../lib/sd_raw.c **** #define R2_ADDR_ERR (R1_ADDR_ERR + 8)
 126:../lib/sd_raw.c **** #define R2_PARAM_ERR (R1_PARAM_ERR + 8)
 127:../lib/sd_raw.c **** /* R3: size 5 bytes */
 128:../lib/sd_raw.c **** #define R3_OCR_MASK (0xffffffffUL)
 129:../lib/sd_raw.c **** #define R3_IDLE_STATE (R1_IDLE_STATE + 32)
 130:../lib/sd_raw.c **** #define R3_ERASE_RESET (R1_ERASE_RESET + 32)
 131:../lib/sd_raw.c **** #define R3_ILL_COMMAND (R1_ILL_COMMAND + 32)
 132:../lib/sd_raw.c **** #define R3_COM_CRC_ERR (R1_COM_CRC_ERR + 32)
 133:../lib/sd_raw.c **** #define R3_ERASE_SEQ_ERR (R1_ERASE_SEQ_ERR + 32)
 134:../lib/sd_raw.c **** #define R3_ADDR_ERR (R1_ADDR_ERR + 32)
 135:../lib/sd_raw.c **** #define R3_PARAM_ERR (R1_PARAM_ERR + 32)
 136:../lib/sd_raw.c **** /* Data Response: size 1 byte */
 137:../lib/sd_raw.c **** #define DR_STATUS_MASK 0x0e
 138:../lib/sd_raw.c **** #define DR_STATUS_ACCEPTED 0x05
 139:../lib/sd_raw.c **** #define DR_STATUS_CRC_ERR 0x0a
 140:../lib/sd_raw.c **** #define DR_STATUS_WRITE_ERR 0x0c
 141:../lib/sd_raw.c **** 
 142:../lib/sd_raw.c **** /* status bits for card types */
 143:../lib/sd_raw.c **** #define SD_RAW_SPEC_1 0
 144:../lib/sd_raw.c **** #define SD_RAW_SPEC_2 1
 145:../lib/sd_raw.c **** #define SD_RAW_SPEC_SDHC 2
 146:../lib/sd_raw.c **** 
 147:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 148:../lib/sd_raw.c **** /* static data buffer for acceleration */
 149:../lib/sd_raw.c **** static uint8_t raw_block[512];
 150:../lib/sd_raw.c **** /* offset where the data within raw_block lies on the card */
 151:../lib/sd_raw.c **** static offset_t raw_block_address;
 152:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 153:../lib/sd_raw.c **** /* flag to remember if raw_block was written to the card */
 154:../lib/sd_raw.c **** static uint8_t raw_block_written;
 155:../lib/sd_raw.c **** #endif
 156:../lib/sd_raw.c **** #endif
 157:../lib/sd_raw.c **** 
 158:../lib/sd_raw.c **** /* card type state */
 159:../lib/sd_raw.c **** static uint8_t sd_raw_card_type;
 160:../lib/sd_raw.c **** 
 161:../lib/sd_raw.c **** /* private helper functions */
 162:../lib/sd_raw.c **** static void sd_raw_send_byte(uint8_t b);
 163:../lib/sd_raw.c **** static uint8_t sd_raw_rec_byte(void);
 164:../lib/sd_raw.c **** static uint8_t sd_raw_send_command(uint8_t command, uint32_t arg);
 165:../lib/sd_raw.c **** 
 166:../lib/sd_raw.c **** /**
 167:../lib/sd_raw.c ****  * \ingroup sd_raw
 168:../lib/sd_raw.c ****  * Initializes memory card communication.
 169:../lib/sd_raw.c ****  *
 170:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 171:../lib/sd_raw.c ****  */
 172:../lib/sd_raw.c **** uint8_t sd_raw_init()
 173:../lib/sd_raw.c **** {
 174:../lib/sd_raw.c ****     /* enable inputs for reading card status */
 175:../lib/sd_raw.c ****     configure_pin_available();
 176:../lib/sd_raw.c ****     configure_pin_locked();
 177:../lib/sd_raw.c **** 
 178:../lib/sd_raw.c ****     /* enable outputs for MOSI, SCK, SS, input for MISO */
 179:../lib/sd_raw.c ****     configure_pin_mosi();
 180:../lib/sd_raw.c ****     configure_pin_sck();
 181:../lib/sd_raw.c ****     configure_pin_ss();
 182:../lib/sd_raw.c ****     configure_pin_miso();
 183:../lib/sd_raw.c **** 
 184:../lib/sd_raw.c ****     unselect_card();
 185:../lib/sd_raw.c **** 
 186:../lib/sd_raw.c ****     /* initialize SPI with lowest frequency; max. 400kHz during identification mode of card */
 187:../lib/sd_raw.c ****     S0SPCCR = 150;  /* Set frequency to 400kHz */
 188:../lib/sd_raw.c ****     S0SPCR = 0x38;
 189:../lib/sd_raw.c **** 
 190:../lib/sd_raw.c ****     /* initialization procedure */
 191:../lib/sd_raw.c ****     sd_raw_card_type = 0;
 192:../lib/sd_raw.c ****     
 193:../lib/sd_raw.c ****     if(!sd_raw_available())
 194:../lib/sd_raw.c ****         return 0;
 195:../lib/sd_raw.c **** 
 196:../lib/sd_raw.c ****     /* card needs 74 cycles minimum to start up */
 197:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 10; ++i)
 198:../lib/sd_raw.c ****     {
 199:../lib/sd_raw.c ****         /* wait 8 clock cycles */
 200:../lib/sd_raw.c ****         sd_raw_rec_byte();
 201:../lib/sd_raw.c ****     }
 202:../lib/sd_raw.c **** 
 203:../lib/sd_raw.c ****     /* address card */
 204:../lib/sd_raw.c ****     select_card();
 205:../lib/sd_raw.c **** 
 206:../lib/sd_raw.c ****     /* reset card */
 207:../lib/sd_raw.c ****     uint8_t response;
 208:../lib/sd_raw.c ****     for(uint16_t i = 0; ; ++i)
 209:../lib/sd_raw.c ****     {
 210:../lib/sd_raw.c ****         response = sd_raw_send_command(CMD_GO_IDLE_STATE, 0);
 211:../lib/sd_raw.c ****         if(response == (1 << R1_IDLE_STATE))
 212:../lib/sd_raw.c ****             break;
 213:../lib/sd_raw.c **** 
 214:../lib/sd_raw.c ****         if(i == 0x1ff)
 215:../lib/sd_raw.c ****         {
 216:../lib/sd_raw.c ****             unselect_card();
 217:../lib/sd_raw.c ****             return 0;
 218:../lib/sd_raw.c ****         }
 219:../lib/sd_raw.c ****     }
 220:../lib/sd_raw.c **** 
 221:../lib/sd_raw.c **** #if SD_RAW_SDHC
 222:../lib/sd_raw.c ****     /* check for version of SD card specification */
 223:../lib/sd_raw.c ****     response = sd_raw_send_command(CMD_SEND_IF_COND, 0x100 /* 2.7V - 3.6V */ | 0xaa /* test pattern
 224:../lib/sd_raw.c ****     if((response & (1 << R1_ILL_COMMAND)) == 0)
 225:../lib/sd_raw.c ****     {
 226:../lib/sd_raw.c ****         sd_raw_rec_byte();
 227:../lib/sd_raw.c ****         sd_raw_rec_byte();
 228:../lib/sd_raw.c ****         if((sd_raw_rec_byte() & 0x01) == 0)
 229:../lib/sd_raw.c ****             return 0; /* card operation voltage range doesn't match */
 230:../lib/sd_raw.c ****         if(sd_raw_rec_byte() != 0xaa)
 231:../lib/sd_raw.c ****             return 0; /* wrong test pattern */
 232:../lib/sd_raw.c **** 
 233:../lib/sd_raw.c ****         /* card conforms to SD 2 card specification */
 234:../lib/sd_raw.c ****         sd_raw_card_type |= (1 << SD_RAW_SPEC_2);
 235:../lib/sd_raw.c ****     }
 236:../lib/sd_raw.c ****     else
 237:../lib/sd_raw.c **** #endif
 238:../lib/sd_raw.c ****     {
 239:../lib/sd_raw.c ****         /* determine SD/MMC card type */
 240:../lib/sd_raw.c ****         sd_raw_send_command(CMD_APP, 0);
 241:../lib/sd_raw.c ****         response = sd_raw_send_command(CMD_SD_SEND_OP_COND, 0);
 242:../lib/sd_raw.c ****         if((response & (1 << R1_ILL_COMMAND)) == 0)
 243:../lib/sd_raw.c ****         {
 244:../lib/sd_raw.c ****             /* card conforms to SD 1 card specification */
 245:../lib/sd_raw.c ****             sd_raw_card_type |= (1 << SD_RAW_SPEC_1);
 246:../lib/sd_raw.c ****         }
 247:../lib/sd_raw.c ****         else
 248:../lib/sd_raw.c ****         {
 249:../lib/sd_raw.c ****             /* MMC card */
 250:../lib/sd_raw.c ****         }
 251:../lib/sd_raw.c ****     }
 252:../lib/sd_raw.c **** 
 253:../lib/sd_raw.c ****     /* wait for card to get ready */
 254:../lib/sd_raw.c ****     for(uint16_t i = 0; ; ++i)
 255:../lib/sd_raw.c ****     {
 256:../lib/sd_raw.c ****         if(sd_raw_card_type & ((1 << SD_RAW_SPEC_1) | (1 << SD_RAW_SPEC_2)))
 257:../lib/sd_raw.c ****         {
 258:../lib/sd_raw.c ****             uint32_t arg = 0;
 259:../lib/sd_raw.c **** #if SD_RAW_SDHC
 260:../lib/sd_raw.c ****             if(sd_raw_card_type & (1 << SD_RAW_SPEC_2))
 261:../lib/sd_raw.c ****                 arg = 0x40000000;
 262:../lib/sd_raw.c **** #endif
 263:../lib/sd_raw.c ****             sd_raw_send_command(CMD_APP, 0);
 264:../lib/sd_raw.c ****             response = sd_raw_send_command(CMD_SD_SEND_OP_COND, arg);
 265:../lib/sd_raw.c ****         }
 266:../lib/sd_raw.c ****         else
 267:../lib/sd_raw.c ****         {
 268:../lib/sd_raw.c ****             response = sd_raw_send_command(CMD_SEND_OP_COND, 0);
 269:../lib/sd_raw.c ****         }
 270:../lib/sd_raw.c **** 
 271:../lib/sd_raw.c ****         if((response & (1 << R1_IDLE_STATE)) == 0)
 272:../lib/sd_raw.c ****             break;
 273:../lib/sd_raw.c **** 
 274:../lib/sd_raw.c ****         if(i == 0x7fff)
 275:../lib/sd_raw.c ****         {
 276:../lib/sd_raw.c ****             unselect_card();
 277:../lib/sd_raw.c ****             return 0;
 278:../lib/sd_raw.c ****         }
 279:../lib/sd_raw.c ****     }
 280:../lib/sd_raw.c **** 
 281:../lib/sd_raw.c **** #if SD_RAW_SDHC
 282:../lib/sd_raw.c ****     if(sd_raw_card_type & (1 << SD_RAW_SPEC_2))
 283:../lib/sd_raw.c ****     {
 284:../lib/sd_raw.c ****         if(sd_raw_send_command(CMD_READ_OCR, 0))
 285:../lib/sd_raw.c ****         {
 286:../lib/sd_raw.c ****             unselect_card();
 287:../lib/sd_raw.c ****             return 0;
 288:../lib/sd_raw.c ****         }
 289:../lib/sd_raw.c **** 
 290:../lib/sd_raw.c ****         if(sd_raw_rec_byte() & 0x40)
 291:../lib/sd_raw.c ****             sd_raw_card_type |= (1 << SD_RAW_SPEC_SDHC);
 292:../lib/sd_raw.c **** 
 293:../lib/sd_raw.c ****         sd_raw_rec_byte();
 294:../lib/sd_raw.c ****         sd_raw_rec_byte();
 295:../lib/sd_raw.c ****         sd_raw_rec_byte();
 296:../lib/sd_raw.c ****     }
 297:../lib/sd_raw.c **** #endif
 298:../lib/sd_raw.c **** 
 299:../lib/sd_raw.c ****     /* set block size to 512 bytes */
 300:../lib/sd_raw.c ****     if(sd_raw_send_command(CMD_SET_BLOCKLEN, 512))
 301:../lib/sd_raw.c ****     {
 302:../lib/sd_raw.c ****         unselect_card();
 303:../lib/sd_raw.c ****         return 0;
 304:../lib/sd_raw.c ****     }
 305:../lib/sd_raw.c **** 
 306:../lib/sd_raw.c ****     /* deaddress card */
 307:../lib/sd_raw.c ****     unselect_card();
 308:../lib/sd_raw.c **** 
 309:../lib/sd_raw.c ****     /* switch to highest SPI frequency possible */
 310:../lib/sd_raw.c ****     S0SPCCR = 60; /* ~1MHz-- potentially can be faster */
 311:../lib/sd_raw.c **** 
 312:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 313:../lib/sd_raw.c ****     /* the first block is likely to be accessed first, so precache it here */
 314:../lib/sd_raw.c ****     raw_block_address = (offset_t) -1;
 315:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 316:../lib/sd_raw.c ****     raw_block_written = 1;
 317:../lib/sd_raw.c **** #endif
 318:../lib/sd_raw.c ****     if(!sd_raw_read(0, raw_block, sizeof(raw_block)))
 319:../lib/sd_raw.c ****         return 0;
 320:../lib/sd_raw.c **** #endif
 321:../lib/sd_raw.c **** 
 322:../lib/sd_raw.c ****     return 1;
 323:../lib/sd_raw.c **** }
 324:../lib/sd_raw.c **** 
 325:../lib/sd_raw.c **** /**
 326:../lib/sd_raw.c ****  * \ingroup sd_raw
 327:../lib/sd_raw.c ****  * Checks wether a memory card is located in the slot.
 328:../lib/sd_raw.c ****  *
 329:../lib/sd_raw.c ****  * \returns 1 if the card is available, 0 if it is not.
 330:../lib/sd_raw.c ****  */
 331:../lib/sd_raw.c **** uint8_t sd_raw_available()
 332:../lib/sd_raw.c **** {
 333:../lib/sd_raw.c ****     return get_pin_available() == 0x00;
 334:../lib/sd_raw.c **** }
 335:../lib/sd_raw.c **** 
 336:../lib/sd_raw.c **** /**
 337:../lib/sd_raw.c ****  * \ingroup sd_raw
 338:../lib/sd_raw.c ****  * Checks wether the memory card is locked for write access.
 339:../lib/sd_raw.c ****  *
 340:../lib/sd_raw.c ****  * \returns 1 if the card is locked, 0 if it is not.
 341:../lib/sd_raw.c ****  */
 342:../lib/sd_raw.c **** uint8_t sd_raw_locked()
 343:../lib/sd_raw.c **** {
 344:../lib/sd_raw.c ****     return get_pin_locked() == 0x00;
 345:../lib/sd_raw.c **** }
 346:../lib/sd_raw.c **** 
 347:../lib/sd_raw.c **** /**
 348:../lib/sd_raw.c ****  * \ingroup sd_raw
 349:../lib/sd_raw.c ****  * Sends a raw byte to the memory card.
 350:../lib/sd_raw.c ****  *
 351:../lib/sd_raw.c ****  * \param[in] b The byte to sent.
 352:../lib/sd_raw.c ****  * \see sd_raw_rec_byte
 353:../lib/sd_raw.c ****  */
 354:../lib/sd_raw.c **** void sd_raw_send_byte(uint8_t b)
 355:../lib/sd_raw.c **** {
  10              		.loc 1 355 0
  11              		.cfi_startproc
  12              		@ Function supports interworking.
  13              		@ args = 0, pretend = 0, frame = 0
  14              		@ frame_needed = 0, uses_anonymous_args = 0
  15              		@ link register save eliminated.
  16              	.LVL0:
 356:../lib/sd_raw.c ****     S0SPDR = b;
  17              		.loc 1 356 0
  18 0000 10309FE5 		ldr	r3, .L7
  19 0004 080083E5 		str	r0, [r3, #8]
  20              	.L2:
 357:../lib/sd_raw.c ****     /* wait for byte to be shifted out */
 358:../lib/sd_raw.c ****     while(!(S0SPSR & 0x80));
  21              		.loc 1 358 0 discriminator 1
  22 0008 042093E5 		ldr	r2, [r3, #4]
  23 000c 800012E3 		tst	r2, #128
  24 0010 FCFFFF0A 		beq	.L2
 359:../lib/sd_raw.c **** }
  25              		.loc 1 359 0
  26 0014 1EFF2FE1 		bx	lr
  27              	.L8:
  28              		.align	2
  29              	.L7:
  30 0018 000002E0 		.word	-536739840
  31              		.cfi_endproc
  32              	.LFE3:
  34              		.align	2
  36              	sd_raw_rec_byte:
  37              	.LFB4:
 360:../lib/sd_raw.c **** 
 361:../lib/sd_raw.c **** /**
 362:../lib/sd_raw.c ****  * \ingroup sd_raw
 363:../lib/sd_raw.c ****  * Receives a raw byte from the memory card.
 364:../lib/sd_raw.c ****  *
 365:../lib/sd_raw.c ****  * \returns The byte which should be read.
 366:../lib/sd_raw.c ****  * \see sd_raw_send_byte
 367:../lib/sd_raw.c ****  */
 368:../lib/sd_raw.c **** uint8_t sd_raw_rec_byte(void)
 369:../lib/sd_raw.c **** {
  38              		.loc 1 369 0
  39              		.cfi_startproc
  40              		@ Function supports interworking.
  41              		@ args = 0, pretend = 0, frame = 0
  42              		@ frame_needed = 0, uses_anonymous_args = 0
  43              		@ link register save eliminated.
 370:../lib/sd_raw.c ****     /* send dummy data for receiving some */
 371:../lib/sd_raw.c ****     S0SPDR = 0xff;
  44              		.loc 1 371 0
  45 001c 20309FE5 		ldr	r3, .L15
  46 0020 FF20A0E3 		mov	r2, #255
  47 0024 082083E5 		str	r2, [r3, #8]
  48              	.L10:
 372:../lib/sd_raw.c ****     while(!(S0SPSR & 0x80));
  49              		.loc 1 372 0 discriminator 1
  50 0028 042093E5 		ldr	r2, [r3, #4]
  51 002c 800012E3 		tst	r2, #128
  52 0030 FCFFFF0A 		beq	.L10
 373:../lib/sd_raw.c **** 
 374:../lib/sd_raw.c ****     return S0SPDR;
  53              		.loc 1 374 0
  54 0034 08309FE5 		ldr	r3, .L15
  55 0038 080093E5 		ldr	r0, [r3, #8]
  56 003c FF0000E2 		and	r0, r0, #255
 375:../lib/sd_raw.c **** }
  57              		.loc 1 375 0
  58 0040 1EFF2FE1 		bx	lr
  59              	.L16:
  60              		.align	2
  61              	.L15:
  62 0044 000002E0 		.word	-536739840
  63              		.cfi_endproc
  64              	.LFE4:
  66              		.align	2
  68              	sd_raw_send_command:
  69              	.LFB5:
 376:../lib/sd_raw.c **** 
 377:../lib/sd_raw.c **** /**
 378:../lib/sd_raw.c ****  * \ingroup sd_raw
 379:../lib/sd_raw.c ****  * Send a command to the memory card which responses with a R1 response (and possibly others).
 380:../lib/sd_raw.c ****  *
 381:../lib/sd_raw.c ****  * \param[in] command The command to send.
 382:../lib/sd_raw.c ****  * \param[in] arg The argument for command.
 383:../lib/sd_raw.c ****  * \returns The command answer.
 384:../lib/sd_raw.c ****  */
 385:../lib/sd_raw.c **** uint8_t sd_raw_send_command(uint8_t command, uint32_t arg)
 386:../lib/sd_raw.c **** {
  70              		.loc 1 386 0
  71              		.cfi_startproc
  72              		@ Function supports interworking.
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              	.LVL1:
  76 0048 30402DE9 		stmfd	sp!, {r4, r5, lr}
  77              	.LCFI0:
  78              		.cfi_def_cfa_offset 12
  79              		.cfi_offset 4, -12
  80              		.cfi_offset 5, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 386 0
  83 004c 0050A0E1 		mov	r5, r0
  84 0050 0140A0E1 		mov	r4, r1
 387:../lib/sd_raw.c ****     uint8_t response;
 388:../lib/sd_raw.c **** 
 389:../lib/sd_raw.c ****     /* wait some clock cycles */
 390:../lib/sd_raw.c ****     sd_raw_rec_byte();
  85              		.loc 1 390 0
  86 0054 F0FFFFEB 		bl	sd_raw_rec_byte
  87              	.LVL2:
 391:../lib/sd_raw.c **** 
 392:../lib/sd_raw.c ****     /* send command via SPI */
 393:../lib/sd_raw.c ****     sd_raw_send_byte(0x40 | command);
  88              		.loc 1 393 0
  89 0058 400085E3 		orr	r0, r5, #64
  90 005c E7FFFFEB 		bl	sd_raw_send_byte
  91              	.LVL3:
 394:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 24) & 0xff);
  92              		.loc 1 394 0
  93 0060 240CA0E1 		mov	r0, r4, lsr #24
  94 0064 E5FFFFEB 		bl	sd_raw_send_byte
  95              	.LVL4:
 395:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 16) & 0xff);
 396:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 8) & 0xff);
 397:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 0) & 0xff);
 398:../lib/sd_raw.c ****     switch(command)
 399:../lib/sd_raw.c ****     {
 400:../lib/sd_raw.c ****         case CMD_GO_IDLE_STATE:
 401:../lib/sd_raw.c ****            sd_raw_send_byte(0x95);
 402:../lib/sd_raw.c ****            break;
 403:../lib/sd_raw.c ****         case CMD_SEND_IF_COND:
 404:../lib/sd_raw.c ****            sd_raw_send_byte(0x87);
 405:../lib/sd_raw.c ****            break;
 406:../lib/sd_raw.c ****         default:
 407:../lib/sd_raw.c ****            sd_raw_send_byte(0xff);
 408:../lib/sd_raw.c ****            break;
 409:../lib/sd_raw.c ****     }
 410:../lib/sd_raw.c ****     
 411:../lib/sd_raw.c ****     /* receive response */
 412:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 10; ++i)
 413:../lib/sd_raw.c ****     {
 414:../lib/sd_raw.c ****         response = sd_raw_rec_byte();
 415:../lib/sd_raw.c ****         if(response != 0xff)
 416:../lib/sd_raw.c ****             break;
 417:../lib/sd_raw.c ****     }
 418:../lib/sd_raw.c **** 
 419:../lib/sd_raw.c ****     return response;
 420:../lib/sd_raw.c **** }
 421:../lib/sd_raw.c **** 
 422:../lib/sd_raw.c **** /**
 423:../lib/sd_raw.c ****  * \ingroup sd_raw
 424:../lib/sd_raw.c ****  * Reads raw data from the card.
 425:../lib/sd_raw.c ****  *
 426:../lib/sd_raw.c ****  * \param[in] offset The offset from which to read.
 427:../lib/sd_raw.c ****  * \param[out] buffer The buffer into which to write the data.
 428:../lib/sd_raw.c ****  * \param[in] length The number of bytes to read.
 429:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 430:../lib/sd_raw.c ****  * \see sd_raw_read_interval, sd_raw_write, sd_raw_write_interval
 431:../lib/sd_raw.c ****  */
 432:../lib/sd_raw.c **** uint8_t sd_raw_read(offset_t offset, uint8_t* buffer, uintptr_t length)
 433:../lib/sd_raw.c **** {
 434:../lib/sd_raw.c ****     offset_t block_address;
 435:../lib/sd_raw.c ****     uint16_t block_offset;
 436:../lib/sd_raw.c ****     uint16_t read_length;
 437:../lib/sd_raw.c ****     while(length > 0)
 438:../lib/sd_raw.c ****     {
 439:../lib/sd_raw.c ****         /* determine byte count to read at once */
 440:../lib/sd_raw.c ****         block_offset = offset & 0x01ff;
 441:../lib/sd_raw.c ****         block_address = offset - block_offset;
 442:../lib/sd_raw.c ****         read_length = 512 - block_offset; /* read up to block border */
 443:../lib/sd_raw.c ****         if(read_length > length)
 444:../lib/sd_raw.c ****             read_length = length;
 445:../lib/sd_raw.c ****         
 446:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 447:../lib/sd_raw.c ****         /* check if the requested data is cached */
 448:../lib/sd_raw.c ****         if(block_address != raw_block_address)
 449:../lib/sd_raw.c **** #endif
 450:../lib/sd_raw.c ****         {
 451:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 452:../lib/sd_raw.c ****             if(!sd_raw_sync())
 453:../lib/sd_raw.c ****                 return 0;
 454:../lib/sd_raw.c **** #endif
 455:../lib/sd_raw.c **** 
 456:../lib/sd_raw.c ****             /* address card */
 457:../lib/sd_raw.c ****             select_card();
 458:../lib/sd_raw.c **** 
 459:../lib/sd_raw.c ****             /* send single block request */
 460:../lib/sd_raw.c **** #if SD_RAW_SDHC
 461:../lib/sd_raw.c ****             if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDH
 462:../lib/sd_raw.c **** #else
 463:../lib/sd_raw.c ****             if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, block_address))
 464:../lib/sd_raw.c **** #endif
 465:../lib/sd_raw.c ****             {
 466:../lib/sd_raw.c ****                 unselect_card();
 467:../lib/sd_raw.c ****                 return 0;
 468:../lib/sd_raw.c ****             }
 469:../lib/sd_raw.c **** 
 470:../lib/sd_raw.c ****             /* wait for data block (start byte 0xfe) */
 471:../lib/sd_raw.c ****             while(sd_raw_rec_byte() != 0xfe);
 472:../lib/sd_raw.c **** 
 473:../lib/sd_raw.c **** #if SD_RAW_SAVE_RAM
 474:../lib/sd_raw.c ****             /* read byte block */
 475:../lib/sd_raw.c ****             uint16_t read_to = block_offset + read_length;
 476:../lib/sd_raw.c ****             for(uint16_t i = 0; i < 512; ++i)
 477:../lib/sd_raw.c ****             {
 478:../lib/sd_raw.c ****                 uint8_t b = sd_raw_rec_byte();
 479:../lib/sd_raw.c ****                 if(i >= block_offset && i < read_to)
 480:../lib/sd_raw.c ****                     *buffer++ = b;
 481:../lib/sd_raw.c ****             }
 482:../lib/sd_raw.c **** #else
 483:../lib/sd_raw.c ****             /* read byte block */
 484:../lib/sd_raw.c ****             uint8_t* cache = raw_block;
 485:../lib/sd_raw.c ****             for(uint16_t i = 0; i < 512; ++i)
 486:../lib/sd_raw.c ****                 *cache++ = sd_raw_rec_byte();
 487:../lib/sd_raw.c ****             raw_block_address = block_address;
 488:../lib/sd_raw.c **** 
 489:../lib/sd_raw.c ****             memcpy(buffer, raw_block + block_offset, read_length);
 490:../lib/sd_raw.c ****             buffer += read_length;
 491:../lib/sd_raw.c **** #endif
 492:../lib/sd_raw.c ****             
 493:../lib/sd_raw.c ****             /* read crc16 */
 494:../lib/sd_raw.c ****             sd_raw_rec_byte();
 495:../lib/sd_raw.c ****             sd_raw_rec_byte();
 496:../lib/sd_raw.c ****             
 497:../lib/sd_raw.c ****             /* deaddress card */
 498:../lib/sd_raw.c ****             unselect_card();
 499:../lib/sd_raw.c **** 
 500:../lib/sd_raw.c ****             /* let card some time to finish */
 501:../lib/sd_raw.c ****             sd_raw_rec_byte();
 502:../lib/sd_raw.c ****         }
 503:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 504:../lib/sd_raw.c ****         else
 505:../lib/sd_raw.c ****         {
 506:../lib/sd_raw.c ****             /* use cached data */
 507:../lib/sd_raw.c ****             memcpy(buffer, raw_block + block_offset, read_length);
 508:../lib/sd_raw.c ****             buffer += read_length;
 509:../lib/sd_raw.c ****         }
 510:../lib/sd_raw.c **** #endif
 511:../lib/sd_raw.c **** 
 512:../lib/sd_raw.c ****         length -= read_length;
 513:../lib/sd_raw.c ****         offset += read_length;
 514:../lib/sd_raw.c ****     }
 515:../lib/sd_raw.c **** 
 516:../lib/sd_raw.c ****     return 1;
 517:../lib/sd_raw.c **** }
 518:../lib/sd_raw.c **** 
 519:../lib/sd_raw.c **** /**
 520:../lib/sd_raw.c ****  * \ingroup sd_raw
 521:../lib/sd_raw.c ****  * Continuously reads units of \c interval bytes and calls a callback function.
 522:../lib/sd_raw.c ****  *
 523:../lib/sd_raw.c ****  * This function starts reading at the specified offset. Every \c interval bytes,
 524:../lib/sd_raw.c ****  * it calls the callback function with the associated data buffer.
 525:../lib/sd_raw.c ****  *
 526:../lib/sd_raw.c ****  * By returning zero, the callback may stop reading.
 527:../lib/sd_raw.c ****  *
 528:../lib/sd_raw.c ****  * \note Within the callback function, you can not start another read or
 529:../lib/sd_raw.c ****  *       write operation.
 530:../lib/sd_raw.c ****  * \note This function only works if the following conditions are met:
 531:../lib/sd_raw.c ****  *       - (offset - (offset % 512)) % interval == 0
 532:../lib/sd_raw.c ****  *       - length % interval == 0
 533:../lib/sd_raw.c ****  *
 534:../lib/sd_raw.c ****  * \param[in] offset Offset from which to start reading.
 535:../lib/sd_raw.c ****  * \param[in] buffer Pointer to a buffer which is at least interval bytes in size.
 536:../lib/sd_raw.c ****  * \param[in] interval Number of bytes to read before calling the callback function.
 537:../lib/sd_raw.c ****  * \param[in] length Number of bytes to read altogether.
 538:../lib/sd_raw.c ****  * \param[in] callback The function to call every interval bytes.
 539:../lib/sd_raw.c ****  * \param[in] p An opaque pointer directly passed to the callback function.
 540:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success
 541:../lib/sd_raw.c ****  * \see sd_raw_write_interval, sd_raw_read, sd_raw_write
 542:../lib/sd_raw.c ****  */
 543:../lib/sd_raw.c **** uint8_t sd_raw_read_interval(offset_t offset, uint8_t* buffer, uintptr_t interval, uintptr_t length
 544:../lib/sd_raw.c **** {
 545:../lib/sd_raw.c ****     if(!buffer || interval == 0 || length < interval || !callback)
 546:../lib/sd_raw.c ****         return 0;
 547:../lib/sd_raw.c **** 
 548:../lib/sd_raw.c **** #if !SD_RAW_SAVE_RAM
 549:../lib/sd_raw.c ****     while(length >= interval)
 550:../lib/sd_raw.c ****     {
 551:../lib/sd_raw.c ****         /* as reading is now buffered, we directly
 552:../lib/sd_raw.c ****          * hand over the request to sd_raw_read()
 553:../lib/sd_raw.c ****          */
 554:../lib/sd_raw.c ****         if(!sd_raw_read(offset, buffer, interval))
 555:../lib/sd_raw.c ****             return 0;
 556:../lib/sd_raw.c ****         if(!callback(buffer, offset, p))
 557:../lib/sd_raw.c ****             break;
 558:../lib/sd_raw.c ****         offset += interval;
 559:../lib/sd_raw.c ****         length -= interval;
 560:../lib/sd_raw.c ****     }
 561:../lib/sd_raw.c **** 
 562:../lib/sd_raw.c ****     return 1;
 563:../lib/sd_raw.c **** #else
 564:../lib/sd_raw.c ****     /* address card */
 565:../lib/sd_raw.c ****     select_card();
 566:../lib/sd_raw.c **** 
 567:../lib/sd_raw.c ****     uint16_t block_offset;
 568:../lib/sd_raw.c ****     uint16_t read_length;
 569:../lib/sd_raw.c ****     uint8_t* buffer_cur;
 570:../lib/sd_raw.c ****     uint8_t finished = 0;
 571:../lib/sd_raw.c ****     do
 572:../lib/sd_raw.c ****     {
 573:../lib/sd_raw.c ****         /* determine byte count to read at once */
 574:../lib/sd_raw.c ****         block_offset = offset & 0x01ff;
 575:../lib/sd_raw.c ****         read_length = 512 - block_offset;
 576:../lib/sd_raw.c ****         
 577:../lib/sd_raw.c ****         /* send single block request */
 578:../lib/sd_raw.c **** #if SD_RAW_SDHC
 579:../lib/sd_raw.c ****         if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) ?
 580:../lib/sd_raw.c **** #else
 581:../lib/sd_raw.c ****         if(sd_raw_send_command(CMD_READ_SINGLE_BLOCK, offset - block_offset))
 582:../lib/sd_raw.c **** #endif
 583:../lib/sd_raw.c ****         {
 584:../lib/sd_raw.c ****             unselect_card();
 585:../lib/sd_raw.c ****             return 0;
 586:../lib/sd_raw.c ****         }
 587:../lib/sd_raw.c **** 
 588:../lib/sd_raw.c ****         /* wait for data block (start byte 0xfe) */
 589:../lib/sd_raw.c ****         while(sd_raw_rec_byte() != 0xfe);
 590:../lib/sd_raw.c **** 
 591:../lib/sd_raw.c ****         /* read up to the data of interest */
 592:../lib/sd_raw.c ****         for(uint16_t i = 0; i < block_offset; ++i)
 593:../lib/sd_raw.c ****             sd_raw_rec_byte();
 594:../lib/sd_raw.c **** 
 595:../lib/sd_raw.c ****         /* read interval bytes of data and execute the callback */
 596:../lib/sd_raw.c ****         do
 597:../lib/sd_raw.c ****         {
 598:../lib/sd_raw.c ****             if(read_length < interval || length < interval)
 599:../lib/sd_raw.c ****                 break;
 600:../lib/sd_raw.c **** 
 601:../lib/sd_raw.c ****             buffer_cur = buffer;
 602:../lib/sd_raw.c ****             for(uint16_t i = 0; i < interval; ++i)
 603:../lib/sd_raw.c ****                 *buffer_cur++ = sd_raw_rec_byte();
 604:../lib/sd_raw.c **** 
 605:../lib/sd_raw.c ****             if(!callback(buffer, offset + (512 - read_length), p))
 606:../lib/sd_raw.c ****             {
 607:../lib/sd_raw.c ****                 finished = 1;
 608:../lib/sd_raw.c ****                 break;
 609:../lib/sd_raw.c ****             }
 610:../lib/sd_raw.c **** 
 611:../lib/sd_raw.c ****             read_length -= interval;
 612:../lib/sd_raw.c ****             length -= interval;
 613:../lib/sd_raw.c **** 
 614:../lib/sd_raw.c ****         } while(read_length > 0 && length > 0);
 615:../lib/sd_raw.c ****         
 616:../lib/sd_raw.c ****         /* read rest of data block */
 617:../lib/sd_raw.c ****         while(read_length-- > 0)
 618:../lib/sd_raw.c ****             sd_raw_rec_byte();
 619:../lib/sd_raw.c ****         
 620:../lib/sd_raw.c ****         /* read crc16 */
 621:../lib/sd_raw.c ****         sd_raw_rec_byte();
 622:../lib/sd_raw.c ****         sd_raw_rec_byte();
 623:../lib/sd_raw.c **** 
 624:../lib/sd_raw.c ****         if(length < interval)
 625:../lib/sd_raw.c ****             break;
 626:../lib/sd_raw.c **** 
 627:../lib/sd_raw.c ****         offset = offset - block_offset + 512;
 628:../lib/sd_raw.c **** 
 629:../lib/sd_raw.c ****     } while(!finished);
 630:../lib/sd_raw.c ****     
 631:../lib/sd_raw.c ****     /* deaddress card */
 632:../lib/sd_raw.c ****     unselect_card();
 633:../lib/sd_raw.c **** 
 634:../lib/sd_raw.c ****     /* let card some time to finish */
 635:../lib/sd_raw.c ****     sd_raw_rec_byte();
 636:../lib/sd_raw.c **** 
 637:../lib/sd_raw.c ****     return 1;
 638:../lib/sd_raw.c **** #endif
 639:../lib/sd_raw.c **** }
 640:../lib/sd_raw.c **** 
 641:../lib/sd_raw.c **** #if DOXYGEN || SD_RAW_WRITE_SUPPORT
 642:../lib/sd_raw.c **** /**
 643:../lib/sd_raw.c ****  * \ingroup sd_raw
 644:../lib/sd_raw.c ****  * Writes raw data to the card.
 645:../lib/sd_raw.c ****  *
 646:../lib/sd_raw.c ****  * \note If write buffering is enabled, you might have to
 647:../lib/sd_raw.c ****  *       call sd_raw_sync() before disconnecting the card
 648:../lib/sd_raw.c ****  *       to ensure all remaining data has been written.
 649:../lib/sd_raw.c ****  *
 650:../lib/sd_raw.c ****  * \param[in] offset The offset where to start writing.
 651:../lib/sd_raw.c ****  * \param[in] buffer The buffer containing the data to be written.
 652:../lib/sd_raw.c ****  * \param[in] length The number of bytes to write.
 653:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 654:../lib/sd_raw.c ****  * \see sd_raw_write_interval, sd_raw_read, sd_raw_read_interval
 655:../lib/sd_raw.c ****  */
 656:../lib/sd_raw.c **** uint8_t sd_raw_write(offset_t offset, const uint8_t* buffer, uintptr_t length)
 657:../lib/sd_raw.c **** {
 658:../lib/sd_raw.c ****     if(sd_raw_locked())
 659:../lib/sd_raw.c ****         return 0;
 660:../lib/sd_raw.c **** 
 661:../lib/sd_raw.c ****     offset_t block_address;
 662:../lib/sd_raw.c ****     uint16_t block_offset;
 663:../lib/sd_raw.c ****     uint16_t write_length;
 664:../lib/sd_raw.c ****     while(length > 0)
 665:../lib/sd_raw.c ****     {
 666:../lib/sd_raw.c ****         /* determine byte count to write at once */
 667:../lib/sd_raw.c ****         block_offset = offset & 0x01ff;
 668:../lib/sd_raw.c ****         block_address = offset - block_offset;
 669:../lib/sd_raw.c ****         write_length = 512 - block_offset; /* write up to block border */
 670:../lib/sd_raw.c ****         if(write_length > length)
 671:../lib/sd_raw.c ****             write_length = length;
 672:../lib/sd_raw.c ****         
 673:../lib/sd_raw.c ****         /* Merge the data to write with the content of the block.
 674:../lib/sd_raw.c ****          * Use the cached block if available.
 675:../lib/sd_raw.c ****          */
 676:../lib/sd_raw.c ****         if(block_address != raw_block_address)
 677:../lib/sd_raw.c ****         {
 678:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 679:../lib/sd_raw.c ****             if(!sd_raw_sync())
 680:../lib/sd_raw.c ****                 return 0;
 681:../lib/sd_raw.c **** #endif
 682:../lib/sd_raw.c **** 
 683:../lib/sd_raw.c ****             if(block_offset || write_length < 512)
 684:../lib/sd_raw.c ****             {
 685:../lib/sd_raw.c ****                 if(!sd_raw_read(block_address, raw_block, sizeof(raw_block)))
 686:../lib/sd_raw.c ****                     return 0;
 687:../lib/sd_raw.c ****             }
 688:../lib/sd_raw.c ****             raw_block_address = block_address;
 689:../lib/sd_raw.c ****         }
 690:../lib/sd_raw.c **** 
 691:../lib/sd_raw.c ****         if(buffer != raw_block)
 692:../lib/sd_raw.c ****         {
 693:../lib/sd_raw.c ****             memcpy(raw_block + block_offset, buffer, write_length);
 694:../lib/sd_raw.c **** 
 695:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 696:../lib/sd_raw.c ****             raw_block_written = 0;
 697:../lib/sd_raw.c **** 
 698:../lib/sd_raw.c ****             if(length == write_length)
 699:../lib/sd_raw.c ****                 return 1;
 700:../lib/sd_raw.c **** #endif
 701:../lib/sd_raw.c ****         }
 702:../lib/sd_raw.c **** 
 703:../lib/sd_raw.c ****         /* address card */
 704:../lib/sd_raw.c ****         select_card();
 705:../lib/sd_raw.c **** 
 706:../lib/sd_raw.c ****         /* send single block request */
 707:../lib/sd_raw.c **** #if SD_RAW_SDHC
 708:../lib/sd_raw.c ****         if(sd_raw_send_command(CMD_WRITE_SINGLE_BLOCK, (sd_raw_card_type & (1 << SD_RAW_SPEC_SDHC) 
 709:../lib/sd_raw.c **** #else
 710:../lib/sd_raw.c ****         if(sd_raw_send_command(CMD_WRITE_SINGLE_BLOCK, block_address))
 711:../lib/sd_raw.c **** #endif
 712:../lib/sd_raw.c ****         {
 713:../lib/sd_raw.c ****             unselect_card();
 714:../lib/sd_raw.c ****             return 0;
 715:../lib/sd_raw.c ****         }
 716:../lib/sd_raw.c **** 
 717:../lib/sd_raw.c ****         /* send start byte */
 718:../lib/sd_raw.c ****         sd_raw_send_byte(0xfe);
 719:../lib/sd_raw.c **** 
 720:../lib/sd_raw.c ****         /* write byte block */
 721:../lib/sd_raw.c ****         uint8_t* cache = raw_block;
 722:../lib/sd_raw.c ****         for(uint16_t i = 0; i < 512; ++i)
 723:../lib/sd_raw.c ****             sd_raw_send_byte(*cache++);
 724:../lib/sd_raw.c **** 
 725:../lib/sd_raw.c ****         /* write dummy crc16 */
 726:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 727:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 728:../lib/sd_raw.c **** 
 729:../lib/sd_raw.c ****         /* wait while card is busy */
 730:../lib/sd_raw.c ****         while(sd_raw_rec_byte() != 0xff);
 731:../lib/sd_raw.c ****         sd_raw_rec_byte();
 732:../lib/sd_raw.c **** 
 733:../lib/sd_raw.c ****         /* deaddress card */
 734:../lib/sd_raw.c ****         unselect_card();
 735:../lib/sd_raw.c **** 
 736:../lib/sd_raw.c ****         buffer += write_length;
 737:../lib/sd_raw.c ****         offset += write_length;
 738:../lib/sd_raw.c ****         length -= write_length;
 739:../lib/sd_raw.c **** 
 740:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 741:../lib/sd_raw.c ****         raw_block_written = 1;
 742:../lib/sd_raw.c **** #endif
 743:../lib/sd_raw.c ****     }
 744:../lib/sd_raw.c **** 
 745:../lib/sd_raw.c ****     return 1;
 746:../lib/sd_raw.c **** }
 747:../lib/sd_raw.c **** #endif
 748:../lib/sd_raw.c **** 
 749:../lib/sd_raw.c **** #if DOXYGEN || SD_RAW_WRITE_SUPPORT
 750:../lib/sd_raw.c **** /**
 751:../lib/sd_raw.c ****  * \ingroup sd_raw
 752:../lib/sd_raw.c ****  * Writes a continuous data stream obtained from a callback function.
 753:../lib/sd_raw.c ****  *
 754:../lib/sd_raw.c ****  * This function starts writing at the specified offset. To obtain the
 755:../lib/sd_raw.c ****  * next bytes to write, it calls the callback function. The callback fills the
 756:../lib/sd_raw.c ****  * provided data buffer and returns the number of bytes it has put into the buffer.
 757:../lib/sd_raw.c ****  *
 758:../lib/sd_raw.c ****  * By returning zero, the callback may stop writing.
 759:../lib/sd_raw.c ****  *
 760:../lib/sd_raw.c ****  * \param[in] offset Offset where to start writing.
 761:../lib/sd_raw.c ****  * \param[in] buffer Pointer to a buffer which is used for the callback function.
 762:../lib/sd_raw.c ****  * \param[in] length Number of bytes to write in total. May be zero for endless writes.
 763:../lib/sd_raw.c ****  * \param[in] callback The function used to obtain the bytes to write.
 764:../lib/sd_raw.c ****  * \param[in] p An opaque pointer directly passed to the callback function.
 765:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success
 766:../lib/sd_raw.c ****  * \see sd_raw_read_interval, sd_raw_write, sd_raw_read
 767:../lib/sd_raw.c ****  */
 768:../lib/sd_raw.c **** uint8_t sd_raw_write_interval(offset_t offset, uint8_t* buffer, uintptr_t length, sd_raw_write_inte
 769:../lib/sd_raw.c **** {
 770:../lib/sd_raw.c **** #if SD_RAW_SAVE_RAM
 771:../lib/sd_raw.c ****     #error "SD_RAW_WRITE_SUPPORT is not supported together with SD_RAW_SAVE_RAM"
 772:../lib/sd_raw.c **** #endif
 773:../lib/sd_raw.c **** 
 774:../lib/sd_raw.c ****     if(!buffer || !callback)
 775:../lib/sd_raw.c ****         return 0;
 776:../lib/sd_raw.c **** 
 777:../lib/sd_raw.c ****     uint8_t endless = (length == 0);
 778:../lib/sd_raw.c ****     while(endless || length > 0)
 779:../lib/sd_raw.c ****     {
 780:../lib/sd_raw.c ****         uint16_t bytes_to_write = callback(buffer, offset, p);
 781:../lib/sd_raw.c ****         if(!bytes_to_write)
 782:../lib/sd_raw.c ****             break;
 783:../lib/sd_raw.c ****         if(!endless && bytes_to_write > length)
 784:../lib/sd_raw.c ****             return 0;
 785:../lib/sd_raw.c **** 
 786:../lib/sd_raw.c ****         /* as writing is always buffered, we directly
 787:../lib/sd_raw.c ****          * hand over the request to sd_raw_write()
 788:../lib/sd_raw.c ****          */
 789:../lib/sd_raw.c ****         if(!sd_raw_write(offset, buffer, bytes_to_write))
 790:../lib/sd_raw.c ****             return 0;
 791:../lib/sd_raw.c **** 
 792:../lib/sd_raw.c ****         offset += bytes_to_write;
 793:../lib/sd_raw.c ****         length -= bytes_to_write;
 794:../lib/sd_raw.c ****     }
 795:../lib/sd_raw.c **** 
 796:../lib/sd_raw.c ****     return 1;
 797:../lib/sd_raw.c **** }
 798:../lib/sd_raw.c **** #endif
 799:../lib/sd_raw.c **** 
 800:../lib/sd_raw.c **** #if DOXYGEN || SD_RAW_WRITE_SUPPORT
 801:../lib/sd_raw.c **** /**
 802:../lib/sd_raw.c ****  * \ingroup sd_raw
 803:../lib/sd_raw.c ****  * Writes the write buffer's content to the card.
 804:../lib/sd_raw.c ****  *
 805:../lib/sd_raw.c ****  * \note When write buffering is enabled, you should
 806:../lib/sd_raw.c ****  *       call this function before disconnecting the
 807:../lib/sd_raw.c ****  *       card to ensure all remaining data has been
 808:../lib/sd_raw.c ****  *       written.
 809:../lib/sd_raw.c ****  *
 810:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 811:../lib/sd_raw.c ****  * \see sd_raw_write
 812:../lib/sd_raw.c ****  */
 813:../lib/sd_raw.c **** uint8_t sd_raw_sync()
 814:../lib/sd_raw.c **** {
 815:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 816:../lib/sd_raw.c ****     if(raw_block_written)
 817:../lib/sd_raw.c ****         return 1;
 818:../lib/sd_raw.c ****     if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 819:../lib/sd_raw.c ****         return 0;
 820:../lib/sd_raw.c ****     raw_block_written = 1;
 821:../lib/sd_raw.c **** #endif
 822:../lib/sd_raw.c ****     return 1;
 823:../lib/sd_raw.c **** }
 824:../lib/sd_raw.c **** #endif
 825:../lib/sd_raw.c **** 
 826:../lib/sd_raw.c **** /**
 827:../lib/sd_raw.c ****  * \ingroup sd_raw
 828:../lib/sd_raw.c ****  * Reads informational data from the card.
 829:../lib/sd_raw.c ****  *
 830:../lib/sd_raw.c ****  * This function reads and returns the card's registers
 831:../lib/sd_raw.c ****  * containing manufacturing and status information.
 832:../lib/sd_raw.c ****  *
 833:../lib/sd_raw.c ****  * \note: The information retrieved by this function is
 834:../lib/sd_raw.c ****  *        not required in any way to operate on the card,
 835:../lib/sd_raw.c ****  *        but it might be nice to display some of the data
 836:../lib/sd_raw.c ****  *        to the user.
 837:../lib/sd_raw.c ****  *
 838:../lib/sd_raw.c ****  * \param[in] info A pointer to the structure into which to save the information.
 839:../lib/sd_raw.c ****  * \returns 0 on failure, 1 on success.
 840:../lib/sd_raw.c ****  */
 841:../lib/sd_raw.c **** uint8_t sd_raw_get_info(struct sd_raw_info* info)
 842:../lib/sd_raw.c **** {
 843:../lib/sd_raw.c ****     if(!info || !sd_raw_available())
 844:../lib/sd_raw.c ****         return 0;
 845:../lib/sd_raw.c **** 
 846:../lib/sd_raw.c ****     memset(info, 0, sizeof(*info));
 847:../lib/sd_raw.c **** 
 848:../lib/sd_raw.c ****     select_card();
 849:../lib/sd_raw.c **** 
 850:../lib/sd_raw.c ****     /* read cid register */
 851:../lib/sd_raw.c ****     if(sd_raw_send_command(CMD_SEND_CID, 0))
 852:../lib/sd_raw.c ****     {
 853:../lib/sd_raw.c ****         unselect_card();
 854:../lib/sd_raw.c ****         return 0;
 855:../lib/sd_raw.c ****     }
 856:../lib/sd_raw.c ****     while(sd_raw_rec_byte() != 0xfe);
 857:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 18; ++i)
 858:../lib/sd_raw.c ****     {
 859:../lib/sd_raw.c ****         uint8_t b = sd_raw_rec_byte();
 860:../lib/sd_raw.c **** 
 861:../lib/sd_raw.c ****         switch(i)
 862:../lib/sd_raw.c ****         {
 863:../lib/sd_raw.c ****             case 0:
 864:../lib/sd_raw.c ****                 info->manufacturer = b;
 865:../lib/sd_raw.c ****                 break;
 866:../lib/sd_raw.c ****             case 1:
 867:../lib/sd_raw.c ****             case 2:
 868:../lib/sd_raw.c ****                 info->oem[i - 1] = b;
 869:../lib/sd_raw.c ****                 break;
 870:../lib/sd_raw.c ****             case 3:
 871:../lib/sd_raw.c ****             case 4:
 872:../lib/sd_raw.c ****             case 5:
 873:../lib/sd_raw.c ****             case 6:
 874:../lib/sd_raw.c ****             case 7:
 875:../lib/sd_raw.c ****                 info->product[i - 3] = b;
 876:../lib/sd_raw.c ****                 break;
 877:../lib/sd_raw.c ****             case 8:
 878:../lib/sd_raw.c ****                 info->revision = b;
 879:../lib/sd_raw.c ****                 break;
 880:../lib/sd_raw.c ****             case 9:
 881:../lib/sd_raw.c ****             case 10:
 882:../lib/sd_raw.c ****             case 11:
 883:../lib/sd_raw.c ****             case 12:
 884:../lib/sd_raw.c ****                 info->serial |= (uint32_t) b << ((12 - i) * 8);
 885:../lib/sd_raw.c ****                 break;
 886:../lib/sd_raw.c ****             case 13:
 887:../lib/sd_raw.c ****                 info->manufacturing_year = b << 4;
 888:../lib/sd_raw.c ****                 break;
 889:../lib/sd_raw.c ****             case 14:
 890:../lib/sd_raw.c ****                 info->manufacturing_year |= b >> 4;
 891:../lib/sd_raw.c ****                 info->manufacturing_month = b & 0x0f;
 892:../lib/sd_raw.c ****                 break;
 893:../lib/sd_raw.c ****         }
 894:../lib/sd_raw.c ****     }
 895:../lib/sd_raw.c **** 
 896:../lib/sd_raw.c ****     /* read csd register */
 897:../lib/sd_raw.c ****     uint8_t csd_read_bl_len = 0;
 898:../lib/sd_raw.c ****     uint8_t csd_c_size_mult = 0;
 899:../lib/sd_raw.c **** #if SD_RAW_SDHC
 900:../lib/sd_raw.c ****     uint16_t csd_c_size = 0;
 901:../lib/sd_raw.c **** #else
 902:../lib/sd_raw.c ****     uint32_t csd_c_size = 0;
 903:../lib/sd_raw.c **** #endif
 904:../lib/sd_raw.c ****     if(sd_raw_send_command(CMD_SEND_CSD, 0))
 905:../lib/sd_raw.c ****     {
 906:../lib/sd_raw.c ****         unselect_card();
 907:../lib/sd_raw.c ****         return 0;
 908:../lib/sd_raw.c ****     }
 909:../lib/sd_raw.c ****     while(sd_raw_rec_byte() != 0xfe);
 910:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 18; ++i)
 911:../lib/sd_raw.c ****     {
 912:../lib/sd_raw.c ****         uint8_t b = sd_raw_rec_byte();
 913:../lib/sd_raw.c **** 
 914:../lib/sd_raw.c ****         if(i == 14)
 915:../lib/sd_raw.c ****         {
 916:../lib/sd_raw.c ****             if(b & 0x40)
 917:../lib/sd_raw.c ****                 info->flag_copy = 1;
 918:../lib/sd_raw.c ****             if(b & 0x20)
 919:../lib/sd_raw.c ****                 info->flag_write_protect = 1;
 920:../lib/sd_raw.c ****             if(b & 0x10)
 921:../lib/sd_raw.c ****                 info->flag_write_protect_temp = 1;
 922:../lib/sd_raw.c ****             info->format = (b & 0x0c) >> 2;
 923:../lib/sd_raw.c ****         }
 924:../lib/sd_raw.c ****         else
 925:../lib/sd_raw.c ****         {
 926:../lib/sd_raw.c **** #if SD_RAW_SDHC
 927:../lib/sd_raw.c ****             if(sd_raw_card_type & (1 << SD_RAW_SPEC_2))
 928:../lib/sd_raw.c ****             {
 929:../lib/sd_raw.c ****                 switch(i)
 930:../lib/sd_raw.c ****                 {
 931:../lib/sd_raw.c ****                     case 7:
 932:../lib/sd_raw.c ****                         b &= 0x3f;
 933:../lib/sd_raw.c ****                     case 8:
 934:../lib/sd_raw.c ****                     case 9:
 935:../lib/sd_raw.c ****                         csd_c_size <<= 8;
 936:../lib/sd_raw.c ****                         csd_c_size |= b;
 937:../lib/sd_raw.c ****                         break;
 938:../lib/sd_raw.c ****                 }
 939:../lib/sd_raw.c ****                 if(i == 9)
 940:../lib/sd_raw.c ****                 {
 941:../lib/sd_raw.c ****                     ++csd_c_size;
 942:../lib/sd_raw.c ****                     info->capacity = (offset_t) csd_c_size * 512 * 1024;
 943:../lib/sd_raw.c ****                 }
 944:../lib/sd_raw.c ****             }
 945:../lib/sd_raw.c ****             else
 946:../lib/sd_raw.c **** #endif
 947:../lib/sd_raw.c ****             {
 948:../lib/sd_raw.c ****                 switch(i)
 949:../lib/sd_raw.c ****                 {
 950:../lib/sd_raw.c ****                     case 5:
 951:../lib/sd_raw.c ****                         csd_read_bl_len = b & 0x0f;
 952:../lib/sd_raw.c ****                         break;
 953:../lib/sd_raw.c ****                     case 6:
 954:../lib/sd_raw.c ****                         csd_c_size = b & 0x03;
 955:../lib/sd_raw.c ****                         csd_c_size <<= 8;
 956:../lib/sd_raw.c ****                         break;
 957:../lib/sd_raw.c ****                     case 7:
 958:../lib/sd_raw.c ****                         csd_c_size |= b;
 959:../lib/sd_raw.c ****                         csd_c_size <<= 2;
 960:../lib/sd_raw.c ****                         break;
 961:../lib/sd_raw.c ****                     case 8:
 962:../lib/sd_raw.c ****                         csd_c_size |= b >> 6;
 963:../lib/sd_raw.c ****                         ++csd_c_size;
 964:../lib/sd_raw.c ****                         break;
 965:../lib/sd_raw.c ****                     case 9:
 966:../lib/sd_raw.c ****                         csd_c_size_mult = b & 0x03;
 967:../lib/sd_raw.c ****                         csd_c_size_mult <<= 1;
 968:../lib/sd_raw.c ****                         break;
 969:../lib/sd_raw.c ****                     case 10:
 970:../lib/sd_raw.c ****                         csd_c_size_mult |= b >> 7;
 971:../lib/sd_raw.c **** 
 972:../lib/sd_raw.c ****                         info->capacity = (uint32_t) csd_c_size << (csd_c_size_mult + csd_read_bl_le
 973:../lib/sd_raw.c **** 
 974:../lib/sd_raw.c ****                         break;
 975:../lib/sd_raw.c ****                 }
 976:../lib/sd_raw.c ****             }
 977:../lib/sd_raw.c ****         }
 978:../lib/sd_raw.c ****     }
 979:../lib/sd_raw.c **** 
 980:../lib/sd_raw.c ****     unselect_card();
 981:../lib/sd_raw.c **** 
 982:../lib/sd_raw.c ****     return 1;
 983:../lib/sd_raw.c **** }
  96              		.loc 1 983 0
  97 0068 2408A0E1 		mov	r0, r4, lsr #16
 395:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 16) & 0xff);
  98              		.loc 1 395 0
  99 006c FF0000E2 		and	r0, r0, #255
 100 0070 E2FFFFEB 		bl	sd_raw_send_byte
 101              	.LVL5:
 102              		.loc 1 983 0
 103 0074 2404A0E1 		mov	r0, r4, lsr #8
 396:../lib/sd_raw.c ****     sd_raw_send_byte((arg >> 0) & 0xff);
 104              		.loc 1 396 0
 105 0078 FF0000E2 		and	r0, r0, #255
 106 007c DFFFFFEB 		bl	sd_raw_send_byte
 107              	.LVL6:
 108              		.loc 1 983 0
 109 0080 FF0004E2 		and	r0, r4, #255
 397:../lib/sd_raw.c ****     switch(command)
 110              		.loc 1 397 0
 111 0084 DDFFFFEB 		bl	sd_raw_send_byte
 112              	.LVL7:
 398:../lib/sd_raw.c ****     {
 113              		.loc 1 398 0
 114 0088 000055E3 		cmp	r5, #0
 401:../lib/sd_raw.c ****            break;
 115              		.loc 1 401 0
 116 008c 9500A003 		moveq	r0, #149
 398:../lib/sd_raw.c ****     {
 117              		.loc 1 398 0
 118 0090 0200000A 		beq	.L26
 119 0094 080055E3 		cmp	r5, #8
 407:../lib/sd_raw.c ****            break;
 120              		.loc 1 407 0
 121 0098 FF00A013 		movne	r0, #255
 398:../lib/sd_raw.c ****     {
 122              		.loc 1 398 0
 123 009c 0200000A 		beq	.L20
 124              	.L26:
 401:../lib/sd_raw.c ****            break;
 125              		.loc 1 401 0
 126 00a0 D6FFFFEB 		bl	sd_raw_send_byte
 127              	.LVL8:
 386:../lib/sd_raw.c ****     uint8_t response;
 128              		.loc 1 386 0
 129 00a4 0A40A0E3 		mov	r4, #10
 130              	.LVL9:
 131 00a8 010000EA 		b	.L21
 132              	.LVL10:
 133              	.L20:
 404:../lib/sd_raw.c ****            break;
 134              		.loc 1 404 0
 135 00ac 8700A0E3 		mov	r0, #135
 136 00b0 FAFFFFEA 		b	.L26
 137              	.LVL11:
 138              	.L21:
 139              	.LBB18:
 414:../lib/sd_raw.c ****         if(response != 0xff)
 140              		.loc 1 414 0
 141 00b4 D8FFFFEB 		bl	sd_raw_rec_byte
 142              	.LVL12:
 415:../lib/sd_raw.c ****             break;
 143              		.loc 1 415 0
 144 00b8 FF0050E3 		cmp	r0, #255
 145 00bc 0200001A 		bne	.L23
 146              	.LVL13:
 147 00c0 014044E2 		sub	r4, r4, #1
 412:../lib/sd_raw.c ****     {
 148              		.loc 1 412 0
 149 00c4 FF4014E2 		ands	r4, r4, #255
 150 00c8 F9FFFF1A 		bne	.L21
 151              	.LVL14:
 152              	.L23:
 153              	.LBE18:
 420:../lib/sd_raw.c **** 
 154              		.loc 1 420 0
 155 00cc 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 156 00d0 1EFF2FE1 		bx	lr
 157              		.cfi_endproc
 158              	.LFE5:
 160              		.align	2
 161              		.global	sd_raw_available
 163              	sd_raw_available:
 164              	.LFB1:
 332:../lib/sd_raw.c ****     return get_pin_available() == 0x00;
 165              		.loc 1 332 0
 166              		.cfi_startproc
 167              		@ Function supports interworking.
 168              		@ args = 0, pretend = 0, frame = 0
 169              		@ frame_needed = 0, uses_anonymous_args = 0
 170              		@ link register save eliminated.
 334:../lib/sd_raw.c **** 
 171              		.loc 1 334 0
 172 00d4 0100A0E3 		mov	r0, #1
 173 00d8 1EFF2FE1 		bx	lr
 174              		.cfi_endproc
 175              	.LFE1:
 177              		.align	2
 178              		.global	sd_raw_locked
 180              	sd_raw_locked:
 181              	.LFB2:
 343:../lib/sd_raw.c ****     return get_pin_locked() == 0x00;
 182              		.loc 1 343 0
 183              		.cfi_startproc
 184              		@ Function supports interworking.
 185              		@ args = 0, pretend = 0, frame = 0
 186              		@ frame_needed = 0, uses_anonymous_args = 0
 187              		@ link register save eliminated.
 345:../lib/sd_raw.c **** 
 188              		.loc 1 345 0
 189 00dc 0000A0E3 		mov	r0, #0
 190 00e0 1EFF2FE1 		bx	lr
 191              		.cfi_endproc
 192              	.LFE2:
 194              		.align	2
 195              		.global	sd_raw_sync
 197              	sd_raw_sync:
 198              	.LFB10:
 814:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 199              		.loc 1 814 0
 200              		.cfi_startproc
 201              		@ Function supports interworking.
 202              		@ args = 0, pretend = 0, frame = 0
 203              		@ frame_needed = 0, uses_anonymous_args = 0
 204 00e4 10402DE9 		stmfd	sp!, {r4, lr}
 205              	.LCFI1:
 206              		.cfi_def_cfa_offset 8
 207              		.cfi_offset 4, -8
 208              		.cfi_offset 14, -4
 816:../lib/sd_raw.c ****         return 1;
 209              		.loc 1 816 0
 210 00e8 30409FE5 		ldr	r4, .L34
 211 00ec 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 212 00f0 000053E3 		cmp	r3, #0
 817:../lib/sd_raw.c ****     if(!sd_raw_write(raw_block_address, raw_block, sizeof(raw_block)))
 213              		.loc 1 817 0
 214 00f4 0100A013 		movne	r0, #1
 816:../lib/sd_raw.c ****         return 1;
 215              		.loc 1 816 0
 216 00f8 0600001A 		bne	.L30
 217              	.LBB21:
 218              	.LBB22:
 818:../lib/sd_raw.c ****         return 0;
 219              		.loc 1 818 0
 220 00fc 030094E9 		ldmib	r4, {r0-r1}
 221 0100 0C2084E2 		add	r2, r4, #12
 222 0104 023CA0E3 		mov	r3, #512
 223 0108 FEFFFFEB 		bl	sd_raw_write
 224              	.LVL15:
 225 010c 000050E3 		cmp	r0, #0
 820:../lib/sd_raw.c **** #endif
 226              		.loc 1 820 0
 227 0110 0100A013 		movne	r0, #1
 228 0114 0000C415 		strneb	r0, [r4, #0]
 229              	.L30:
 230              	.LBE22:
 231              	.LBE21:
 823:../lib/sd_raw.c **** #endif
 232              		.loc 1 823 0
 233 0118 1040BDE8 		ldmfd	sp!, {r4, lr}
 234 011c 1EFF2FE1 		bx	lr
 235              	.L35:
 236              		.align	2
 237              	.L34:
 238 0120 00000000 		.word	.LANCHOR0
 239              		.cfi_endproc
 240              	.LFE10:
 242              		.align	2
 243              		.global	sd_raw_read
 245              	sd_raw_read:
 246              	.LFB6:
 433:../lib/sd_raw.c ****     offset_t block_address;
 247              		.loc 1 433 0
 248              		.cfi_startproc
 249              		@ Function supports interworking.
 250              		@ args = 0, pretend = 0, frame = 16
 251              		@ frame_needed = 0, uses_anonymous_args = 0
 252              	.LVL16:
 253 0124 FF4F2DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 254              	.LCFI2:
 255              		.cfi_def_cfa_offset 52
 256              		.cfi_offset 0, -52
 257              		.cfi_offset 1, -48
 258              		.cfi_offset 2, -44
 259              		.cfi_offset 3, -40
 260              		.cfi_offset 4, -36
 261              		.cfi_offset 5, -32
 262              		.cfi_offset 6, -28
 263              		.cfi_offset 7, -24
 264              		.cfi_offset 8, -20
 265              		.cfi_offset 9, -16
 266              		.cfi_offset 10, -12
 267              		.cfi_offset 11, -8
 268              		.cfi_offset 14, -4
 448:../lib/sd_raw.c **** #endif
 269              		.loc 1 448 0
 270 0128 74A19FE5 		ldr	sl, .L54
 433:../lib/sd_raw.c ****     offset_t block_address;
 271              		.loc 1 433 0
 272 012c 08008DE5 		str	r0, [sp, #8]
 273 0130 0C108DE5 		str	r1, [sp, #12]
 274 0134 0270A0E1 		mov	r7, r2
 275 0138 0380A0E1 		mov	r8, r3
 276              	.LBB23:
 277              	.LBB24:
 486:../lib/sd_raw.c ****             raw_block_address = block_address;
 278              		.loc 1 486 0
 279 013c 0C908AE2 		add	r9, sl, #12
 280              	.LBE24:
 281              	.LBE23:
 437:../lib/sd_raw.c ****     {
 282              		.loc 1 437 0
 283 0140 510000EA 		b	.L37
 284              	.LVL17:
 285              	.L46:
 440:../lib/sd_raw.c ****         block_address = offset - block_offset;
 286              		.loc 1 440 0
 287 0144 08208DE2 		add	r2, sp, #8
 288 0148 060092E8 		ldmia	r2, {r1-r2}
 289 014c 54319FE5 		ldr	r3, .L54+4
 290 0150 031001E0 		and	r1, r1, r3
 291 0154 0040A0E3 		mov	r4, #0
 442:../lib/sd_raw.c ****         if(read_length > length)
 292              		.loc 1 442 0
 293 0158 026C61E2 		rsb	r6, r1, #512
 440:../lib/sd_raw.c ****         block_address = offset - block_offset;
 294              		.loc 1 440 0
 295 015c 042002E0 		and	r2, r2, r4
 442:../lib/sd_raw.c ****         if(read_length > length)
 296              		.loc 1 442 0
 297 0160 0668A0E1 		mov	r6, r6, asl #16
 441:../lib/sd_raw.c ****         read_length = 512 - block_offset; /* read up to block border */
 298              		.loc 1 441 0
 299 0164 08508DE2 		add	r5, sp, #8
 300 0168 300095E8 		ldmia	r5, {r4-r5}
 442:../lib/sd_raw.c ****         if(read_length > length)
 301              		.loc 1 442 0
 302 016c 2668A0E1 		mov	r6, r6, lsr #16
 441:../lib/sd_raw.c ****         read_length = 512 - block_offset; /* read up to block border */
 303              		.loc 1 441 0
 304 0170 014054E0 		subs	r4, r4, r1
 305 0174 0250C5E0 		sbc	r5, r5, r2
 440:../lib/sd_raw.c ****         block_address = offset - block_offset;
 306              		.loc 1 440 0
 307 0178 06008DE8 		stmia	sp, {r1-r2}
 308              	.LVL18:
 443:../lib/sd_raw.c ****             read_length = length;
 309              		.loc 1 443 0
 310 017c 080056E1 		cmp	r6, r8
 448:../lib/sd_raw.c **** #endif
 311              		.loc 1 448 0
 312 0180 0C009AE9 		ldmib	sl, {r2-r3}
 444:../lib/sd_raw.c ****         
 313              		.loc 1 444 0
 314 0184 0868A081 		movhi	r6, r8, asl #16
 315              	.LVL19:
 316 0188 2668A081 		movhi	r6, r6, lsr #16
 317              	.LVL20:
 448:../lib/sd_raw.c **** #endif
 318              		.loc 1 448 0
 319 018c 030055E1 		cmp	r5, r3
 320              		it eq
 321 0190 02005401 		cmpeq	r4, r2
 322 0194 2E00000A 		beq	.L39
 323              	.LBB26:
 452:../lib/sd_raw.c ****                 return 0;
 324              		.loc 1 452 0
 325 0198 FEFFFFEB 		bl	sd_raw_sync
 326              	.LVL21:
 327 019c 000050E3 		cmp	r0, #0
 328 01a0 3C00000A 		beq	.L40
 457:../lib/sd_raw.c **** 
 329              		.loc 1 457 0
 330 01a4 00319FE5 		ldr	r3, .L54+8
 331 01a8 0C2093E5 		ldr	r2, [r3, #12]
 332 01ac 802082E3 		orr	r2, r2, #128
 333 01b0 0C2083E5 		str	r2, [r3, #12]
 461:../lib/sd_raw.c **** #else
 334              		.loc 1 461 0
 335 01b4 0C32DAE5 		ldrb	r3, [sl, #524]	@ zero_extendqisi2
 336 01b8 040013E3 		tst	r3, #4
 337 01bc A414A011 		movne	r1, r4, lsr #9
 338 01c0 851B8111 		orrne	r1, r1, r5, asl #23
 339 01c4 0410A001 		moveq	r1, r4
 340 01c8 1100A0E3 		mov	r0, #17
 341 01cc 9DFFFFEB 		bl	sd_raw_send_command
 342              	.LVL22:
 343 01d0 000050E3 		cmp	r0, #0
 344 01d4 0500000A 		beq	.L50
 466:../lib/sd_raw.c ****                 return 0;
 345              		.loc 1 466 0
 346 01d8 CC309FE5 		ldr	r3, .L54+8
 347 01dc 042093E5 		ldr	r2, [r3, #4]
 348 01e0 802082E3 		orr	r2, r2, #128
 349 01e4 042083E5 		str	r2, [r3, #4]
 467:../lib/sd_raw.c ****             }
 350              		.loc 1 467 0
 351 01e8 0000A0E3 		mov	r0, #0
 352 01ec 290000EA 		b	.L40
 353              	.L50:
 471:../lib/sd_raw.c **** 
 354              		.loc 1 471 0
 355 01f0 89FFFFEB 		bl	sd_raw_rec_byte
 356              	.LVL23:
 357 01f4 FE0050E3 		cmp	r0, #254
 358 01f8 FCFFFF1A 		bne	.L50
 359 01fc 00B0A0E3 		mov	fp, #0
 360              	.L44:
 361              	.LBB25:
 486:../lib/sd_raw.c ****             raw_block_address = block_address;
 362              		.loc 1 486 0 discriminator 2
 363 0200 85FFFFEB 		bl	sd_raw_rec_byte
 364              	.LVL24:
 365 0204 0B00C9E7 		strb	r0, [r9, fp]
 366              	.LVL25:
 367 0208 01B08BE2 		add	fp, fp, #1
 485:../lib/sd_raw.c ****                 *cache++ = sd_raw_rec_byte();
 368              		.loc 1 485 0 discriminator 2
 369 020c 020C5BE3 		cmp	fp, #512
 370 0210 FAFFFF1A 		bne	.L44
 371              	.LBE25:
 487:../lib/sd_raw.c **** 
 372              		.loc 1 487 0
 373 0214 88309FE5 		ldr	r3, .L54
 374 0218 300083E9 		stmib	r3, {r4-r5}
 489:../lib/sd_raw.c ****             buffer += read_length;
 375              		.loc 1 489 0
 376 021c 00409DE5 		ldr	r4, [sp, #0]
 377              	.LVL26:
 378 0220 0620A0E1 		mov	r2, r6
 379 0224 041089E0 		add	r1, r9, r4
 380 0228 0700A0E1 		mov	r0, r7
 381 022c FEFFFFEB 		bl	memcpy
 382              	.LVL27:
 494:../lib/sd_raw.c ****             sd_raw_rec_byte();
 383              		.loc 1 494 0
 384 0230 79FFFFEB 		bl	sd_raw_rec_byte
 385              	.LVL28:
 495:../lib/sd_raw.c ****             
 386              		.loc 1 495 0
 387 0234 78FFFFEB 		bl	sd_raw_rec_byte
 388              	.LVL29:
 498:../lib/sd_raw.c **** 
 389              		.loc 1 498 0
 390 0238 6C309FE5 		ldr	r3, .L54+8
 391 023c 042093E5 		ldr	r2, [r3, #4]
 392 0240 802082E3 		orr	r2, r2, #128
 393 0244 042083E5 		str	r2, [r3, #4]
 490:../lib/sd_raw.c **** #endif
 394              		.loc 1 490 0
 395 0248 067087E0 		add	r7, r7, r6
 396              	.LVL30:
 501:../lib/sd_raw.c ****         }
 397              		.loc 1 501 0
 398 024c 72FFFFEB 		bl	sd_raw_rec_byte
 399              	.LVL31:
 400 0250 060000EA 		b	.L45
 401              	.LVL32:
 402              	.L39:
 403              	.LBE26:
 507:../lib/sd_raw.c ****             buffer += read_length;
 404              		.loc 1 507 0
 405 0254 00209DE5 		ldr	r2, [sp, #0]
 406 0258 50109FE5 		ldr	r1, .L54+12
 407 025c 0700A0E1 		mov	r0, r7
 408 0260 021081E0 		add	r1, r1, r2
 409 0264 0620A0E1 		mov	r2, r6
 410 0268 FEFFFFEB 		bl	memcpy
 411              	.LVL33:
 508:../lib/sd_raw.c ****         }
 412              		.loc 1 508 0
 413 026c 067087E0 		add	r7, r7, r6
 414              	.LVL34:
 415              	.L45:
 513:../lib/sd_raw.c ****     }
 416              		.loc 1 513 0
 417 0270 08408DE2 		add	r4, sp, #8
 418 0274 180094E8 		ldmia	r4, {r3-r4}
 419 0278 063093E0 		adds	r3, r3, r6
 420 027c 0040A4E2 		adc	r4, r4, #0
 421 0280 08308DE5 		str	r3, [sp, #8]
 422 0284 0C408DE5 		str	r4, [sp, #12]
 512:../lib/sd_raw.c ****         offset += read_length;
 423              		.loc 1 512 0
 424 0288 088066E0 		rsb	r8, r6, r8
 425              	.LVL35:
 426              	.L37:
 437:../lib/sd_raw.c ****     {
 427              		.loc 1 437 0 discriminator 1
 428 028c 000058E3 		cmp	r8, #0
 429 0290 ABFFFF1A 		bne	.L46
 516:../lib/sd_raw.c **** }
 430              		.loc 1 516 0
 431 0294 0100A0E3 		mov	r0, #1
 432              	.L40:
 517:../lib/sd_raw.c **** 
 433              		.loc 1 517 0
 434 0298 10D08DE2 		add	sp, sp, #16
 435 029c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 436 02a0 1EFF2FE1 		bx	lr
 437              	.L55:
 438              		.align	2
 439              	.L54:
 440 02a4 00000000 		.word	.LANCHOR0
 441 02a8 FF010000 		.word	511
 442 02ac 008002E0 		.word	-536707072
 443 02b0 0C000000 		.word	.LANCHOR0+12
 444              		.cfi_endproc
 445              	.LFE6:
 447              		.align	2
 448              		.global	sd_raw_read_interval
 450              	sd_raw_read_interval:
 451              	.LFB7:
 544:../lib/sd_raw.c ****     if(!buffer || interval == 0 || length < interval || !callback)
 452              		.loc 1 544 0
 453              		.cfi_startproc
 454              		@ Function supports interworking.
 455              		@ args = 12, pretend = 0, frame = 0
 456              		@ frame_needed = 0, uses_anonymous_args = 0
 457              	.LVL36:
 458 02b4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 459              	.LCFI3:
 460              		.cfi_def_cfa_offset 36
 461              		.cfi_offset 4, -36
 462              		.cfi_offset 5, -32
 463              		.cfi_offset 6, -28
 464              		.cfi_offset 7, -24
 465              		.cfi_offset 8, -20
 466              		.cfi_offset 9, -16
 467              		.cfi_offset 10, -12
 468              		.cfi_offset 11, -8
 469              		.cfi_offset 14, -4
 545:../lib/sd_raw.c ****         return 0;
 470              		.loc 1 545 0
 471 02b8 000052E3 		cmp	r2, #0
 472 02bc 00005313 		cmpne	r3, #0
 544:../lib/sd_raw.c ****     if(!buffer || interval == 0 || length < interval || !callback)
 473              		.loc 1 544 0
 474 02c0 0040A0E1 		mov	r4, r0
 475 02c4 0150A0E1 		mov	r5, r1
 476 02c8 24A09DE5 		ldr	sl, [sp, #36]
 477 02cc 28909DE5 		ldr	r9, [sp, #40]
 545:../lib/sd_raw.c ****         return 0;
 478              		.loc 1 545 0
 479 02d0 0380A0E1 		mov	r8, r3
 480 02d4 02B0A0E1 		mov	fp, r2
 481 02d8 0100001A 		bne	.L57
 482              	.LVL37:
 483              	.L59:
 546:../lib/sd_raw.c **** 
 484              		.loc 1 546 0
 485 02dc 0000A0E3 		mov	r0, #0
 486 02e0 1D0000EA 		b	.L58
 487              	.LVL38:
 488              	.L57:
 545:../lib/sd_raw.c ****         return 0;
 489              		.loc 1 545 0 discriminator 1
 490 02e4 03005AE1 		cmp	sl, r3
 491 02e8 0030A023 		movcs	r3, #0
 492              	.LVL39:
 493 02ec 0130A033 		movcc	r3, #1
 494 02f0 000059E3 		cmp	r9, #0
 495 02f4 01308303 		orreq	r3, r3, #1
 496 02f8 000053E3 		cmp	r3, #0
 497 02fc F6FFFF1A 		bne	.L59
 558:../lib/sd_raw.c ****         length -= interval;
 498              		.loc 1 558 0
 499 0300 0860A0E1 		mov	r6, r8
 500 0304 0070A0E3 		mov	r7, #0
 501              	.LVL40:
 502              	.L64:
 554:../lib/sd_raw.c ****             return 0;
 503              		.loc 1 554 0
 504 0308 0400A0E1 		mov	r0, r4
 505 030c 0510A0E1 		mov	r1, r5
 506 0310 0B20A0E1 		mov	r2, fp
 507 0314 0830A0E1 		mov	r3, r8
 508 0318 FEFFFFEB 		bl	sd_raw_read
 509              	.LVL41:
 510 031c 000050E3 		cmp	r0, #0
 511 0320 EDFFFF0A 		beq	.L59
 556:../lib/sd_raw.c ****             break;
 512              		.loc 1 556 0
 513 0324 0B00A0E1 		mov	r0, fp
 514 0328 0410A0E1 		mov	r1, r4
 515 032c 0520A0E1 		mov	r2, r5
 516 0330 2C309DE5 		ldr	r3, [sp, #44]
 517 0334 0FE0A0E1 		mov	lr, pc
 518 0338 19FF2FE1 		bx	r9
 519              	.LVL42:
 520 033c 000050E3 		cmp	r0, #0
 521 0340 0400000A 		beq	.L61
 543:../lib/sd_raw.c **** {
 522              		.loc 1 543 0
 523 0344 064094E0 		adds	r4, r4, r6
 559:../lib/sd_raw.c ****     }
 524              		.loc 1 559 0
 525 0348 0AA068E0 		rsb	sl, r8, sl
 543:../lib/sd_raw.c **** {
 526              		.loc 1 543 0
 527 034c 0750A5E0 		adc	r5, r5, r7
 528              	.LVL43:
 549:../lib/sd_raw.c ****     {
 529              		.loc 1 549 0
 530 0350 08005AE1 		cmp	sl, r8
 531 0354 EBFFFF2A 		bcs	.L64
 532              	.LVL44:
 533              	.L61:
 562:../lib/sd_raw.c **** #else
 534              		.loc 1 562 0
 535 0358 0100A0E3 		mov	r0, #1
 536              	.LVL45:
 537              	.L58:
 639:../lib/sd_raw.c **** 
 538              		.loc 1 639 0
 539 035c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 540 0360 1EFF2FE1 		bx	lr
 541              		.cfi_endproc
 542              	.LFE7:
 544              		.align	2
 545              		.global	sd_raw_init
 547              	sd_raw_init:
 548              	.LFB0:
 173:../lib/sd_raw.c ****     /* enable inputs for reading card status */
 549              		.loc 1 173 0
 550              		.cfi_startproc
 551              		@ Function supports interworking.
 552              		@ args = 0, pretend = 0, frame = 0
 553              		@ frame_needed = 0, uses_anonymous_args = 0
 179:../lib/sd_raw.c ****     configure_pin_sck();
 554              		.loc 1 179 0
 555 0364 40329FE5 		ldr	r3, .L98
 556 0368 002093E5 		ldr	r2, [r3, #0]
 557 036c 012A82E3 		orr	r2, r2, #4096
 173:../lib/sd_raw.c ****     /* enable inputs for reading card status */
 558              		.loc 1 173 0
 559 0370 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 560              	.LCFI4:
 561              		.cfi_def_cfa_offset 16
 562              		.cfi_offset 4, -16
 563              		.cfi_offset 5, -12
 564              		.cfi_offset 6, -8
 565              		.cfi_offset 14, -4
 179:../lib/sd_raw.c ****     configure_pin_sck();
 566              		.loc 1 179 0
 567 0374 002083E5 		str	r2, [r3, #0]
 180:../lib/sd_raw.c ****     configure_pin_ss();
 568              		.loc 1 180 0
 569 0378 002093E5 		ldr	r2, [r3, #0]
 570 037c 012C82E3 		orr	r2, r2, #256
 571 0380 002083E5 		str	r2, [r3, #0]
 181:../lib/sd_raw.c ****     configure_pin_miso();
 572              		.loc 1 181 0
 573 0384 24229FE5 		ldr	r2, .L98+4
 574 0388 081092E5 		ldr	r1, [r2, #8]
 575 038c 801081E3 		orr	r1, r1, #128
 576 0390 081082E5 		str	r1, [r2, #8]
 182:../lib/sd_raw.c **** 
 577              		.loc 1 182 0
 578 0394 001093E5 		ldr	r1, [r3, #0]
 579 0398 011B81E3 		orr	r1, r1, #1024
 580 039c 001083E5 		str	r1, [r3, #0]
 184:../lib/sd_raw.c **** 
 581              		.loc 1 184 0
 582 03a0 043092E5 		ldr	r3, [r2, #4]
 583 03a4 803083E3 		orr	r3, r3, #128
 584 03a8 043082E5 		str	r3, [r2, #4]
 187:../lib/sd_raw.c ****     S0SPCR = 0x38;
 585              		.loc 1 187 0
 586 03ac 00329FE5 		ldr	r3, .L98+8
 587 03b0 9610A0E3 		mov	r1, #150
 588 03b4 0C1083E5 		str	r1, [r3, #12]
 188:../lib/sd_raw.c **** 
 589              		.loc 1 188 0
 590 03b8 3810A0E3 		mov	r1, #56
 591 03bc 001083E5 		str	r1, [r3, #0]
 191:../lib/sd_raw.c ****     
 592              		.loc 1 191 0
 593 03c0 F0319FE5 		ldr	r3, .L98+12
 594 03c4 0010A0E3 		mov	r1, #0
 595 03c8 0C12C3E5 		strb	r1, [r3, #524]
 596              	.LVL46:
 597 03cc 0A50A0E3 		mov	r5, #10
 598 03d0 0240A0E1 		mov	r4, r2
 599              	.LVL47:
 600              	.L68:
 601 03d4 015045E2 		sub	r5, r5, #1
 602              	.LBB27:
 200:../lib/sd_raw.c ****     }
 603              		.loc 1 200 0 discriminator 2
 604 03d8 0FFFFFEB 		bl	sd_raw_rec_byte
 605              	.LVL48:
 197:../lib/sd_raw.c ****     {
 606              		.loc 1 197 0 discriminator 2
 607 03dc FF5015E2 		ands	r5, r5, #255
 608 03e0 FBFFFF1A 		bne	.L68
 609              	.LBE27:
 204:../lib/sd_raw.c **** 
 610              		.loc 1 204 0
 611 03e4 0C3094E5 		ldr	r3, [r4, #12]
 612 03e8 803083E3 		orr	r3, r3, #128
 613 03ec 0C3084E5 		str	r3, [r4, #12]
 614              	.LVL49:
 615 03f0 024CA0E3 		mov	r4, #512
 616              	.LVL50:
 617              	.L70:
 618              	.LBB28:
 210:../lib/sd_raw.c ****         if(response == (1 << R1_IDLE_STATE))
 619              		.loc 1 210 0
 620 03f4 0000A0E3 		mov	r0, #0
 621 03f8 0010A0E1 		mov	r1, r0
 622 03fc 11FFFFEB 		bl	sd_raw_send_command
 623              	.LVL51:
 211:../lib/sd_raw.c ****             break;
 624              		.loc 1 211 0
 625 0400 010050E3 		cmp	r0, #1
 210:../lib/sd_raw.c ****         if(response == (1 << R1_IDLE_STATE))
 626              		.loc 1 210 0
 627 0404 0050A0E1 		mov	r5, r0
 628              	.LVL52:
 211:../lib/sd_raw.c ****             break;
 629              		.loc 1 211 0
 630 0408 0400000A 		beq	.L69
 631 040c 014044E2 		sub	r4, r4, #1
 632 0410 0448A0E1 		mov	r4, r4, asl #16
 214:../lib/sd_raw.c ****         {
 633              		.loc 1 214 0
 634 0414 2448B0E1 		movs	r4, r4, lsr #16
 635 0418 F5FFFF1A 		bne	.L70
 636 041c 3A0000EA 		b	.L97
 637              	.L69:
 638              	.LBE28:
 223:../lib/sd_raw.c ****     if((response & (1 << R1_ILL_COMMAND)) == 0)
 639              		.loc 1 223 0
 640 0420 0800A0E3 		mov	r0, #8
 641              	.LVL53:
 642 0424 90119FE5 		ldr	r1, .L98+16
 643 0428 06FFFFEB 		bl	sd_raw_send_command
 644              	.LVL54:
 224:../lib/sd_raw.c ****     {
 645              		.loc 1 224 0
 646 042c 040010E3 		tst	r0, #4
 647 0430 0D00001A 		bne	.L72
 226:../lib/sd_raw.c ****         sd_raw_rec_byte();
 648              		.loc 1 226 0
 649 0434 F8FEFFEB 		bl	sd_raw_rec_byte
 650              	.LVL55:
 227:../lib/sd_raw.c ****         if((sd_raw_rec_byte() & 0x01) == 0)
 651              		.loc 1 227 0
 652 0438 F7FEFFEB 		bl	sd_raw_rec_byte
 653              	.LVL56:
 228:../lib/sd_raw.c ****             return 0; /* card operation voltage range doesn't match */
 654              		.loc 1 228 0
 655 043c F6FEFFEB 		bl	sd_raw_rec_byte
 656              	.LVL57:
 657 0440 010010E3 		tst	r0, #1
 658 0444 4500000A 		beq	.L96
 659              	.L73:
 230:../lib/sd_raw.c ****             return 0; /* wrong test pattern */
 660              		.loc 1 230 0
 661 0448 F3FEFFEB 		bl	sd_raw_rec_byte
 662              	.LVL58:
 663 044c AA0050E3 		cmp	r0, #170
 664 0450 4200001A 		bne	.L96
 234:../lib/sd_raw.c ****     }
 665              		.loc 1 234 0
 666 0454 5C319FE5 		ldr	r3, .L98+12
 667 0458 0220A0E3 		mov	r2, #2
 668 045c 0C22C3E5 		strb	r2, [r3, #524]
 669              	.L76:
 204:../lib/sd_raw.c **** 
 670              		.loc 1 204 0
 671 0460 0249A0E3 		mov	r4, #32768
 672              	.LBB29:
 256:../lib/sd_raw.c ****         {
 673              		.loc 1 256 0
 674 0464 4C519FE5 		ldr	r5, .L98+12
 675 0468 090000EA 		b	.L75
 676              	.LVL59:
 677              	.L72:
 678              	.LBE29:
 240:../lib/sd_raw.c ****         response = sd_raw_send_command(CMD_SD_SEND_OP_COND, 0);
 679              		.loc 1 240 0
 680 046c 0010A0E3 		mov	r1, #0
 681 0470 3700A0E3 		mov	r0, #55
 682              	.LVL60:
 683 0474 F3FEFFEB 		bl	sd_raw_send_command
 684              	.LVL61:
 241:../lib/sd_raw.c ****         if((response & (1 << R1_ILL_COMMAND)) == 0)
 685              		.loc 1 241 0
 686 0478 2900A0E3 		mov	r0, #41
 687 047c 0010A0E3 		mov	r1, #0
 688 0480 F0FEFFEB 		bl	sd_raw_send_command
 689              	.LVL62:
 242:../lib/sd_raw.c ****         {
 690              		.loc 1 242 0
 691 0484 040010E3 		tst	r0, #4
 245:../lib/sd_raw.c ****         }
 692              		.loc 1 245 0
 693 0488 28319F05 		ldreq	r3, .L98+12
 694 048c 0C52C305 		streqb	r5, [r3, #524]
 695 0490 F2FFFFEA 		b	.L76
 696              	.LVL63:
 697              	.L75:
 698              	.LBB31:
 256:../lib/sd_raw.c ****         {
 699              		.loc 1 256 0
 700 0494 0C32D5E5 		ldrb	r3, [r5, #524]	@ zero_extendqisi2
 701 0498 031013E2 		ands	r1, r3, #3
 268:../lib/sd_raw.c ****         }
 702              		.loc 1 268 0
 703 049c 0100A003 		moveq	r0, #1
 256:../lib/sd_raw.c ****         {
 704              		.loc 1 256 0
 705 04a0 0800000A 		beq	.L95
 706              	.LVL64:
 707              	.LBB30:
 258:../lib/sd_raw.c **** #if SD_RAW_SDHC
 708              		.loc 1 258 0
 709 04a4 020013E3 		tst	r3, #2
 710 04a8 0161A013 		movne	r6, #1073741824
 711 04ac 0060A003 		moveq	r6, #0
 712              	.LVL65:
 263:../lib/sd_raw.c ****             response = sd_raw_send_command(CMD_SD_SEND_OP_COND, arg);
 713              		.loc 1 263 0
 714 04b0 0010A0E3 		mov	r1, #0
 715 04b4 3700A0E3 		mov	r0, #55
 716 04b8 E2FEFFEB 		bl	sd_raw_send_command
 717              	.LVL66:
 264:../lib/sd_raw.c ****         }
 718              		.loc 1 264 0
 719 04bc 2900A0E3 		mov	r0, #41
 720 04c0 0610A0E1 		mov	r1, r6
 721 04c4 FFFFFFEA 		b	.L95
 722              	.LVL67:
 723              	.L95:
 724              	.LBE30:
 268:../lib/sd_raw.c ****         }
 725              		.loc 1 268 0
 726 04c8 DEFEFFEB 		bl	sd_raw_send_command
 727              	.LVL68:
 271:../lib/sd_raw.c ****             break;
 728              		.loc 1 271 0
 729 04cc 016010E2 		ands	r6, r0, #1
 730 04d0 0400000A 		beq	.L80
 731 04d4 014044E2 		sub	r4, r4, #1
 732 04d8 0448A0E1 		mov	r4, r4, asl #16
 274:../lib/sd_raw.c ****         {
 733              		.loc 1 274 0
 734 04dc 2448B0E1 		movs	r4, r4, lsr #16
 735 04e0 EBFFFF1A 		bne	.L75
 736 04e4 080000EA 		b	.L97
 737              	.L80:
 738              	.LBE31:
 282:../lib/sd_raw.c ****     {
 739              		.loc 1 282 0
 740 04e8 C8409FE5 		ldr	r4, .L98+12
 741 04ec 0C52D4E5 		ldrb	r5, [r4, #524]	@ zero_extendqisi2
 742 04f0 020015E3 		tst	r5, #2
 743 04f4 1000000A 		beq	.L81
 284:../lib/sd_raw.c ****         {
 744              		.loc 1 284 0
 745 04f8 3A00A0E3 		mov	r0, #58
 746              	.LVL69:
 747 04fc 0610A0E1 		mov	r1, r6
 748 0500 D0FEFFEB 		bl	sd_raw_send_command
 749              	.LVL70:
 750 0504 000050E3 		cmp	r0, #0
 751 0508 0400000A 		beq	.L82
 752              	.L97:
 286:../lib/sd_raw.c ****             return 0;
 753              		.loc 1 286 0
 754 050c 9C309FE5 		ldr	r3, .L98+4
 755 0510 042093E5 		ldr	r2, [r3, #4]
 756 0514 802082E3 		orr	r2, r2, #128
 757 0518 042083E5 		str	r2, [r3, #4]
 758 051c 0F0000EA 		b	.L96
 759              	.L82:
 290:../lib/sd_raw.c ****             sd_raw_card_type |= (1 << SD_RAW_SPEC_SDHC);
 760              		.loc 1 290 0
 761 0520 BDFEFFEB 		bl	sd_raw_rec_byte
 762              	.LVL71:
 763 0524 400010E3 		tst	r0, #64
 291:../lib/sd_raw.c **** 
 764              		.loc 1 291 0
 765 0528 04508513 		orrne	r5, r5, #4
 766 052c 0C52C415 		strneb	r5, [r4, #524]
 293:../lib/sd_raw.c ****         sd_raw_rec_byte();
 767              		.loc 1 293 0
 768 0530 B9FEFFEB 		bl	sd_raw_rec_byte
 769              	.LVL72:
 294:../lib/sd_raw.c ****         sd_raw_rec_byte();
 770              		.loc 1 294 0
 771 0534 B8FEFFEB 		bl	sd_raw_rec_byte
 772              	.LVL73:
 295:../lib/sd_raw.c ****     }
 773              		.loc 1 295 0
 774 0538 B7FEFFEB 		bl	sd_raw_rec_byte
 775              	.LVL74:
 776              	.L81:
 300:../lib/sd_raw.c ****     {
 777              		.loc 1 300 0
 778 053c 1000A0E3 		mov	r0, #16
 779 0540 021CA0E3 		mov	r1, #512
 780 0544 BFFEFFEB 		bl	sd_raw_send_command
 781              	.LVL75:
 782 0548 60309FE5 		ldr	r3, .L98+4
 302:../lib/sd_raw.c ****         return 0;
 783              		.loc 1 302 0
 784 054c 042093E5 		ldr	r2, [r3, #4]
 300:../lib/sd_raw.c ****     {
 785              		.loc 1 300 0
 786 0550 000050E3 		cmp	r0, #0
 302:../lib/sd_raw.c ****         return 0;
 787              		.loc 1 302 0
 788 0554 802082E3 		orr	r2, r2, #128
 789 0558 042083E5 		str	r2, [r3, #4]
 300:../lib/sd_raw.c ****     {
 790              		.loc 1 300 0
 791 055c 0100000A 		beq	.L84
 792              	.L96:
 303:../lib/sd_raw.c ****     }
 793              		.loc 1 303 0
 794 0560 0000A0E3 		mov	r0, #0
 795 0564 0E0000EA 		b	.L71
 796              	.L84:
 310:../lib/sd_raw.c **** 
 797              		.loc 1 310 0
 798 0568 44309FE5 		ldr	r3, .L98+8
 799 056c 3C20A0E3 		mov	r2, #60
 800 0570 0C2083E5 		str	r2, [r3, #12]
 314:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 801              		.loc 1 314 0
 802 0574 3C209FE5 		ldr	r2, .L98+12
 803 0578 0000E0E3 		mvn	r0, #0
 804 057c 0010E0E3 		mvn	r1, #0
 316:../lib/sd_raw.c **** #endif
 805              		.loc 1 316 0
 806 0580 0130A0E3 		mov	r3, #1
 314:../lib/sd_raw.c **** #if SD_RAW_WRITE_BUFFERING
 807              		.loc 1 314 0
 808 0584 030082E9 		stmib	r2, {r0-r1}
 316:../lib/sd_raw.c **** #endif
 809              		.loc 1 316 0
 810 0588 0C30C2E4 		strb	r3, [r2], #12
 318:../lib/sd_raw.c ****         return 0;
 811              		.loc 1 318 0
 812 058c 0000A0E3 		mov	r0, #0
 813 0590 0010A0E3 		mov	r1, #0
 814 0594 023CA0E3 		mov	r3, #512
 815 0598 FEFFFFEB 		bl	sd_raw_read
 816              	.LVL76:
 322:../lib/sd_raw.c **** }
 817              		.loc 1 322 0
 818 059c 000090E2 		adds	r0, r0, #0
 819 05a0 0100A013 		movne	r0, #1
 820              	.L71:
 323:../lib/sd_raw.c **** 
 821              		.loc 1 323 0
 822 05a4 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 823 05a8 1EFF2FE1 		bx	lr
 824              	.L99:
 825              		.align	2
 826              	.L98:
 827 05ac 00C002E0 		.word	-536690688
 828 05b0 008002E0 		.word	-536707072
 829 05b4 000002E0 		.word	-536739840
 830 05b8 00000000 		.word	.LANCHOR0
 831 05bc AA010000 		.word	426
 832              		.cfi_endproc
 833              	.LFE0:
 835              		.align	2
 836              		.global	sd_raw_write
 838              	sd_raw_write:
 839              	.LFB8:
 657:../lib/sd_raw.c ****     if(sd_raw_locked())
 840              		.loc 1 657 0
 841              		.cfi_startproc
 842              		@ Function supports interworking.
 843              		@ args = 0, pretend = 0, frame = 16
 844              		@ frame_needed = 0, uses_anonymous_args = 0
 845              	.LVL77:
 846 05c0 FF4F2DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 847              	.LCFI5:
 848              		.cfi_def_cfa_offset 52
 849              		.cfi_offset 0, -52
 850              		.cfi_offset 1, -48
 851              		.cfi_offset 2, -44
 852              		.cfi_offset 3, -40
 853              		.cfi_offset 4, -36
 854              		.cfi_offset 5, -32
 855              		.cfi_offset 6, -28
 856              		.cfi_offset 7, -24
 857              		.cfi_offset 8, -20
 858              		.cfi_offset 9, -16
 859              		.cfi_offset 10, -12
 860              		.cfi_offset 11, -8
 861              		.cfi_offset 14, -4
 862              	.LBB32:
 676:../lib/sd_raw.c ****         {
 863              		.loc 1 676 0
 864 05c4 B8819FE5 		ldr	r8, .L126
 865              	.LBE32:
 657:../lib/sd_raw.c ****     if(sd_raw_locked())
 866              		.loc 1 657 0
 867 05c8 03008DE8 		stmia	sp, {r0-r1}
 868 05cc 02A0A0E1 		mov	sl, r2
 869 05d0 0370A0E1 		mov	r7, r3
 870              	.LBB34:
 691:../lib/sd_raw.c ****         {
 871              		.loc 1 691 0
 872 05d4 0C9088E2 		add	r9, r8, #12
 873 05d8 630000EA 		b	.L101
 874              	.LVL78:
 875              	.L117:
 667:../lib/sd_raw.c ****         block_address = offset - block_offset;
 876              		.loc 1 667 0
 877 05dc 06009DE8 		ldmia	sp, {r1-r2}
 878 05e0 A0319FE5 		ldr	r3, .L126+4
 879 05e4 031001E0 		and	r1, r1, r3
 880 05e8 01B8A0E1 		mov	fp, r1, asl #16
 881 05ec 2BB8A0E1 		mov	fp, fp, lsr #16
 882              	.LVL79:
 883 05f0 0040A0E3 		mov	r4, #0
 669:../lib/sd_raw.c ****         if(write_length > length)
 884              		.loc 1 669 0
 885 05f4 026C6BE2 		rsb	r6, fp, #512
 667:../lib/sd_raw.c ****         block_address = offset - block_offset;
 886              		.loc 1 667 0
 887 05f8 042002E0 		and	r2, r2, r4
 669:../lib/sd_raw.c ****         if(write_length > length)
 888              		.loc 1 669 0
 889 05fc 0668A0E1 		mov	r6, r6, asl #16
 668:../lib/sd_raw.c ****         write_length = 512 - block_offset; /* write up to block border */
 890              		.loc 1 668 0
 891 0600 30009DE8 		ldmia	sp, {r4-r5}
 669:../lib/sd_raw.c ****         if(write_length > length)
 892              		.loc 1 669 0
 893 0604 2668A0E1 		mov	r6, r6, lsr #16
 668:../lib/sd_raw.c ****         write_length = 512 - block_offset; /* write up to block border */
 894              		.loc 1 668 0
 895 0608 014054E0 		subs	r4, r4, r1
 896 060c 0250C5E0 		sbc	r5, r5, r2
 897              	.LVL80:
 667:../lib/sd_raw.c ****         block_address = offset - block_offset;
 898              		.loc 1 667 0
 899 0610 08108DE5 		str	r1, [sp, #8]
 900 0614 0C208DE5 		str	r2, [sp, #12]
 670:../lib/sd_raw.c ****             write_length = length;
 901              		.loc 1 670 0
 902 0618 070056E1 		cmp	r6, r7
 676:../lib/sd_raw.c ****         {
 903              		.loc 1 676 0
 904 061c 0C0098E9 		ldmib	r8, {r2-r3}
 671:../lib/sd_raw.c ****         
 905              		.loc 1 671 0
 906 0620 0768A081 		movhi	r6, r7, asl #16
 907              	.LVL81:
 908 0624 2668A081 		movhi	r6, r6, lsr #16
 909              	.LVL82:
 676:../lib/sd_raw.c ****         {
 910              		.loc 1 676 0
 911 0628 030055E1 		cmp	r5, r3
 912              		it eq
 913 062c 02005401 		cmpeq	r4, r2
 914 0630 0F00000A 		beq	.L103
 679:../lib/sd_raw.c ****                 return 0;
 915              		.loc 1 679 0
 916 0634 FEFFFFEB 		bl	sd_raw_sync
 917              	.LVL83:
 918 0638 000050E3 		cmp	r0, #0
 919 063c 2C00000A 		beq	.L125
 920              	.L104:
 683:../lib/sd_raw.c ****             {
 921              		.loc 1 683 0
 922 0640 020C56E3 		cmp	r6, #512
 923 0644 00005B23 		cmpcs	fp, #0
 924 0648 0100001A 		bne	.L106
 925              	.L108:
 688:../lib/sd_raw.c ****         }
 926              		.loc 1 688 0
 927 064c 300088E9 		stmib	r8, {r4-r5}
 928 0650 070000EA 		b	.L103
 929              	.L106:
 685:../lib/sd_raw.c ****                     return 0;
 930              		.loc 1 685 0
 931 0654 0400A0E1 		mov	r0, r4
 932 0658 0510A0E1 		mov	r1, r5
 933 065c 28219FE5 		ldr	r2, .L126+8
 934 0660 023CA0E3 		mov	r3, #512
 935 0664 FEFFFFEB 		bl	sd_raw_read
 936              	.LVL84:
 937 0668 000050E3 		cmp	r0, #0
 938 066c F6FFFF1A 		bne	.L108
 939 0670 1F0000EA 		b	.L125
 940              	.L103:
 691:../lib/sd_raw.c ****         {
 941              		.loc 1 691 0
 942 0674 09005AE1 		cmp	sl, r9
 943 0678 0900001A 		bne	.L109
 944              	.L112:
 704:../lib/sd_raw.c **** 
 945              		.loc 1 704 0
 946 067c 0C319FE5 		ldr	r3, .L126+12
 947 0680 0C2093E5 		ldr	r2, [r3, #12]
 948 0684 802082E3 		orr	r2, r2, #128
 949 0688 0C2083E5 		str	r2, [r3, #12]
 708:../lib/sd_raw.c **** #else
 950              		.loc 1 708 0
 951 068c 0C32D8E5 		ldrb	r3, [r8, #524]	@ zero_extendqisi2
 952 0690 040013E3 		tst	r3, #4
 953 0694 A414A011 		movne	r1, r4, lsr #9
 954 0698 851B8111 		orrne	r1, r1, r5, asl #23
 955 069c 0C00001A 		bne	.L113
 956 06a0 0A0000EA 		b	.L124
 957              	.L109:
 693:../lib/sd_raw.c **** 
 958              		.loc 1 693 0
 959 06a4 08109DE5 		ldr	r1, [sp, #8]
 960 06a8 0620A0E1 		mov	r2, r6
 961 06ac 010089E0 		add	r0, r9, r1
 962 06b0 0A10A0E1 		mov	r1, sl
 963 06b4 FEFFFFEB 		bl	memcpy
 964              	.LVL85:
 696:../lib/sd_raw.c **** 
 965              		.loc 1 696 0
 966 06b8 0030A0E3 		mov	r3, #0
 698:../lib/sd_raw.c ****                 return 1;
 967              		.loc 1 698 0
 968 06bc 060057E1 		cmp	r7, r6
 696:../lib/sd_raw.c **** 
 969              		.loc 1 696 0
 970 06c0 0030C8E5 		strb	r3, [r8, #0]
 698:../lib/sd_raw.c ****                 return 1;
 971              		.loc 1 698 0
 972 06c4 ECFFFF1A 		bne	.L112
 973              	.LVL86:
 974              	.L118:
 699:../lib/sd_raw.c **** #endif
 975              		.loc 1 699 0
 976 06c8 0100A0E3 		mov	r0, #1
 977 06cc 290000EA 		b	.L105
 978              	.LVL87:
 979              	.L124:
 708:../lib/sd_raw.c **** #else
 980              		.loc 1 708 0 discriminator 2
 981 06d0 0410A0E1 		mov	r1, r4
 982              	.L113:
 708:../lib/sd_raw.c **** #else
 983              		.loc 1 708 0 is_stmt 0 discriminator 3
 984 06d4 1800A0E3 		mov	r0, #24
 985 06d8 5AFEFFEB 		bl	sd_raw_send_command
 986              	.LVL88:
 987 06dc 004050E2 		subs	r4, r0, #0
 988              	.LVL89:
 989 06e0 0500000A 		beq	.L114
 713:../lib/sd_raw.c ****             return 0;
 990              		.loc 1 713 0 is_stmt 1
 991 06e4 A4309FE5 		ldr	r3, .L126+12
 992 06e8 042093E5 		ldr	r2, [r3, #4]
 993 06ec 802082E3 		orr	r2, r2, #128
 994 06f0 042083E5 		str	r2, [r3, #4]
 995              	.L125:
 714:../lib/sd_raw.c ****         }
 996              		.loc 1 714 0
 997 06f4 0000A0E3 		mov	r0, #0
 998 06f8 1E0000EA 		b	.L105
 999              	.L114:
 718:../lib/sd_raw.c **** 
 1000              		.loc 1 718 0
 1001 06fc FE00A0E3 		mov	r0, #254
 1002 0700 3EFEFFEB 		bl	sd_raw_send_byte
 1003              	.LVL90:
 1004              	.LBB33:
 723:../lib/sd_raw.c **** 
 1005              		.loc 1 723 0
 1006 0704 80509FE5 		ldr	r5, .L126+8
 1007              	.LVL91:
 1008              	.L115:
 723:../lib/sd_raw.c **** 
 1009              		.loc 1 723 0 is_stmt 0 discriminator 2
 1010 0708 0400D5E7 		ldrb	r0, [r5, r4]	@ zero_extendqisi2
 1011 070c 014084E2 		add	r4, r4, #1
 1012 0710 3AFEFFEB 		bl	sd_raw_send_byte
 1013              	.LVL92:
 722:../lib/sd_raw.c ****             sd_raw_send_byte(*cache++);
 1014              		.loc 1 722 0 is_stmt 1 discriminator 2
 1015 0714 020C54E3 		cmp	r4, #512
 1016 0718 FAFFFF1A 		bne	.L115
 1017              	.LBE33:
 726:../lib/sd_raw.c ****         sd_raw_send_byte(0xff);
 1018              		.loc 1 726 0
 1019 071c FF00A0E3 		mov	r0, #255
 1020 0720 36FEFFEB 		bl	sd_raw_send_byte
 1021              	.LVL93:
 727:../lib/sd_raw.c **** 
 1022              		.loc 1 727 0
 1023 0724 FF00A0E3 		mov	r0, #255
 1024 0728 34FEFFEB 		bl	sd_raw_send_byte
 1025              	.LVL94:
 1026              	.L116:
 730:../lib/sd_raw.c ****         sd_raw_rec_byte();
 1027              		.loc 1 730 0 discriminator 1
 1028 072c 3AFEFFEB 		bl	sd_raw_rec_byte
 1029              	.LVL95:
 1030 0730 FF0050E3 		cmp	r0, #255
 1031 0734 FCFFFF1A 		bne	.L116
 731:../lib/sd_raw.c **** 
 1032              		.loc 1 731 0
 1033 0738 37FEFFEB 		bl	sd_raw_rec_byte
 1034              	.LVL96:
 734:../lib/sd_raw.c **** 
 1035              		.loc 1 734 0
 1036 073c 4C309FE5 		ldr	r3, .L126+12
 1037 0740 042093E5 		ldr	r2, [r3, #4]
 1038 0744 802082E3 		orr	r2, r2, #128
 1039 0748 042083E5 		str	r2, [r3, #4]
 737:../lib/sd_raw.c ****         length -= write_length;
 1040              		.loc 1 737 0
 1041 074c 0C009DE8 		ldmia	sp, {r2-r3}
 1042 0750 062092E0 		adds	r2, r2, r6
 1043 0754 0030A3E2 		adc	r3, r3, #0
 1044 0758 0C008DE8 		stmia	sp, {r2-r3}
 741:../lib/sd_raw.c **** #endif
 1045              		.loc 1 741 0
 1046 075c 0130A0E3 		mov	r3, #1
 1047 0760 0030C8E5 		strb	r3, [r8, #0]
 736:../lib/sd_raw.c ****         offset += write_length;
 1048              		.loc 1 736 0
 1049 0764 06A08AE0 		add	sl, sl, r6
 1050              	.LVL97:
 738:../lib/sd_raw.c **** 
 1051              		.loc 1 738 0
 1052 0768 077066E0 		rsb	r7, r6, r7
 1053              	.LVL98:
 1054              	.L101:
 1055              	.LBE34:
 664:../lib/sd_raw.c ****     {
 1056              		.loc 1 664 0 discriminator 1
 1057 076c 000057E3 		cmp	r7, #0
 1058 0770 99FFFF1A 		bne	.L117
 1059 0774 D3FFFFEA 		b	.L118
 1060              	.L105:
 746:../lib/sd_raw.c **** #endif
 1061              		.loc 1 746 0
 1062 0778 10D08DE2 		add	sp, sp, #16
 1063 077c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1064 0780 1EFF2FE1 		bx	lr
 1065              	.L127:
 1066              		.align	2
 1067              	.L126:
 1068 0784 00000000 		.word	.LANCHOR0
 1069 0788 FF010000 		.word	511
 1070 078c 0C000000 		.word	.LANCHOR0+12
 1071 0790 008002E0 		.word	-536707072
 1072              		.cfi_endproc
 1073              	.LFE8:
 1075              		.align	2
 1076              		.global	sd_raw_write_interval
 1078              	sd_raw_write_interval:
 1079              	.LFB9:
 769:../lib/sd_raw.c **** #if SD_RAW_SAVE_RAM
 1080              		.loc 1 769 0
 1081              		.cfi_startproc
 1082              		@ Function supports interworking.
 1083              		@ args = 8, pretend = 0, frame = 0
 1084              		@ frame_needed = 0, uses_anonymous_args = 0
 1085              	.LVL99:
 1086 0794 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 36
 1089              		.cfi_offset 4, -36
 1090              		.cfi_offset 5, -32
 1091              		.cfi_offset 6, -28
 1092              		.cfi_offset 7, -24
 1093              		.cfi_offset 8, -20
 1094              		.cfi_offset 9, -16
 1095              		.cfi_offset 10, -12
 1096              		.cfi_offset 11, -8
 1097              		.cfi_offset 14, -4
 769:../lib/sd_raw.c **** #if SD_RAW_SAVE_RAM
 1098              		.loc 1 769 0
 1099 0798 24A09DE5 		ldr	sl, [sp, #36]
 774:../lib/sd_raw.c ****         return 0;
 1100              		.loc 1 774 0
 1101 079c 000052E3 		cmp	r2, #0
 1102 07a0 00005A13 		cmpne	sl, #0
 769:../lib/sd_raw.c **** #if SD_RAW_SAVE_RAM
 1103              		.loc 1 769 0
 1104 07a4 0040A0E1 		mov	r4, r0
 1105 07a8 0150A0E1 		mov	r5, r1
 1106 07ac 0360A0E1 		mov	r6, r3
 774:../lib/sd_raw.c ****         return 0;
 1107              		.loc 1 774 0
 1108 07b0 0270A0E1 		mov	r7, r2
 1109 07b4 0100001A 		bne	.L129
 1110              	.LVL100:
 1111              	.L134:
 775:../lib/sd_raw.c **** 
 1112              		.loc 1 775 0
 1113 07b8 0000A0E3 		mov	r0, #0
 1114 07bc 230000EA 		b	.L130
 1115              	.LVL101:
 1116              	.L129:
 777:../lib/sd_raw.c ****     while(endless || length > 0)
 1117              		.loc 1 777 0
 1118 07c0 018073E2 		rsbs	r8, r3, #1
 1119 07c4 0080A033 		movcc	r8, #0
 1120              	.LVL102:
 778:../lib/sd_raw.c ****     {
 1121              		.loc 1 778 0
 1122 07c8 1A0000EA 		b	.L131
 1123              	.LVL103:
 1124              	.L135:
 1125              	.LBB35:
 780:../lib/sd_raw.c ****         if(!bytes_to_write)
 1126              		.loc 1 780 0
 1127 07cc 0700A0E1 		mov	r0, r7
 1128 07d0 0410A0E1 		mov	r1, r4
 1129 07d4 0520A0E1 		mov	r2, r5
 1130 07d8 28309DE5 		ldr	r3, [sp, #40]
 1131 07dc 0FE0A0E1 		mov	lr, pc
 1132 07e0 1AFF2FE1 		bx	sl
 1133              	.LVL104:
 1134 07e4 00C8A0E1 		mov	ip, r0, asl #16
 1135              	.LVL105:
 781:../lib/sd_raw.c ****             break;
 1136              		.loc 1 781 0
 1137 07e8 2CB8B0E1 		movs	fp, ip, lsr #16
 1138 07ec 0100001A 		bne	.L132
 1139              	.LVL106:
 1140              	.L136:
 1141              	.LBE35:
 796:../lib/sd_raw.c **** }
 1142              		.loc 1 796 0
 1143 07f0 0100A0E3 		mov	r0, #1
 1144 07f4 150000EA 		b	.L130
 1145              	.LVL107:
 1146              	.L132:
 1147              	.LBB36:
 783:../lib/sd_raw.c ****             return 0;
 1148              		.loc 1 783 0
 1149 07f8 000058E3 		cmp	r8, #0
 1150 07fc 0100001A 		bne	.L133
 783:../lib/sd_raw.c ****             return 0;
 1151              		.loc 1 783 0 is_stmt 0 discriminator 1
 1152 0800 06005BE1 		cmp	fp, r6
 1153 0804 EBFFFF8A 		bhi	.L134
 1154              	.L133:
 789:../lib/sd_raw.c ****             return 0;
 1155              		.loc 1 789 0 is_stmt 1
 1156 0808 0098A0E1 		mov	r9, r0, asl #16
 1157 080c 2998A0E1 		mov	r9, r9, lsr #16
 1158 0810 0400A0E1 		mov	r0, r4
 1159 0814 0510A0E1 		mov	r1, r5
 1160 0818 0720A0E1 		mov	r2, r7
 1161 081c 0930A0E1 		mov	r3, r9
 1162 0820 FEFFFFEB 		bl	sd_raw_write
 1163              	.LVL108:
 1164 0824 000050E3 		cmp	r0, #0
 1165 0828 E2FFFF0A 		beq	.L134
 792:../lib/sd_raw.c ****         length -= bytes_to_write;
 1166              		.loc 1 792 0
 1167 082c 0B4094E0 		adds	r4, r4, fp
 1168              	.LVL109:
 1169 0830 0050A5E2 		adc	r5, r5, #0
 1170              	.LVL110:
 793:../lib/sd_raw.c ****     }
 1171              		.loc 1 793 0
 1172 0834 066069E0 		rsb	r6, r9, r6
 1173              	.LVL111:
 1174              	.L131:
 1175              	.LBE36:
 778:../lib/sd_raw.c ****     {
 1176              		.loc 1 778 0 discriminator 1
 1177 0838 000056E3 		cmp	r6, #0
 1178 083c 0830A001 		moveq	r3, r8
 1179 0840 01308813 		orrne	r3, r8, #1
 1180 0844 000053E3 		cmp	r3, #0
 1181 0848 DFFFFF1A 		bne	.L135
 1182 084c E7FFFFEA 		b	.L136
 1183              	.LVL112:
 1184              	.L130:
 797:../lib/sd_raw.c **** #endif
 1185              		.loc 1 797 0
 1186 0850 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1187 0854 1EFF2FE1 		bx	lr
 1188              		.cfi_endproc
 1189              	.LFE9:
 1191              		.align	2
 1192              		.global	sd_raw_get_info
 1194              	sd_raw_get_info:
 1195              	.LFB11:
 842:../lib/sd_raw.c ****     if(!info || !sd_raw_available())
 1196              		.loc 1 842 0
 1197              		.cfi_startproc
 1198              		@ Function supports interworking.
 1199              		@ args = 0, pretend = 0, frame = 0
 1200              		@ frame_needed = 0, uses_anonymous_args = 0
 1201              	.LVL113:
 1202 0858 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1203              	.LCFI7:
 1204              		.cfi_def_cfa_offset 36
 1205              		.cfi_offset 4, -36
 1206              		.cfi_offset 5, -32
 1207              		.cfi_offset 6, -28
 1208              		.cfi_offset 7, -24
 1209              		.cfi_offset 8, -20
 1210              		.cfi_offset 9, -16
 1211              		.cfi_offset 10, -12
 1212              		.cfi_offset 11, -8
 1213              		.cfi_offset 14, -4
 843:../lib/sd_raw.c ****         return 0;
 1214              		.loc 1 843 0
 1215 085c 004050E2 		subs	r4, r0, #0
 844:../lib/sd_raw.c **** 
 1216              		.loc 1 844 0
 1217 0860 0400A001 		moveq	r0, r4
 1218              	.LVL114:
 843:../lib/sd_raw.c ****         return 0;
 1219              		.loc 1 843 0
 1220 0864 A500000A 		beq	.L141
 848:../lib/sd_raw.c **** 
 1221              		.loc 1 848 0
 1222 0868 98529FE5 		ldr	r5, .L195
 846:../lib/sd_raw.c **** 
 1223              		.loc 1 846 0
 1224 086c 0010A0E3 		mov	r1, #0
 1225 0870 2020A0E3 		mov	r2, #32
 1226 0874 FEFFFFEB 		bl	memset
 1227              	.LVL115:
 848:../lib/sd_raw.c **** 
 1228              		.loc 1 848 0
 1229 0878 0C3095E5 		ldr	r3, [r5, #12]
 1230 087c 803083E3 		orr	r3, r3, #128
 1231 0880 0C3085E5 		str	r3, [r5, #12]
 851:../lib/sd_raw.c ****     {
 1232              		.loc 1 851 0
 1233 0884 0A00A0E3 		mov	r0, #10
 1234 0888 0010A0E3 		mov	r1, #0
 1235 088c EDFDFFEB 		bl	sd_raw_send_command
 1236              	.LVL116:
 1237 0890 000050E3 		cmp	r0, #0
 853:../lib/sd_raw.c ****         return 0;
 1238              		.loc 1 853 0
 1239 0894 04309515 		ldrne	r3, [r5, #4]
 1240 0898 80308313 		orrne	r3, r3, #128
 1241 089c 04308515 		strne	r3, [r5, #4]
 1242 08a0 3A00001A 		bne	.L194
 1243              	.L183:
 856:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 18; ++i)
 1244              		.loc 1 856 0
 1245 08a4 DCFDFFEB 		bl	sd_raw_rec_byte
 1246              	.LVL117:
 1247 08a8 FE0050E3 		cmp	r0, #254
 1248 08ac FCFFFF1A 		bne	.L183
 1249 08b0 0450A0E1 		mov	r5, r4
 1250 08b4 6060A0E3 		mov	r6, #96
 1251              	.L152:
 841:../lib/sd_raw.c **** {
 1252              		.loc 1 841 0
 1253 08b8 057064E0 		rsb	r7, r4, r5
 1254 08bc FF7007E2 		and	r7, r7, #255
 1255              	.LBB37:
 1256              	.LBB38:
 859:../lib/sd_raw.c **** 
 1257              		.loc 1 859 0
 1258 08c0 D5FDFFEB 		bl	sd_raw_rec_byte
 1259              	.LVL118:
 861:../lib/sd_raw.c ****         {
 1260              		.loc 1 861 0
 1261 08c4 0E0057E3 		cmp	r7, #14
 1262 08c8 07F19F97 		ldrls	pc, [pc, r7, asl #2]
 1263 08cc 220000EA 		b	.L143
 1264              	.L151:
 1265 08d0 0C090000 		.word	.L144
 1266 08d4 14090000 		.word	.L145
 1267 08d8 14090000 		.word	.L145
 1268 08dc 1C090000 		.word	.L146
 1269 08e0 1C090000 		.word	.L146
 1270 08e4 1C090000 		.word	.L146
 1271 08e8 1C090000 		.word	.L146
 1272 08ec 1C090000 		.word	.L146
 1273 08f0 24090000 		.word	.L147
 1274 08f4 2C090000 		.word	.L148
 1275 08f8 2C090000 		.word	.L148
 1276 08fc 2C090000 		.word	.L148
 1277 0900 2C090000 		.word	.L148
 1278 0904 3C090000 		.word	.L149
 1279 0908 48090000 		.word	.L150
 1280              	.L144:
 864:../lib/sd_raw.c ****                 break;
 1281              		.loc 1 864 0
 1282 090c 0000C4E5 		strb	r0, [r4, #0]
 865:../lib/sd_raw.c ****             case 1:
 1283              		.loc 1 865 0
 1284 0910 110000EA 		b	.L143
 1285              	.L145:
 868:../lib/sd_raw.c ****                 break;
 1286              		.loc 1 868 0
 1287 0914 0000C5E5 		strb	r0, [r5, #0]
 869:../lib/sd_raw.c ****             case 3:
 1288              		.loc 1 869 0
 1289 0918 0F0000EA 		b	.L143
 1290              	.L146:
 875:../lib/sd_raw.c ****                 break;
 1291              		.loc 1 875 0
 1292 091c 0100C5E5 		strb	r0, [r5, #1]
 876:../lib/sd_raw.c ****             case 8:
 1293              		.loc 1 876 0
 1294 0920 0D0000EA 		b	.L143
 1295              	.L147:
 878:../lib/sd_raw.c ****                 break;
 1296              		.loc 1 878 0
 1297 0924 0A00C4E5 		strb	r0, [r4, #10]
 879:../lib/sd_raw.c ****             case 9:
 1298              		.loc 1 879 0
 1299 0928 0B0000EA 		b	.L143
 1300              	.L148:
 884:../lib/sd_raw.c ****                 break;
 1301              		.loc 1 884 0
 1302 092c 0C3094E5 		ldr	r3, [r4, #12]
 1303 0930 100683E1 		orr	r0, r3, r0, asl r6
 1304              	.LVL119:
 1305 0934 0C0084E5 		str	r0, [r4, #12]
 885:../lib/sd_raw.c ****             case 13:
 1306              		.loc 1 885 0
 1307 0938 070000EA 		b	.L143
 1308              	.LVL120:
 1309              	.L149:
 887:../lib/sd_raw.c ****                 break;
 1310              		.loc 1 887 0
 1311 093c 0002A0E1 		mov	r0, r0, asl #4
 1312              	.LVL121:
 1313 0940 1000C4E5 		strb	r0, [r4, #16]
 888:../lib/sd_raw.c ****             case 14:
 1314              		.loc 1 888 0
 1315 0944 040000EA 		b	.L143
 1316              	.LVL122:
 1317              	.L150:
 890:../lib/sd_raw.c ****                 info->manufacturing_month = b & 0x0f;
 1318              		.loc 1 890 0
 1319 0948 1030D4E5 		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 1320 094c 203283E1 		orr	r3, r3, r0, lsr #4
 891:../lib/sd_raw.c ****                 break;
 1321              		.loc 1 891 0
 1322 0950 0F0000E2 		and	r0, r0, #15
 1323              	.LVL123:
 890:../lib/sd_raw.c ****                 info->manufacturing_month = b & 0x0f;
 1324              		.loc 1 890 0
 1325 0954 1030C4E5 		strb	r3, [r4, #16]
 891:../lib/sd_raw.c ****                 break;
 1326              		.loc 1 891 0
 1327 0958 1100C4E5 		strb	r0, [r4, #17]
 1328              	.L143:
 1329              	.LVL124:
 1330 095c 086046E2 		sub	r6, r6, #8
 1331              	.LBE38:
 857:../lib/sd_raw.c ****     {
 1332              		.loc 1 857 0
 1333 0960 300076E3 		cmn	r6, #48
 1334 0964 015085E2 		add	r5, r5, #1
 1335 0968 D2FFFF1A 		bne	.L152
 1336              	.LVL125:
 1337              	.LBE37:
 904:../lib/sd_raw.c ****     {
 1338              		.loc 1 904 0
 1339 096c 0900A0E3 		mov	r0, #9
 1340 0970 0010A0E3 		mov	r1, #0
 1341 0974 B3FDFFEB 		bl	sd_raw_send_command
 1342              	.LVL126:
 1343 0978 000050E3 		cmp	r0, #0
 1344 097c 0500000A 		beq	.L182
 906:../lib/sd_raw.c ****         return 0;
 1345              		.loc 1 906 0
 1346 0980 80319FE5 		ldr	r3, .L195
 1347 0984 042093E5 		ldr	r2, [r3, #4]
 1348 0988 802082E3 		orr	r2, r2, #128
 1349 098c 042083E5 		str	r2, [r3, #4]
 1350              	.LVL127:
 1351              	.L194:
 907:../lib/sd_raw.c ****     }
 1352              		.loc 1 907 0
 1353 0990 0000A0E3 		mov	r0, #0
 1354 0994 590000EA 		b	.L141
 1355              	.LVL128:
 1356              	.L182:
 909:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 18; ++i)
 1357              		.loc 1 909 0
 1358 0998 9FFDFFEB 		bl	sd_raw_rec_byte
 1359              	.LVL129:
 1360 099c FE0050E3 		cmp	r0, #254
 1361 09a0 FCFFFF1A 		bne	.L182
 1362 09a4 0060A0E3 		mov	r6, #0
 1363              	.LBB39:
 1364              	.LBB40:
 927:../lib/sd_raw.c ****             {
 1365              		.loc 1 927 0
 1366 09a8 5C919FE5 		ldr	r9, .L195+4
 1367              	.LBE40:
 1368              	.LBE39:
 909:../lib/sd_raw.c ****     for(uint8_t i = 0; i < 18; ++i)
 1369              		.loc 1 909 0
 1370 09ac 0650A0E1 		mov	r5, r6
 1371 09b0 0670A0E1 		mov	r7, r6
 1372 09b4 06A0A0E1 		mov	sl, r6
 1373              	.LBB42:
 1374              	.LBB41:
 972:../lib/sd_raw.c **** 
 1375              		.loc 1 972 0
 1376 09b8 06B0A0E1 		mov	fp, r6
 921:../lib/sd_raw.c ****             info->format = (b & 0x0c) >> 2;
 1377              		.loc 1 921 0
 1378 09bc 0180A0E3 		mov	r8, #1
 1379              	.LVL130:
 1380              	.L170:
 912:../lib/sd_raw.c **** 
 1381              		.loc 1 912 0
 1382 09c0 95FDFFEB 		bl	sd_raw_rec_byte
 1383              	.LVL131:
 914:../lib/sd_raw.c ****         {
 1384              		.loc 1 914 0
 1385 09c4 0E0056E3 		cmp	r6, #14
 1386 09c8 0900001A 		bne	.L154
 916:../lib/sd_raw.c ****                 info->flag_copy = 1;
 1387              		.loc 1 916 0
 1388 09cc 400010E3 		tst	r0, #64
 917:../lib/sd_raw.c ****             if(b & 0x20)
 1389              		.loc 1 917 0
 1390 09d0 1C80C415 		strneb	r8, [r4, #28]
 918:../lib/sd_raw.c ****                 info->flag_write_protect = 1;
 1391              		.loc 1 918 0
 1392 09d4 200010E3 		tst	r0, #32
 919:../lib/sd_raw.c ****             if(b & 0x10)
 1393              		.loc 1 919 0
 1394 09d8 1D80C415 		strneb	r8, [r4, #29]
 920:../lib/sd_raw.c ****                 info->flag_write_protect_temp = 1;
 1395              		.loc 1 920 0
 1396 09dc 100010E3 		tst	r0, #16
 922:../lib/sd_raw.c ****         }
 1397              		.loc 1 922 0
 1398 09e0 0C0000E2 		and	r0, r0, #12
 1399              	.LVL132:
 1400 09e4 4001A0E1 		mov	r0, r0, asr #2
 921:../lib/sd_raw.c ****             info->format = (b & 0x0c) >> 2;
 1401              		.loc 1 921 0
 1402 09e8 1E80C415 		strneb	r8, [r4, #30]
 922:../lib/sd_raw.c ****         }
 1403              		.loc 1 922 0
 1404 09ec 1F00C4E5 		strb	r0, [r4, #31]
 1405 09f0 380000EA 		b	.L158
 1406              	.LVL133:
 1407              	.L154:
 927:../lib/sd_raw.c ****             {
 1408              		.loc 1 927 0
 1409 09f4 0C32D9E5 		ldrb	r3, [r9, #524]	@ zero_extendqisi2
 1410 09f8 020013E3 		tst	r3, #2
 1411 09fc 1300000A 		beq	.L159
 929:../lib/sd_raw.c ****                 {
 1412              		.loc 1 929 0
 1413 0a00 070056E3 		cmp	r6, #7
 1414 0a04 0300000A 		beq	.L161
 1415 0a08 0600003A 		bcc	.L160
 1416 0a0c 090056E3 		cmp	r6, #9
 1417 0a10 3000008A 		bhi	.L158
 1418 0a14 000000EA 		b	.L162
 1419              	.L161:
 932:../lib/sd_raw.c ****                     case 8:
 1420              		.loc 1 932 0
 1421 0a18 3F0000E2 		and	r0, r0, #63
 1422              	.LVL134:
 1423              	.L162:
 936:../lib/sd_raw.c ****                         break;
 1424              		.loc 1 936 0
 1425 0a1c 055480E1 		orr	r5, r0, r5, asl #8
 1426              	.LVL135:
 1427 0a20 0558A0E1 		mov	r5, r5, asl #16
 1428 0a24 2558A0E1 		mov	r5, r5, lsr #16
 1429              	.LVL136:
 1430              	.L160:
 939:../lib/sd_raw.c ****                 {
 1431              		.loc 1 939 0
 1432 0a28 090056E3 		cmp	r6, #9
 1433 0a2c 2900001A 		bne	.L158
 941:../lib/sd_raw.c ****                     info->capacity = (offset_t) csd_c_size * 512 * 1024;
 1434              		.loc 1 941 0
 1435 0a30 015085E2 		add	r5, r5, #1
 1436              	.LVL137:
 1437 0a34 0538A0E1 		mov	r3, r5, asl #16
 1438 0a38 2358A0E1 		mov	r5, r3, lsr #16
 1439              	.LVL138:
 942:../lib/sd_raw.c ****                 }
 1440              		.loc 1 942 0
 1441 0a3c A33EA0E1 		mov	r3, r3, lsr #29
 1442 0a40 183084E5 		str	r3, [r4, #24]
 1443 0a44 8539A0E1 		mov	r3, r5, asl #19
 1444 0a48 143084E5 		str	r3, [r4, #20]
 1445 0a4c 210000EA 		b	.L158
 1446              	.LVL139:
 1447              	.L159:
 948:../lib/sd_raw.c ****                 {
 1448              		.loc 1 948 0
 1449 0a50 053046E2 		sub	r3, r6, #5
 1450 0a54 050053E3 		cmp	r3, #5
 1451 0a58 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1452 0a5c 1D0000EA 		b	.L158
 1453              	.L169:
 1454 0a60 780A0000 		.word	.L163
 1455 0a64 800A0000 		.word	.L164
 1456 0a68 8C0A0000 		.word	.L165
 1457 0a6c 980A0000 		.word	.L166
 1458 0a70 B00A0000 		.word	.L167
 1459 0a74 BC0A0000 		.word	.L168
 1460              	.L163:
 951:../lib/sd_raw.c ****                         break;
 1461              		.loc 1 951 0
 1462 0a78 0FA000E2 		and	sl, r0, #15
 1463              	.LVL140:
 952:../lib/sd_raw.c ****                     case 6:
 1464              		.loc 1 952 0
 1465 0a7c 150000EA 		b	.L158
 1466              	.LVL141:
 1467              	.L164:
 954:../lib/sd_raw.c ****                         csd_c_size <<= 8;
 1468              		.loc 1 954 0
 1469 0a80 035000E2 		and	r5, r0, #3
 1470              	.LVL142:
 955:../lib/sd_raw.c ****                         break;
 1471              		.loc 1 955 0
 1472 0a84 0554A0E1 		mov	r5, r5, asl #8
 1473              	.LVL143:
 956:../lib/sd_raw.c ****                     case 7:
 1474              		.loc 1 956 0
 1475 0a88 120000EA 		b	.L158
 1476              	.LVL144:
 1477              	.L165:
 958:../lib/sd_raw.c ****                         csd_c_size <<= 2;
 1478              		.loc 1 958 0
 1479 0a8c 055080E1 		orr	r5, r0, r5
 1480              	.LVL145:
 959:../lib/sd_raw.c ****                         break;
 1481              		.loc 1 959 0
 1482 0a90 0559A0E1 		mov	r5, r5, asl #18
 1483              	.LVL146:
 1484 0a94 030000EA 		b	.L193
 1485              	.L166:
 962:../lib/sd_raw.c ****                         ++csd_c_size;
 1486              		.loc 1 962 0
 1487 0a98 0009A0E1 		mov	r0, r0, asl #18
 1488              	.LVL147:
 1489 0a9c 205C85E1 		orr	r5, r5, r0, lsr #24
 1490 0aa0 0558A0E1 		mov	r5, r5, asl #16
 1491              	.LVL148:
 963:../lib/sd_raw.c ****                         break;
 1492              		.loc 1 963 0
 1493 0aa4 015885E2 		add	r5, r5, #65536
 1494              	.LVL149:
 1495              	.L193:
 1496 0aa8 2558A0E1 		mov	r5, r5, lsr #16
 1497              	.LVL150:
 964:../lib/sd_raw.c ****                     case 9:
 1498              		.loc 1 964 0
 1499 0aac 090000EA 		b	.L158
 1500              	.LVL151:
 1501              	.L167:
 966:../lib/sd_raw.c ****                         csd_c_size_mult <<= 1;
 1502              		.loc 1 966 0
 1503 0ab0 030000E2 		and	r0, r0, #3
 1504              	.LVL152:
 967:../lib/sd_raw.c ****                         break;
 1505              		.loc 1 967 0
 1506 0ab4 8070A0E1 		mov	r7, r0, asl #1
 1507              	.LVL153:
 968:../lib/sd_raw.c ****                     case 10:
 1508              		.loc 1 968 0
 1509 0ab8 060000EA 		b	.L158
 1510              	.LVL154:
 1511              	.L168:
 970:../lib/sd_raw.c **** 
 1512              		.loc 1 970 0
 1513 0abc A07387E1 		orr	r7, r7, r0, lsr #7
 1514 0ac0 FF7007E2 		and	r7, r7, #255
 1515              	.LVL155:
 972:../lib/sd_raw.c **** 
 1516              		.loc 1 972 0
 1517 0ac4 0A3087E0 		add	r3, r7, sl
 1518 0ac8 023083E2 		add	r3, r3, #2
 1519 0acc 1533A0E1 		mov	r3, r5, asl r3
 1520 0ad0 18B084E5 		str	fp, [r4, #24]
 1521 0ad4 143084E5 		str	r3, [r4, #20]
 1522              	.LVL156:
 1523              	.L158:
 1524              	.LBE41:
 910:../lib/sd_raw.c ****     {
 1525              		.loc 1 910 0
 1526 0ad8 016086E2 		add	r6, r6, #1
 1527 0adc FF6006E2 		and	r6, r6, #255
 1528              	.LVL157:
 1529 0ae0 120056E3 		cmp	r6, #18
 1530 0ae4 B5FFFF1A 		bne	.L170
 1531              	.LBE42:
 980:../lib/sd_raw.c **** 
 1532              		.loc 1 980 0
 1533 0ae8 18309FE5 		ldr	r3, .L195
 1534 0aec 042093E5 		ldr	r2, [r3, #4]
 1535 0af0 802082E3 		orr	r2, r2, #128
 1536 0af4 042083E5 		str	r2, [r3, #4]
 982:../lib/sd_raw.c **** }
 1537              		.loc 1 982 0
 1538 0af8 0100A0E3 		mov	r0, #1
 1539 0afc FFFFFFEA 		b	.L141
 1540              	.LVL158:
 1541              	.L141:
 1542              		.loc 1 983 0
 1543 0b00 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1544 0b04 1EFF2FE1 		bx	lr
 1545              	.L196:
 1546              		.align	2
 1547              	.L195:
 1548 0b08 008002E0 		.word	-536707072
 1549 0b0c 00000000 		.word	.LANCHOR0
 1550              		.cfi_endproc
 1551              	.LFE11:
 1553              		.bss
 1554              		.align	2
 1555              		.set	.LANCHOR0,. + 0
 1558              	raw_block_written:
 1559 0000 00       		.space	1
 1560 0001 000000   		.space	3
 1563              	raw_block_address:
 1564 0004 00000000 		.space	8
 1564      00000000 
 1567              	raw_block:
 1568 000c 00000000 		.space	512
 1568      00000000 
 1568      00000000 
 1568      00000000 
 1568      00000000 
 1571              	sd_raw_card_type:
 1572 020c 00       		.space	1
 1573 020d 000000   		.text
 1574              	.Letext0:
 1575              		.file 2 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/stdint.h"
 1576              		.file 3 "../lib/sd_raw_config.h"
 1577              		.file 4 "../lib/sd_raw.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 sd_raw.c
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:5      .text:0000000000000000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:7      .text:0000000000000000 sd_raw_send_byte
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:30     .text:0000000000000018 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:34     .text:000000000000001c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:36     .text:000000000000001c sd_raw_rec_byte
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:62     .text:0000000000000044 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:66     .text:0000000000000048 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:68     .text:0000000000000048 sd_raw_send_command
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:163    .text:00000000000000d4 sd_raw_available
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:180    .text:00000000000000dc sd_raw_locked
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:197    .text:00000000000000e4 sd_raw_sync
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:838    .text:00000000000005c0 sd_raw_write
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:238    .text:0000000000000120 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:242    .text:0000000000000124 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:245    .text:0000000000000124 sd_raw_read
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:440    .text:00000000000002a4 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:447    .text:00000000000002b4 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:450    .text:00000000000002b4 sd_raw_read_interval
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:547    .text:0000000000000364 sd_raw_init
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:827    .text:00000000000005ac $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:835    .text:00000000000005c0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1068   .text:0000000000000784 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1075   .text:0000000000000794 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1078   .text:0000000000000794 sd_raw_write_interval
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1194   .text:0000000000000858 sd_raw_get_info
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1265   .text:00000000000008d0 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1282   .text:000000000000090c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1454   .text:0000000000000a60 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1462   .text:0000000000000a78 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1548   .text:0000000000000b08 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1554   .bss:0000000000000000 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1558   .bss:0000000000000000 raw_block_written
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1563   .bss:0000000000000004 raw_block_address
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1567   .bss:000000000000000c raw_block
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccdz9OTn.s:1571   .bss:000000000000020c sd_raw_card_type
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
memcpy
memset
