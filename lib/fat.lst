   1              		.file	"fat.c"
   2              		.text
   3              	.Ltext0:
   4              		.cfi_sections	.debug_frame
   5              		.align	2
   7              	fat_clear_cluster_callback:
   8              	.LFB8:
   9              		.file 1 "../lib/fat.c"
   1:../lib/fat.c  **** 
   2:../lib/fat.c  **** /* 
   3:../lib/fat.c  ****  * Copyright (c) 2006-2011 by Roland Riegel <feedback@roland-riegel.de>
   4:../lib/fat.c  ****  *
   5:../lib/fat.c  ****  * This file is free software; you can redistribute it and/or modify
   6:../lib/fat.c  ****  * it under the terms of either the GNU General Public License version 2
   7:../lib/fat.c  ****  * or the GNU Lesser General Public License version 2.1, both as
   8:../lib/fat.c  ****  * published by the Free Software Foundation.
   9:../lib/fat.c  ****  */
  10:../lib/fat.c  **** 
  11:../lib/fat.c  **** #include "byteordering.h"
  12:../lib/fat.c  **** #include "partition.h"
  13:../lib/fat.c  **** #include "fat.h"
  14:../lib/fat.c  **** #include "fat_config.h"
  15:../lib/fat.c  **** #include "sd-reader_config.h"
  16:../lib/fat.c  **** 
  17:../lib/fat.c  **** 
  18:../lib/fat.c  **** #include <string.h>
  19:../lib/fat.c  **** 
  20:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
  21:../lib/fat.c  ****     #include <stdlib.h>
  22:../lib/fat.c  **** #endif
  23:../lib/fat.c  **** 
  24:../lib/fat.c  **** /**
  25:../lib/fat.c  ****  * \addtogroup fat FAT support
  26:../lib/fat.c  ****  *
  27:../lib/fat.c  ****  * This module implements FAT16/FAT32 read and write access.
  28:../lib/fat.c  ****  * 
  29:../lib/fat.c  ****  * The following features are supported:
  30:../lib/fat.c  ****  * - File names up to 31 characters long.
  31:../lib/fat.c  ****  * - Unlimited depth of subdirectories.
  32:../lib/fat.c  ****  * - Short 8.3 and long filenames.
  33:../lib/fat.c  ****  * - Creating and deleting files.
  34:../lib/fat.c  ****  * - Reading and writing from and to files.
  35:../lib/fat.c  ****  * - File resizing.
  36:../lib/fat.c  ****  * - File sizes of up to 4 gigabytes.
  37:../lib/fat.c  ****  * 
  38:../lib/fat.c  ****  * @{
  39:../lib/fat.c  ****  */
  40:../lib/fat.c  **** /**
  41:../lib/fat.c  ****  * \file
  42:../lib/fat.c  ****  * FAT implementation (license: GPLv2 or LGPLv2.1)
  43:../lib/fat.c  ****  *
  44:../lib/fat.c  ****  * \author Roland Riegel
  45:../lib/fat.c  ****  */
  46:../lib/fat.c  **** 
  47:../lib/fat.c  **** /**
  48:../lib/fat.c  ****  * \addtogroup fat_config FAT configuration
  49:../lib/fat.c  ****  * Preprocessor defines to configure the FAT implementation.
  50:../lib/fat.c  ****  */
  51:../lib/fat.c  **** 
  52:../lib/fat.c  **** /**
  53:../lib/fat.c  ****  * \addtogroup fat_fs FAT access
  54:../lib/fat.c  ****  * Basic functions for handling a FAT filesystem.
  55:../lib/fat.c  ****  */
  56:../lib/fat.c  **** 
  57:../lib/fat.c  **** /**
  58:../lib/fat.c  ****  * \addtogroup fat_file FAT file functions
  59:../lib/fat.c  ****  * Functions for managing files.
  60:../lib/fat.c  ****  */
  61:../lib/fat.c  **** 
  62:../lib/fat.c  **** /**
  63:../lib/fat.c  ****  * \addtogroup fat_dir FAT directory functions
  64:../lib/fat.c  ****  * Functions for managing directories.
  65:../lib/fat.c  ****  */
  66:../lib/fat.c  **** 
  67:../lib/fat.c  **** /**
  68:../lib/fat.c  ****  * @}
  69:../lib/fat.c  ****  */
  70:../lib/fat.c  **** 
  71:../lib/fat.c  **** #define FAT16_CLUSTER_FREE 0x0000
  72:../lib/fat.c  **** #define FAT16_CLUSTER_RESERVED_MIN 0xfff0
  73:../lib/fat.c  **** #define FAT16_CLUSTER_RESERVED_MAX 0xfff6
  74:../lib/fat.c  **** #define FAT16_CLUSTER_BAD 0xfff7
  75:../lib/fat.c  **** #define FAT16_CLUSTER_LAST_MIN 0xfff8
  76:../lib/fat.c  **** #define FAT16_CLUSTER_LAST_MAX 0xffff
  77:../lib/fat.c  **** 
  78:../lib/fat.c  **** #define FAT32_CLUSTER_FREE 0x00000000
  79:../lib/fat.c  **** #define FAT32_CLUSTER_RESERVED_MIN 0x0ffffff0
  80:../lib/fat.c  **** #define FAT32_CLUSTER_RESERVED_MAX 0x0ffffff6
  81:../lib/fat.c  **** #define FAT32_CLUSTER_BAD 0x0ffffff7
  82:../lib/fat.c  **** #define FAT32_CLUSTER_LAST_MIN 0x0ffffff8
  83:../lib/fat.c  **** #define FAT32_CLUSTER_LAST_MAX 0x0fffffff
  84:../lib/fat.c  **** 
  85:../lib/fat.c  **** #define FAT_DIRENTRY_DELETED 0xe5
  86:../lib/fat.c  **** #define FAT_DIRENTRY_LFNLAST (1 << 6)
  87:../lib/fat.c  **** #define FAT_DIRENTRY_LFNSEQMASK ((1 << 6) - 1)
  88:../lib/fat.c  **** 
  89:../lib/fat.c  **** /* Each entry within the directory table has a size of 32 bytes
  90:../lib/fat.c  ****  * and either contains a 8.3 DOS-style file name or a part of a
  91:../lib/fat.c  ****  * long file name, which may consist of several directory table
  92:../lib/fat.c  ****  * entries at once.
  93:../lib/fat.c  ****  *
  94:../lib/fat.c  ****  * multi-byte integer values are stored little-endian!
  95:../lib/fat.c  ****  *
  96:../lib/fat.c  ****  * 8.3 file name entry:
  97:../lib/fat.c  ****  * ====================
  98:../lib/fat.c  ****  * offset  length  description
  99:../lib/fat.c  ****  *      0       8  name (space padded)
 100:../lib/fat.c  ****  *      8       3  extension (space padded)
 101:../lib/fat.c  ****  *     11       1  attributes (FAT_ATTRIB_*)
 102:../lib/fat.c  ****  *
 103:../lib/fat.c  ****  * long file name (lfn) entry ordering for a single file name:
 104:../lib/fat.c  ****  * ===========================================================
 105:../lib/fat.c  ****  * LFN entry n
 106:../lib/fat.c  ****  *     ...
 107:../lib/fat.c  ****  * LFN entry 2
 108:../lib/fat.c  ****  * LFN entry 1
 109:../lib/fat.c  ****  * 8.3 entry (see above)
 110:../lib/fat.c  ****  * 
 111:../lib/fat.c  ****  * lfn entry:
 112:../lib/fat.c  ****  * ==========
 113:../lib/fat.c  ****  * offset  length  description
 114:../lib/fat.c  ****  *      0       1  ordinal field
 115:../lib/fat.c  ****  *      1       2  unicode character 1
 116:../lib/fat.c  ****  *      3       3  unicode character 2
 117:../lib/fat.c  ****  *      5       3  unicode character 3
 118:../lib/fat.c  ****  *      7       3  unicode character 4
 119:../lib/fat.c  ****  *      9       3  unicode character 5
 120:../lib/fat.c  ****  *     11       1  attribute (always 0x0f)
 121:../lib/fat.c  ****  *     12       1  type (reserved, always 0)
 122:../lib/fat.c  ****  *     13       1  checksum
 123:../lib/fat.c  ****  *     14       2  unicode character 6
 124:../lib/fat.c  ****  *     16       2  unicode character 7
 125:../lib/fat.c  ****  *     18       2  unicode character 8
 126:../lib/fat.c  ****  *     20       2  unicode character 9
 127:../lib/fat.c  ****  *     22       2  unicode character 10
 128:../lib/fat.c  ****  *     24       2  unicode character 11
 129:../lib/fat.c  ****  *     26       2  cluster (unused, always 0)
 130:../lib/fat.c  ****  *     28       2  unicode character 12
 131:../lib/fat.c  ****  *     30       2  unicode character 13
 132:../lib/fat.c  ****  * 
 133:../lib/fat.c  ****  * The ordinal field contains a descending number, from n to 1.
 134:../lib/fat.c  ****  * For the n'th lfn entry the ordinal field is or'ed with 0x40.
 135:../lib/fat.c  ****  * For deleted lfn entries, the ordinal field is set to 0xe5.
 136:../lib/fat.c  ****  */
 137:../lib/fat.c  **** 
 138:../lib/fat.c  **** struct fat_header_struct
 139:../lib/fat.c  **** {
 140:../lib/fat.c  ****     offset_t size;
 141:../lib/fat.c  **** 
 142:../lib/fat.c  ****     offset_t fat_offset;
 143:../lib/fat.c  ****     uint32_t fat_size;
 144:../lib/fat.c  **** 
 145:../lib/fat.c  ****     uint16_t sector_size;
 146:../lib/fat.c  ****     uint16_t cluster_size;
 147:../lib/fat.c  **** 
 148:../lib/fat.c  ****     offset_t cluster_zero_offset;
 149:../lib/fat.c  **** 
 150:../lib/fat.c  ****     offset_t root_dir_offset;
 151:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 152:../lib/fat.c  ****     cluster_t root_dir_cluster;
 153:../lib/fat.c  **** #endif
 154:../lib/fat.c  **** };
 155:../lib/fat.c  **** 
 156:../lib/fat.c  **** struct fat_fs_struct
 157:../lib/fat.c  **** {
 158:../lib/fat.c  ****     struct partition_struct* partition;
 159:../lib/fat.c  ****     struct fat_header_struct header;
 160:../lib/fat.c  ****     cluster_t cluster_free;
 161:../lib/fat.c  **** };
 162:../lib/fat.c  **** 
 163:../lib/fat.c  **** struct fat_file_struct
 164:../lib/fat.c  **** {
 165:../lib/fat.c  ****     struct fat_fs_struct* fs;
 166:../lib/fat.c  ****     struct fat_dir_entry_struct dir_entry;
 167:../lib/fat.c  ****     offset_t pos;
 168:../lib/fat.c  ****     cluster_t pos_cluster;
 169:../lib/fat.c  **** };
 170:../lib/fat.c  **** 
 171:../lib/fat.c  **** struct fat_dir_struct
 172:../lib/fat.c  **** {
 173:../lib/fat.c  ****     struct fat_fs_struct* fs;
 174:../lib/fat.c  ****     struct fat_dir_entry_struct dir_entry;
 175:../lib/fat.c  ****     cluster_t entry_cluster;
 176:../lib/fat.c  ****     uint16_t entry_offset;
 177:../lib/fat.c  **** };
 178:../lib/fat.c  **** 
 179:../lib/fat.c  **** struct fat_read_dir_callback_arg
 180:../lib/fat.c  **** {
 181:../lib/fat.c  ****     struct fat_dir_entry_struct* dir_entry;
 182:../lib/fat.c  ****     uintptr_t bytes_read;
 183:../lib/fat.c  **** #if FAT_LFN_SUPPORT
 184:../lib/fat.c  ****     uint8_t checksum;
 185:../lib/fat.c  **** #endif
 186:../lib/fat.c  ****     uint8_t finished;
 187:../lib/fat.c  **** };
 188:../lib/fat.c  **** 
 189:../lib/fat.c  **** struct fat_usage_count_callback_arg
 190:../lib/fat.c  **** {
 191:../lib/fat.c  ****     cluster_t cluster_count;
 192:../lib/fat.c  ****     uintptr_t buffer_size;
 193:../lib/fat.c  **** };
 194:../lib/fat.c  **** 
 195:../lib/fat.c  **** #if !USE_DYNAMIC_MEMORY
 196:../lib/fat.c  **** static struct fat_fs_struct fat_fs_handles[FAT_FS_COUNT];
 197:../lib/fat.c  **** static struct fat_file_struct fat_file_handles[FAT_FILE_COUNT];
 198:../lib/fat.c  **** static struct fat_dir_struct fat_dir_handles[FAT_DIR_COUNT];
 199:../lib/fat.c  **** #endif
 200:../lib/fat.c  **** 
 201:../lib/fat.c  **** static uint8_t fat_read_header(struct fat_fs_struct* fs);
 202:../lib/fat.c  **** static cluster_t fat_get_next_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num);
 203:../lib/fat.c  **** static offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num);
 204:../lib/fat.c  **** static uint8_t fat_dir_entry_read_callback(uint8_t* buffer, offset_t offset, void* p);
 205:../lib/fat.c  **** #if FAT_LFN_SUPPORT
 206:../lib/fat.c  **** static uint8_t fat_calc_83_checksum(const uint8_t* file_name_83);
 207:../lib/fat.c  **** #endif
 208:../lib/fat.c  **** 
 209:../lib/fat.c  **** static uint8_t fat_get_fs_free_16_callback(uint8_t* buffer, offset_t offset, void* p);
 210:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 211:../lib/fat.c  **** static uint8_t fat_get_fs_free_32_callback(uint8_t* buffer, offset_t offset, void* p);
 212:../lib/fat.c  **** #endif
 213:../lib/fat.c  **** 
 214:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
 215:../lib/fat.c  **** static cluster_t fat_append_clusters(struct fat_fs_struct* fs, cluster_t cluster_num, cluster_t cou
 216:../lib/fat.c  **** static uint8_t fat_free_clusters(struct fat_fs_struct* fs, cluster_t cluster_num);
 217:../lib/fat.c  **** static uint8_t fat_terminate_clusters(struct fat_fs_struct* fs, cluster_t cluster_num);
 218:../lib/fat.c  **** static uint8_t fat_clear_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num);
 219:../lib/fat.c  **** static uintptr_t fat_clear_cluster_callback(uint8_t* buffer, offset_t offset, void* p);
 220:../lib/fat.c  **** static offset_t fat_find_offset_for_dir_entry(struct fat_fs_struct* fs, const struct fat_dir_struct
 221:../lib/fat.c  **** static uint8_t fat_write_dir_entry(const struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir
 222:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
 223:../lib/fat.c  **** static void fat_set_file_modification_date(struct fat_dir_entry_struct* dir_entry, uint16_t year, u
 224:../lib/fat.c  **** static void fat_set_file_modification_time(struct fat_dir_entry_struct* dir_entry, uint8_t hour, ui
 225:../lib/fat.c  **** #endif
 226:../lib/fat.c  **** #endif
 227:../lib/fat.c  **** 
 228:../lib/fat.c  **** /**
 229:../lib/fat.c  ****  * \ingroup fat_fs
 230:../lib/fat.c  ****  * Opens a FAT filesystem.
 231:../lib/fat.c  ****  *
 232:../lib/fat.c  ****  * \param[in] partition Discriptor of partition on which the filesystem resides.
 233:../lib/fat.c  ****  * \returns 0 on error, a FAT filesystem descriptor on success.
 234:../lib/fat.c  ****  * \see fat_close
 235:../lib/fat.c  ****  */
 236:../lib/fat.c  **** struct fat_fs_struct* fat_open(struct partition_struct* partition)
 237:../lib/fat.c  **** {
 238:../lib/fat.c  ****     if(!partition ||
 239:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
 240:../lib/fat.c  ****        !partition->device_write ||
 241:../lib/fat.c  ****        !partition->device_write_interval
 242:../lib/fat.c  **** #else
 243:../lib/fat.c  ****        0
 244:../lib/fat.c  **** #endif
 245:../lib/fat.c  ****       )
 246:../lib/fat.c  ****         return 0;
 247:../lib/fat.c  **** 
 248:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
 249:../lib/fat.c  ****     struct fat_fs_struct* fs = malloc(sizeof(*fs));
 250:../lib/fat.c  ****     if(!fs)
 251:../lib/fat.c  ****         return 0;
 252:../lib/fat.c  **** #else
 253:../lib/fat.c  ****     struct fat_fs_struct* fs = fat_fs_handles;
 254:../lib/fat.c  ****     uint8_t i;
 255:../lib/fat.c  ****     for(i = 0; i < FAT_FS_COUNT; ++i)
 256:../lib/fat.c  ****     {
 257:../lib/fat.c  ****         if(!fs->partition)
 258:../lib/fat.c  ****             break;
 259:../lib/fat.c  **** 
 260:../lib/fat.c  ****         ++fs;
 261:../lib/fat.c  ****     }
 262:../lib/fat.c  ****     if(i >= FAT_FS_COUNT)
 263:../lib/fat.c  ****         return 0;
 264:../lib/fat.c  **** #endif
 265:../lib/fat.c  ****     memset(fs, 0, sizeof(*fs));
 266:../lib/fat.c  **** 
 267:../lib/fat.c  ****     fs->partition = partition;
 268:../lib/fat.c  **** 
 269:../lib/fat.c  ****     if(!fat_read_header(fs))
 270:../lib/fat.c  ****     {
 271:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
 272:../lib/fat.c  ****         free(fs);
 273:../lib/fat.c  **** #else
 274:../lib/fat.c  ****         fs->partition = 0;
 275:../lib/fat.c  **** #endif
 276:../lib/fat.c  ****         return 0;
 277:../lib/fat.c  ****     }
 278:../lib/fat.c  ****     
 279:../lib/fat.c  ****     return fs;
 280:../lib/fat.c  **** }
 281:../lib/fat.c  **** 
 282:../lib/fat.c  **** /**
 283:../lib/fat.c  ****  * \ingroup fat_fs
 284:../lib/fat.c  ****  * Closes a FAT filesystem.
 285:../lib/fat.c  ****  *
 286:../lib/fat.c  ****  * When this function returns, the given filesystem descriptor
 287:../lib/fat.c  ****  * will be invalid.
 288:../lib/fat.c  ****  *
 289:../lib/fat.c  ****  * \param[in] fs The filesystem to close.
 290:../lib/fat.c  ****  * \see fat_open
 291:../lib/fat.c  ****  */
 292:../lib/fat.c  **** void fat_close(struct fat_fs_struct* fs)
 293:../lib/fat.c  **** {
 294:../lib/fat.c  ****     if(!fs)
 295:../lib/fat.c  ****         return;
 296:../lib/fat.c  **** 
 297:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
 298:../lib/fat.c  ****     free(fs);
 299:../lib/fat.c  **** #else
 300:../lib/fat.c  ****     fs->partition = 0;
 301:../lib/fat.c  **** #endif
 302:../lib/fat.c  **** }
 303:../lib/fat.c  **** 
 304:../lib/fat.c  **** /**
 305:../lib/fat.c  ****  * \ingroup fat_fs
 306:../lib/fat.c  ****  * Reads and parses the header of a FAT filesystem.
 307:../lib/fat.c  ****  *
 308:../lib/fat.c  ****  * \param[in,out] fs The filesystem for which to parse the header.
 309:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
 310:../lib/fat.c  ****  */
 311:../lib/fat.c  **** uint8_t fat_read_header(struct fat_fs_struct* fs)
 312:../lib/fat.c  **** {
 313:../lib/fat.c  ****     if(!fs)
 314:../lib/fat.c  ****         return 0;
 315:../lib/fat.c  **** 
 316:../lib/fat.c  ****     struct partition_struct* partition = fs->partition;
 317:../lib/fat.c  ****     if(!partition)
 318:../lib/fat.c  ****         return 0;
 319:../lib/fat.c  **** 
 320:../lib/fat.c  ****     /* read fat parameters */
 321:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 322:../lib/fat.c  ****     uint8_t buffer[37];
 323:../lib/fat.c  **** #else
 324:../lib/fat.c  ****     uint8_t buffer[25];
 325:../lib/fat.c  **** #endif
 326:../lib/fat.c  ****     offset_t partition_offset = (offset_t) partition->offset * 512;
 327:../lib/fat.c  **** 
 328:../lib/fat.c  ****     if(!partition->device_read(partition_offset + 0x0b, buffer, sizeof(buffer)))
 329:../lib/fat.c  ****         return 0;
 330:../lib/fat.c  **** 
 331:../lib/fat.c  ****     uint16_t bytes_per_sector = read16(&buffer[0x00]);
 332:../lib/fat.c  ****     uint16_t reserved_sectors = read16(&buffer[0x03]);
 333:../lib/fat.c  ****     uint8_t sectors_per_cluster = buffer[0x02];
 334:../lib/fat.c  ****     uint8_t fat_copies = buffer[0x05];
 335:../lib/fat.c  ****     uint16_t max_root_entries = read16(&buffer[0x06]);
 336:../lib/fat.c  ****     uint16_t sector_count_16 = read16(&buffer[0x08]);
 337:../lib/fat.c  ****     uint16_t sectors_per_fat = read16(&buffer[0x0b]);
 338:../lib/fat.c  ****     uint32_t sector_count = read32(&buffer[0x15]);
 339:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 340:../lib/fat.c  ****     uint32_t sectors_per_fat32 = read32(&buffer[0x19]);
 341:../lib/fat.c  ****     uint32_t cluster_root_dir = read32(&buffer[0x21]);
 342:../lib/fat.c  **** #endif
 343:../lib/fat.c  **** 
 344:../lib/fat.c  ****     if(sector_count == 0)
 345:../lib/fat.c  ****     {
 346:../lib/fat.c  ****         if(sector_count_16 == 0)
 347:../lib/fat.c  ****             /* illegal volume size */
 348:../lib/fat.c  ****             return 0;
 349:../lib/fat.c  ****         else
 350:../lib/fat.c  ****             sector_count = sector_count_16;
 351:../lib/fat.c  ****     }
 352:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 353:../lib/fat.c  ****     if(sectors_per_fat != 0)
 354:../lib/fat.c  ****         sectors_per_fat32 = sectors_per_fat;
 355:../lib/fat.c  ****     else if(sectors_per_fat32 == 0)
 356:../lib/fat.c  ****         /* this is neither FAT16 nor FAT32 */
 357:../lib/fat.c  ****         return 0;
 358:../lib/fat.c  **** #else
 359:../lib/fat.c  ****     if(sectors_per_fat == 0)
 360:../lib/fat.c  ****         /* this is not a FAT16 */
 361:../lib/fat.c  ****         return 0;
 362:../lib/fat.c  **** #endif
 363:../lib/fat.c  **** 
 364:../lib/fat.c  ****     /* determine the type of FAT we have here */
 365:../lib/fat.c  ****     uint32_t data_sector_count = sector_count
 366:../lib/fat.c  ****                                  - reserved_sectors
 367:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 368:../lib/fat.c  ****                                  - sectors_per_fat32 * fat_copies
 369:../lib/fat.c  **** #else
 370:../lib/fat.c  ****                                  - (uint32_t) sectors_per_fat * fat_copies
 371:../lib/fat.c  **** #endif
 372:../lib/fat.c  ****                                  - ((max_root_entries * 32 + bytes_per_sector - 1) / bytes_per_sect
 373:../lib/fat.c  ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 374:../lib/fat.c  ****     if(data_cluster_count < 4085)
 375:../lib/fat.c  ****         /* this is a FAT12, not supported */
 376:../lib/fat.c  ****         return 0;
 377:../lib/fat.c  ****     else if(data_cluster_count < 65525)
 378:../lib/fat.c  ****         /* this is a FAT16 */
 379:../lib/fat.c  ****         partition->type = PARTITION_TYPE_FAT16;
 380:../lib/fat.c  ****     else
 381:../lib/fat.c  ****         /* this is a FAT32 */
 382:../lib/fat.c  ****         partition->type = PARTITION_TYPE_FAT32;
 383:../lib/fat.c  **** 
 384:../lib/fat.c  ****     /* fill header information */
 385:../lib/fat.c  ****     struct fat_header_struct* header = &fs->header;
 386:../lib/fat.c  ****     memset(header, 0, sizeof(*header));
 387:../lib/fat.c  ****     
 388:../lib/fat.c  ****     header->size = (offset_t) sector_count * bytes_per_sector;
 389:../lib/fat.c  **** 
 390:../lib/fat.c  ****     header->fat_offset = /* jump to partition */
 391:../lib/fat.c  ****                          partition_offset +
 392:../lib/fat.c  ****                          /* jump to fat */
 393:../lib/fat.c  ****                          (offset_t) reserved_sectors * bytes_per_sector;
 394:../lib/fat.c  ****     header->fat_size = (data_cluster_count + 2) * (partition->type == PARTITION_TYPE_FAT16 ? 2 : 4)
 395:../lib/fat.c  **** 
 396:../lib/fat.c  ****     header->sector_size = bytes_per_sector;
 397:../lib/fat.c  ****     header->cluster_size = (uint16_t) bytes_per_sector * sectors_per_cluster;
 398:../lib/fat.c  **** 
 399:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 400:../lib/fat.c  ****     if(partition->type == PARTITION_TYPE_FAT16)
 401:../lib/fat.c  **** #endif
 402:../lib/fat.c  ****     {
 403:../lib/fat.c  ****         header->root_dir_offset = /* jump to fats */
 404:../lib/fat.c  ****                                   header->fat_offset +
 405:../lib/fat.c  ****                                   /* jump to root directory entries */
 406:../lib/fat.c  ****                                   (offset_t) fat_copies * sectors_per_fat * bytes_per_sector;
 407:../lib/fat.c  **** 
 408:../lib/fat.c  ****         header->cluster_zero_offset = /* jump to root directory entries */
 409:../lib/fat.c  ****                                       header->root_dir_offset +
 410:../lib/fat.c  ****                                       /* skip root directory entries */
 411:../lib/fat.c  ****                                       (offset_t) max_root_entries * 32;
 412:../lib/fat.c  ****     }
 413:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 414:../lib/fat.c  ****     else
 415:../lib/fat.c  ****     {
 416:../lib/fat.c  ****         header->cluster_zero_offset = /* jump to fats */
 417:../lib/fat.c  ****                                       header->fat_offset +
 418:../lib/fat.c  ****                                       /* skip fats */
 419:../lib/fat.c  ****                                       (offset_t) fat_copies * sectors_per_fat32 * bytes_per_sector;
 420:../lib/fat.c  **** 
 421:../lib/fat.c  ****         header->root_dir_cluster = cluster_root_dir;
 422:../lib/fat.c  ****     }
 423:../lib/fat.c  **** #endif
 424:../lib/fat.c  **** 
 425:../lib/fat.c  ****     return 1;
 426:../lib/fat.c  **** }
 427:../lib/fat.c  **** 
 428:../lib/fat.c  **** /**
 429:../lib/fat.c  ****  * \ingroup fat_fs
 430:../lib/fat.c  ****  * Retrieves the next following cluster of a given cluster.
 431:../lib/fat.c  ****  *
 432:../lib/fat.c  ****  * Using the filesystem file allocation table, this function returns
 433:../lib/fat.c  ****  * the number of the cluster containing the data directly following
 434:../lib/fat.c  ****  * the data within the cluster with the given number.
 435:../lib/fat.c  ****  *
 436:../lib/fat.c  ****  * \param[in] fs The filesystem for which to determine the next cluster.
 437:../lib/fat.c  ****  * \param[in] cluster_num The number of the cluster for which to determine its successor.
 438:../lib/fat.c  ****  * \returns The wanted cluster number, or 0 on error.
 439:../lib/fat.c  ****  */
 440:../lib/fat.c  **** cluster_t fat_get_next_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num)
 441:../lib/fat.c  **** {
 442:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 443:../lib/fat.c  ****         return 0;
 444:../lib/fat.c  **** 
 445:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 446:../lib/fat.c  ****     if(fs->partition->type == PARTITION_TYPE_FAT32)
 447:../lib/fat.c  ****     {
 448:../lib/fat.c  ****         /* read appropriate fat entry */
 449:../lib/fat.c  ****         uint32_t fat_entry;
 450:../lib/fat.c  ****         if(!fs->partition->device_read(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat_
 451:../lib/fat.c  ****             return 0;
 452:../lib/fat.c  **** 
 453:../lib/fat.c  ****         /* determine next cluster from fat */
 454:../lib/fat.c  ****         cluster_num = ltoh32(fat_entry);
 455:../lib/fat.c  ****         
 456:../lib/fat.c  ****         if(cluster_num == FAT32_CLUSTER_FREE ||
 457:../lib/fat.c  ****            cluster_num == FAT32_CLUSTER_BAD ||
 458:../lib/fat.c  ****            (cluster_num >= FAT32_CLUSTER_RESERVED_MIN && cluster_num <= FAT32_CLUSTER_RESERVED_MAX)
 459:../lib/fat.c  ****            (cluster_num >= FAT32_CLUSTER_LAST_MIN && cluster_num <= FAT32_CLUSTER_LAST_MAX))
 460:../lib/fat.c  ****             return 0;
 461:../lib/fat.c  ****     }
 462:../lib/fat.c  ****     else
 463:../lib/fat.c  **** #endif
 464:../lib/fat.c  ****     {
 465:../lib/fat.c  ****         /* read appropriate fat entry */
 466:../lib/fat.c  ****         uint16_t fat_entry;
 467:../lib/fat.c  ****         if(!fs->partition->device_read(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat_
 468:../lib/fat.c  ****             return 0;
 469:../lib/fat.c  **** 
 470:../lib/fat.c  ****         /* determine next cluster from fat */
 471:../lib/fat.c  ****         cluster_num = ltoh16(fat_entry);
 472:../lib/fat.c  ****         
 473:../lib/fat.c  ****         if(cluster_num == FAT16_CLUSTER_FREE ||
 474:../lib/fat.c  ****            cluster_num == FAT16_CLUSTER_BAD ||
 475:../lib/fat.c  ****            (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX)
 476:../lib/fat.c  ****            (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 477:../lib/fat.c  ****             return 0;
 478:../lib/fat.c  ****     }
 479:../lib/fat.c  **** 
 480:../lib/fat.c  ****     return cluster_num;
 481:../lib/fat.c  **** }
 482:../lib/fat.c  **** 
 483:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
 484:../lib/fat.c  **** /**
 485:../lib/fat.c  ****  * \ingroup fat_fs
 486:../lib/fat.c  ****  * Appends a new cluster chain to an existing one.
 487:../lib/fat.c  ****  *
 488:../lib/fat.c  ****  * Set cluster_num to zero to create a completely new one.
 489:../lib/fat.c  ****  *
 490:../lib/fat.c  ****  * \param[in] fs The file system on which to operate.
 491:../lib/fat.c  ****  * \param[in] cluster_num The cluster to which to append the new chain.
 492:../lib/fat.c  ****  * \param[in] count The number of clusters to allocate.
 493:../lib/fat.c  ****  * \returns 0 on failure, the number of the first new cluster on success.
 494:../lib/fat.c  ****  */
 495:../lib/fat.c  **** cluster_t fat_append_clusters(struct fat_fs_struct* fs, cluster_t cluster_num, cluster_t count)
 496:../lib/fat.c  **** {
 497:../lib/fat.c  ****     if(!fs)
 498:../lib/fat.c  ****         return 0;
 499:../lib/fat.c  **** 
 500:../lib/fat.c  ****     device_read_t device_read = fs->partition->device_read;
 501:../lib/fat.c  ****     device_write_t device_write = fs->partition->device_write;
 502:../lib/fat.c  ****     offset_t fat_offset = fs->header.fat_offset;
 503:../lib/fat.c  ****     cluster_t count_left = count;
 504:../lib/fat.c  ****     cluster_t cluster_current = fs->cluster_free;
 505:../lib/fat.c  ****     cluster_t cluster_next = 0;
 506:../lib/fat.c  ****     cluster_t cluster_count;
 507:../lib/fat.c  ****     uint16_t fat_entry16;
 508:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 509:../lib/fat.c  ****     uint32_t fat_entry32;
 510:../lib/fat.c  ****     uint8_t is_fat32 = (fs->partition->type == PARTITION_TYPE_FAT32);
 511:../lib/fat.c  **** 
 512:../lib/fat.c  ****     if(is_fat32)
 513:../lib/fat.c  ****         cluster_count = fs->header.fat_size / sizeof(fat_entry32);
 514:../lib/fat.c  ****     else
 515:../lib/fat.c  **** #endif
 516:../lib/fat.c  ****         cluster_count = fs->header.fat_size / sizeof(fat_entry16);
 517:../lib/fat.c  **** 
 518:../lib/fat.c  ****     fs->cluster_free = 0;
 519:../lib/fat.c  ****     for(cluster_t cluster_left = cluster_count; cluster_left > 0; --cluster_left, ++cluster_current
 520:../lib/fat.c  ****     {
 521:../lib/fat.c  ****         if(cluster_current < 2 || cluster_current >= cluster_count)
 522:../lib/fat.c  ****             cluster_current = 2;
 523:../lib/fat.c  **** 
 524:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 525:../lib/fat.c  ****         if(is_fat32)
 526:../lib/fat.c  ****         {
 527:../lib/fat.c  ****             if(!device_read(fat_offset + (offset_t) cluster_current * sizeof(fat_entry32), (uint8_t
 528:../lib/fat.c  ****                 return 0;
 529:../lib/fat.c  ****         }
 530:../lib/fat.c  ****         else
 531:../lib/fat.c  **** #endif
 532:../lib/fat.c  ****         {
 533:../lib/fat.c  ****             if(!device_read(fat_offset + (offset_t) cluster_current * sizeof(fat_entry16), (uint8_t
 534:../lib/fat.c  ****                 return 0;
 535:../lib/fat.c  ****         }
 536:../lib/fat.c  **** 
 537:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 538:../lib/fat.c  ****         if(is_fat32)
 539:../lib/fat.c  ****         {
 540:../lib/fat.c  ****             /* check if this is a free cluster */
 541:../lib/fat.c  ****             if(fat_entry32 != HTOL32(FAT32_CLUSTER_FREE))
 542:../lib/fat.c  ****                 continue;
 543:../lib/fat.c  **** 
 544:../lib/fat.c  ****             /* If we don't need this free cluster for the
 545:../lib/fat.c  ****              * current allocation, we keep it in mind for
 546:../lib/fat.c  ****              * the next time.
 547:../lib/fat.c  ****              */
 548:../lib/fat.c  ****             if(count_left == 0)
 549:../lib/fat.c  ****             {
 550:../lib/fat.c  ****                 fs->cluster_free = cluster_current;
 551:../lib/fat.c  ****                 break;
 552:../lib/fat.c  ****             }
 553:../lib/fat.c  **** 
 554:../lib/fat.c  ****             /* allocate cluster */
 555:../lib/fat.c  ****             if(cluster_next == 0)
 556:../lib/fat.c  ****                 fat_entry32 = HTOL32(FAT32_CLUSTER_LAST_MAX);
 557:../lib/fat.c  ****             else
 558:../lib/fat.c  ****                 fat_entry32 = htol32(cluster_next);
 559:../lib/fat.c  **** 
 560:../lib/fat.c  ****             if(!device_write(fat_offset + (offset_t) cluster_current * sizeof(fat_entry32), (uint8_
 561:../lib/fat.c  ****                 break;
 562:../lib/fat.c  ****         }
 563:../lib/fat.c  ****         else
 564:../lib/fat.c  **** #endif
 565:../lib/fat.c  ****         {
 566:../lib/fat.c  ****             /* check if this is a free cluster */
 567:../lib/fat.c  ****             if(fat_entry16 != HTOL16(FAT16_CLUSTER_FREE))
 568:../lib/fat.c  ****                 continue;
 569:../lib/fat.c  **** 
 570:../lib/fat.c  ****             /* If we don't need this free cluster for the
 571:../lib/fat.c  ****              * current allocation, we keep it in mind for
 572:../lib/fat.c  ****              * the next time.
 573:../lib/fat.c  ****              */
 574:../lib/fat.c  ****             if(count_left == 0)
 575:../lib/fat.c  ****             {
 576:../lib/fat.c  ****                 fs->cluster_free = cluster_current;
 577:../lib/fat.c  ****                 break;
 578:../lib/fat.c  ****             }
 579:../lib/fat.c  **** 
 580:../lib/fat.c  ****             /* allocate cluster */
 581:../lib/fat.c  ****             if(cluster_next == 0)
 582:../lib/fat.c  ****                 fat_entry16 = HTOL16(FAT16_CLUSTER_LAST_MAX);
 583:../lib/fat.c  ****             else
 584:../lib/fat.c  ****                 fat_entry16 = htol16((uint16_t) cluster_next);
 585:../lib/fat.c  **** 
 586:../lib/fat.c  ****             if(!device_write(fat_offset + (offset_t) cluster_current * sizeof(fat_entry16), (uint8_
 587:../lib/fat.c  ****                 break;
 588:../lib/fat.c  ****         }
 589:../lib/fat.c  **** 
 590:../lib/fat.c  ****         cluster_next = cluster_current;
 591:../lib/fat.c  ****         --count_left;
 592:../lib/fat.c  ****     }
 593:../lib/fat.c  **** 
 594:../lib/fat.c  ****     do
 595:../lib/fat.c  ****     {
 596:../lib/fat.c  ****         if(count_left > 0)
 597:../lib/fat.c  ****             break;
 598:../lib/fat.c  **** 
 599:../lib/fat.c  ****         /* We allocated a new cluster chain. Now join
 600:../lib/fat.c  ****          * it with the existing one (if any).
 601:../lib/fat.c  ****          */
 602:../lib/fat.c  ****         if(cluster_num >= 2)
 603:../lib/fat.c  ****         {
 604:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 605:../lib/fat.c  ****             if(is_fat32)
 606:../lib/fat.c  ****             {
 607:../lib/fat.c  ****                 fat_entry32 = htol32(cluster_next);
 608:../lib/fat.c  **** 
 609:../lib/fat.c  ****                 if(!device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry32), (uint8_
 610:../lib/fat.c  ****                     break;
 611:../lib/fat.c  ****             }
 612:../lib/fat.c  ****             else
 613:../lib/fat.c  **** #endif
 614:../lib/fat.c  ****             {
 615:../lib/fat.c  ****                 fat_entry16 = htol16((uint16_t) cluster_next);
 616:../lib/fat.c  **** 
 617:../lib/fat.c  ****                 if(!device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry16), (uint8_
 618:../lib/fat.c  ****                     break;
 619:../lib/fat.c  ****             }
 620:../lib/fat.c  ****         }
 621:../lib/fat.c  **** 
 622:../lib/fat.c  ****         return cluster_next;
 623:../lib/fat.c  **** 
 624:../lib/fat.c  ****     } while(0);
 625:../lib/fat.c  **** 
 626:../lib/fat.c  ****     /* No space left on device or writing error.
 627:../lib/fat.c  ****      * Free up all clusters already allocated.
 628:../lib/fat.c  ****      */
 629:../lib/fat.c  ****     fat_free_clusters(fs, cluster_next);
 630:../lib/fat.c  **** 
 631:../lib/fat.c  ****     return 0;
 632:../lib/fat.c  **** }
 633:../lib/fat.c  **** #endif
 634:../lib/fat.c  **** 
 635:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
 636:../lib/fat.c  **** /**
 637:../lib/fat.c  ****  * \ingroup fat_fs
 638:../lib/fat.c  ****  * Frees a cluster chain, or a part thereof.
 639:../lib/fat.c  ****  *
 640:../lib/fat.c  ****  * Marks the specified cluster and all clusters which are sequentially
 641:../lib/fat.c  ****  * referenced by it as free. They may then be used again for future
 642:../lib/fat.c  ****  * file allocations.
 643:../lib/fat.c  ****  *
 644:../lib/fat.c  ****  * \note If this function is used for freeing just a part of a cluster
 645:../lib/fat.c  ****  *       chain, the new end of the chain is not correctly terminated
 646:../lib/fat.c  ****  *       within the FAT. Use fat_terminate_clusters() instead.
 647:../lib/fat.c  ****  *
 648:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
 649:../lib/fat.c  ****  * \param[in] cluster_num The starting cluster of the chain which to free.
 650:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
 651:../lib/fat.c  ****  * \see fat_terminate_clusters
 652:../lib/fat.c  ****  */
 653:../lib/fat.c  **** uint8_t fat_free_clusters(struct fat_fs_struct* fs, cluster_t cluster_num)
 654:../lib/fat.c  **** {
 655:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 656:../lib/fat.c  ****         return 0;
 657:../lib/fat.c  **** 
 658:../lib/fat.c  ****     offset_t fat_offset = fs->header.fat_offset;
 659:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 660:../lib/fat.c  ****     if(fs->partition->type == PARTITION_TYPE_FAT32)
 661:../lib/fat.c  ****     {
 662:../lib/fat.c  ****         uint32_t fat_entry;
 663:../lib/fat.c  ****         while(cluster_num)
 664:../lib/fat.c  ****         {
 665:../lib/fat.c  ****             if(!fs->partition->device_read(fat_offset + (offset_t) cluster_num * sizeof(fat_entry),
 666:../lib/fat.c  ****                 return 0;
 667:../lib/fat.c  **** 
 668:../lib/fat.c  ****             /* get next cluster of current cluster before freeing current cluster */
 669:../lib/fat.c  ****             uint32_t cluster_num_next = ltoh32(fat_entry);
 670:../lib/fat.c  **** 
 671:../lib/fat.c  ****             if(cluster_num_next == FAT32_CLUSTER_FREE)
 672:../lib/fat.c  ****                 return 1;
 673:../lib/fat.c  ****             if(cluster_num_next == FAT32_CLUSTER_BAD ||
 674:../lib/fat.c  ****                (cluster_num_next >= FAT32_CLUSTER_RESERVED_MIN &&
 675:../lib/fat.c  ****                 cluster_num_next <= FAT32_CLUSTER_RESERVED_MAX
 676:../lib/fat.c  ****                )
 677:../lib/fat.c  ****               )
 678:../lib/fat.c  ****                 return 0;
 679:../lib/fat.c  ****             if(cluster_num_next >= FAT32_CLUSTER_LAST_MIN && cluster_num_next <= FAT32_CLUSTER_LAST
 680:../lib/fat.c  ****                 cluster_num_next = 0;
 681:../lib/fat.c  **** 
 682:../lib/fat.c  ****             /* We know we will free the cluster, so remember it as
 683:../lib/fat.c  ****              * free for the next allocation.
 684:../lib/fat.c  ****              */
 685:../lib/fat.c  ****             if(!fs->cluster_free)
 686:../lib/fat.c  ****                 fs->cluster_free = cluster_num;
 687:../lib/fat.c  **** 
 688:../lib/fat.c  ****             /* free cluster */
 689:../lib/fat.c  ****             fat_entry = HTOL32(FAT32_CLUSTER_FREE);
 690:../lib/fat.c  ****             fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (u
 691:../lib/fat.c  **** 
 692:../lib/fat.c  ****             /* We continue in any case here, even if freeing the cluster failed.
 693:../lib/fat.c  ****              * The cluster is lost, but maybe we can still free up some later ones.
 694:../lib/fat.c  ****              */
 695:../lib/fat.c  **** 
 696:../lib/fat.c  ****             cluster_num = cluster_num_next;
 697:../lib/fat.c  ****         }
 698:../lib/fat.c  ****     }
 699:../lib/fat.c  ****     else
 700:../lib/fat.c  **** #endif
 701:../lib/fat.c  ****     {
 702:../lib/fat.c  ****         uint16_t fat_entry;
 703:../lib/fat.c  ****         while(cluster_num)
 704:../lib/fat.c  ****         {
 705:../lib/fat.c  ****             if(!fs->partition->device_read(fat_offset + (offset_t) cluster_num * sizeof(fat_entry),
 706:../lib/fat.c  ****                 return 0;
 707:../lib/fat.c  **** 
 708:../lib/fat.c  ****             /* get next cluster of current cluster before freeing current cluster */
 709:../lib/fat.c  ****             uint16_t cluster_num_next = ltoh16(fat_entry);
 710:../lib/fat.c  **** 
 711:../lib/fat.c  ****             if(cluster_num_next == FAT16_CLUSTER_FREE)
 712:../lib/fat.c  ****                 return 1;
 713:../lib/fat.c  ****             if(cluster_num_next == FAT16_CLUSTER_BAD ||
 714:../lib/fat.c  ****                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 715:../lib/fat.c  ****                 cluster_num_next <= FAT16_CLUSTER_RESERVED_MAX
 716:../lib/fat.c  ****                )
 717:../lib/fat.c  ****               )
 718:../lib/fat.c  ****                 return 0;
 719:../lib/fat.c  ****             if(cluster_num_next >= FAT16_CLUSTER_LAST_MIN && cluster_num_next <= FAT16_CLUSTER_LAST
 720:../lib/fat.c  ****                 cluster_num_next = 0;
 721:../lib/fat.c  **** 
 722:../lib/fat.c  ****             /* free cluster */
 723:../lib/fat.c  ****             fat_entry = HTOL16(FAT16_CLUSTER_FREE);
 724:../lib/fat.c  ****             fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (u
 725:../lib/fat.c  **** 
 726:../lib/fat.c  ****             /* We continue in any case here, even if freeing the cluster failed.
 727:../lib/fat.c  ****              * The cluster is lost, but maybe we can still free up some later ones.
 728:../lib/fat.c  ****              */
 729:../lib/fat.c  **** 
 730:../lib/fat.c  ****             cluster_num = cluster_num_next;
 731:../lib/fat.c  ****         }
 732:../lib/fat.c  ****     }
 733:../lib/fat.c  **** 
 734:../lib/fat.c  ****     return 1;
 735:../lib/fat.c  **** }
 736:../lib/fat.c  **** #endif
 737:../lib/fat.c  **** 
 738:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
 739:../lib/fat.c  **** /**
 740:../lib/fat.c  ****  * \ingroup fat_fs
 741:../lib/fat.c  ****  * Frees a part of a cluster chain and correctly terminates the rest.
 742:../lib/fat.c  ****  *
 743:../lib/fat.c  ****  * Marks the specified cluster as the new end of a cluster chain and
 744:../lib/fat.c  ****  * frees all following clusters.
 745:../lib/fat.c  ****  *
 746:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
 747:../lib/fat.c  ****  * \param[in] cluster_num The new end of the cluster chain.
 748:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
 749:../lib/fat.c  ****  * \see fat_free_clusters
 750:../lib/fat.c  ****  */
 751:../lib/fat.c  **** uint8_t fat_terminate_clusters(struct fat_fs_struct* fs, cluster_t cluster_num)
 752:../lib/fat.c  **** {
 753:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 754:../lib/fat.c  ****         return 0;
 755:../lib/fat.c  **** 
 756:../lib/fat.c  ****     /* fetch next cluster before overwriting the cluster entry */
 757:../lib/fat.c  ****     cluster_t cluster_num_next = fat_get_next_cluster(fs, cluster_num);
 758:../lib/fat.c  **** 
 759:../lib/fat.c  ****     /* mark cluster as the last one */
 760:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 761:../lib/fat.c  ****     if(fs->partition->type == PARTITION_TYPE_FAT32)
 762:../lib/fat.c  ****     {
 763:../lib/fat.c  ****         uint32_t fat_entry = HTOL32(FAT32_CLUSTER_LAST_MAX);
 764:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 765:../lib/fat.c  ****             return 0;
 766:../lib/fat.c  ****     }
 767:../lib/fat.c  ****     else
 768:../lib/fat.c  **** #endif
 769:../lib/fat.c  ****     {
 770:../lib/fat.c  ****         uint16_t fat_entry = HTOL16(FAT16_CLUSTER_LAST_MAX);
 771:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 772:../lib/fat.c  ****             return 0;
 773:../lib/fat.c  ****     }
 774:../lib/fat.c  **** 
 775:../lib/fat.c  ****     /* free remaining clusters */
 776:../lib/fat.c  ****     if(cluster_num_next)
 777:../lib/fat.c  ****         return fat_free_clusters(fs, cluster_num_next);
 778:../lib/fat.c  ****     else
 779:../lib/fat.c  ****         return 1;
 780:../lib/fat.c  **** }
 781:../lib/fat.c  **** #endif
 782:../lib/fat.c  **** 
 783:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
 784:../lib/fat.c  **** /**
 785:../lib/fat.c  ****  * \ingroup fat_fs
 786:../lib/fat.c  ****  * Clears a single cluster.
 787:../lib/fat.c  ****  *
 788:../lib/fat.c  ****  * The complete cluster is filled with zeros.
 789:../lib/fat.c  ****  *
 790:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
 791:../lib/fat.c  ****  * \param[in] cluster_num The cluster to clear.
 792:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
 793:../lib/fat.c  ****  */
 794:../lib/fat.c  **** uint8_t fat_clear_cluster(const struct fat_fs_struct* fs, cluster_t cluster_num)
 795:../lib/fat.c  **** {
 796:../lib/fat.c  ****     if(cluster_num < 2)
 797:../lib/fat.c  ****         return 0;
 798:../lib/fat.c  **** 
 799:../lib/fat.c  ****     offset_t cluster_offset = fat_cluster_offset(fs, cluster_num);
 800:../lib/fat.c  **** 
 801:../lib/fat.c  ****     uint8_t zero[16];
 802:../lib/fat.c  ****     memset(zero, 0, sizeof(zero));
 803:../lib/fat.c  ****     return fs->partition->device_write_interval(cluster_offset,
 804:../lib/fat.c  ****                                                 zero,
 805:../lib/fat.c  ****                                                 fs->header.cluster_size,
 806:../lib/fat.c  ****                                                 fat_clear_cluster_callback,
 807:../lib/fat.c  ****                                                 0
 808:../lib/fat.c  ****                                                );
 809:../lib/fat.c  **** }
 810:../lib/fat.c  **** #endif
 811:../lib/fat.c  **** 
 812:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
 813:../lib/fat.c  **** /**
 814:../lib/fat.c  ****  * \ingroup fat_fs
 815:../lib/fat.c  ****  * Callback function for clearing a cluster.
 816:../lib/fat.c  ****  */
 817:../lib/fat.c  **** uintptr_t fat_clear_cluster_callback(uint8_t* buffer, offset_t offset, void* p)
 818:../lib/fat.c  **** {
  10              		.loc 1 818 0
  11              		.cfi_startproc
  12              		@ Function supports interworking.
  13              		@ args = 0, pretend = 0, frame = 0
  14              		@ frame_needed = 0, uses_anonymous_args = 0
  15              		@ link register save eliminated.
  16              	.LVL0:
 819:../lib/fat.c  ****     return 16;
 820:../lib/fat.c  **** }
  17              		.loc 1 820 0
  18 0000 1000A0E3 		mov	r0, #16
  19              	.LVL1:
  20 0004 1EFF2FE1 		bx	lr
  21              		.cfi_endproc
  22              	.LFE8:
  24              		.align	2
  26              	fat_calc_83_checksum:
  27              	.LFB22:
 821:../lib/fat.c  **** #endif
 822:../lib/fat.c  **** 
 823:../lib/fat.c  **** /**
 824:../lib/fat.c  ****  * \ingroup fat_fs
 825:../lib/fat.c  ****  * Calculates the offset of the specified cluster.
 826:../lib/fat.c  ****  *
 827:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
 828:../lib/fat.c  ****  * \param[in] cluster_num The cluster whose offset to calculate.
 829:../lib/fat.c  ****  * \returns The cluster offset.
 830:../lib/fat.c  ****  */
 831:../lib/fat.c  **** offset_t fat_cluster_offset(const struct fat_fs_struct* fs, cluster_t cluster_num)
 832:../lib/fat.c  **** {
 833:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 834:../lib/fat.c  ****         return 0;
 835:../lib/fat.c  **** 
 836:../lib/fat.c  ****     return fs->header.cluster_zero_offset + (offset_t) (cluster_num - 2) * fs->header.cluster_size;
 837:../lib/fat.c  **** }
 838:../lib/fat.c  **** 
 839:../lib/fat.c  **** /**
 840:../lib/fat.c  ****  * \ingroup fat_file
 841:../lib/fat.c  ****  * Retrieves the directory entry of a path.
 842:../lib/fat.c  ****  *
 843:../lib/fat.c  ****  * The given path may both describe a file or a directory.
 844:../lib/fat.c  ****  *
 845:../lib/fat.c  ****  * \param[in] fs The FAT filesystem on which to search.
 846:../lib/fat.c  ****  * \param[in] path The path of which to read the directory entry.
 847:../lib/fat.c  ****  * \param[out] dir_entry The directory entry to fill.
 848:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
 849:../lib/fat.c  ****  * \see fat_read_dir
 850:../lib/fat.c  ****  */
 851:../lib/fat.c  **** uint8_t fat_get_dir_entry_of_path(struct fat_fs_struct* fs, const char* path, struct fat_dir_entry_
 852:../lib/fat.c  **** {
 853:../lib/fat.c  ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 854:../lib/fat.c  ****         return 0;
 855:../lib/fat.c  **** 
 856:../lib/fat.c  ****     if(path[0] == '/')
 857:../lib/fat.c  ****         ++path;
 858:../lib/fat.c  **** 
 859:../lib/fat.c  ****     /* begin with the root directory */
 860:../lib/fat.c  ****     memset(dir_entry, 0, sizeof(*dir_entry));
 861:../lib/fat.c  ****     dir_entry->attributes = FAT_ATTRIB_DIR;
 862:../lib/fat.c  **** 
 863:../lib/fat.c  ****     while(1)
 864:../lib/fat.c  ****     {
 865:../lib/fat.c  ****         if(path[0] == '\0')
 866:../lib/fat.c  ****             return 1;
 867:../lib/fat.c  **** 
 868:../lib/fat.c  ****         struct fat_dir_struct* dd = fat_open_dir(fs, dir_entry);
 869:../lib/fat.c  ****         if(!dd)
 870:../lib/fat.c  ****             break;
 871:../lib/fat.c  **** 
 872:../lib/fat.c  ****         /* extract the next hierarchy we will search for */
 873:../lib/fat.c  ****         const char* sub_path = strchr(path, '/');
 874:../lib/fat.c  ****         uint8_t length_to_sep;
 875:../lib/fat.c  ****         if(sub_path)
 876:../lib/fat.c  ****         {
 877:../lib/fat.c  ****             length_to_sep = sub_path - path;
 878:../lib/fat.c  ****             ++sub_path;
 879:../lib/fat.c  ****         }
 880:../lib/fat.c  ****         else
 881:../lib/fat.c  ****         {
 882:../lib/fat.c  ****             length_to_sep = strlen(path);
 883:../lib/fat.c  ****             sub_path = path + length_to_sep;
 884:../lib/fat.c  ****         }
 885:../lib/fat.c  ****         
 886:../lib/fat.c  ****         /* read directory entries */
 887:../lib/fat.c  ****         while(fat_read_dir(dd, dir_entry))
 888:../lib/fat.c  ****         {
 889:../lib/fat.c  ****             /* check if we have found the next hierarchy */
 890:../lib/fat.c  ****             if((strlen(dir_entry->long_name) != length_to_sep ||
 891:../lib/fat.c  ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 892:../lib/fat.c  ****                 continue;
 893:../lib/fat.c  **** 
 894:../lib/fat.c  ****             fat_close_dir(dd);
 895:../lib/fat.c  ****             dd = 0;
 896:../lib/fat.c  **** 
 897:../lib/fat.c  ****             if(path[length_to_sep] == '\0')
 898:../lib/fat.c  ****                 /* we iterated through the whole path and have found the file */
 899:../lib/fat.c  ****                 return 1;
 900:../lib/fat.c  **** 
 901:../lib/fat.c  ****             if(dir_entry->attributes & FAT_ATTRIB_DIR)
 902:../lib/fat.c  ****             {
 903:../lib/fat.c  ****                 /* we found a parent directory of the file we are searching for */
 904:../lib/fat.c  ****                 path = sub_path;
 905:../lib/fat.c  ****                 break;
 906:../lib/fat.c  ****             }
 907:../lib/fat.c  **** 
 908:../lib/fat.c  ****             /* a parent of the file exists, but not the file itself */
 909:../lib/fat.c  ****             return 0;
 910:../lib/fat.c  ****         }
 911:../lib/fat.c  **** 
 912:../lib/fat.c  ****         fat_close_dir(dd);
 913:../lib/fat.c  ****     }
 914:../lib/fat.c  ****     
 915:../lib/fat.c  ****     return 0;
 916:../lib/fat.c  **** }
 917:../lib/fat.c  **** 
 918:../lib/fat.c  **** /**
 919:../lib/fat.c  ****  * \ingroup fat_file
 920:../lib/fat.c  ****  * Opens a file on a FAT filesystem.
 921:../lib/fat.c  ****  *
 922:../lib/fat.c  ****  * \param[in] fs The filesystem on which the file to open lies.
 923:../lib/fat.c  ****  * \param[in] dir_entry The directory entry of the file to open.
 924:../lib/fat.c  ****  * \returns The file handle, or 0 on failure.
 925:../lib/fat.c  ****  * \see fat_close_file
 926:../lib/fat.c  ****  */
 927:../lib/fat.c  **** struct fat_file_struct* fat_open_file(struct fat_fs_struct* fs, const struct fat_dir_entry_struct* 
 928:../lib/fat.c  **** {
 929:../lib/fat.c  ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT_ATTRIB_DIR))
 930:../lib/fat.c  ****         return 0;
 931:../lib/fat.c  **** 
 932:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
 933:../lib/fat.c  ****     struct fat_file_struct* fd = malloc(sizeof(*fd));
 934:../lib/fat.c  ****     if(!fd)
 935:../lib/fat.c  ****         return 0;
 936:../lib/fat.c  **** #else
 937:../lib/fat.c  ****     struct fat_file_struct* fd = fat_file_handles;
 938:../lib/fat.c  ****     uint8_t i;
 939:../lib/fat.c  ****     for(i = 0; i < FAT_FILE_COUNT; ++i)
 940:../lib/fat.c  ****     {
 941:../lib/fat.c  ****         if(!fd->fs)
 942:../lib/fat.c  ****             break;
 943:../lib/fat.c  **** 
 944:../lib/fat.c  ****         ++fd;
 945:../lib/fat.c  ****     }
 946:../lib/fat.c  ****     if(i >= FAT_FILE_COUNT)
 947:../lib/fat.c  ****         return 0;
 948:../lib/fat.c  **** #endif
 949:../lib/fat.c  ****     
 950:../lib/fat.c  ****     memcpy(&fd->dir_entry, dir_entry, sizeof(*dir_entry));
 951:../lib/fat.c  ****     fd->fs = fs;
 952:../lib/fat.c  ****     fd->pos = 0;
 953:../lib/fat.c  ****     fd->pos_cluster = dir_entry->cluster;
 954:../lib/fat.c  **** 
 955:../lib/fat.c  ****     return fd;
 956:../lib/fat.c  **** }
 957:../lib/fat.c  **** 
 958:../lib/fat.c  **** /**
 959:../lib/fat.c  ****  * \ingroup fat_file
 960:../lib/fat.c  ****  * Closes a file.
 961:../lib/fat.c  ****  *
 962:../lib/fat.c  ****  * \param[in] fd The file handle of the file to close.
 963:../lib/fat.c  ****  * \see fat_open_file
 964:../lib/fat.c  ****  */
 965:../lib/fat.c  **** void fat_close_file(struct fat_file_struct* fd)
 966:../lib/fat.c  **** {
 967:../lib/fat.c  ****     if(fd)
 968:../lib/fat.c  ****     {
 969:../lib/fat.c  **** #if FAT_DELAY_DIRENTRY_UPDATE
 970:../lib/fat.c  ****         /* write directory entry */
 971:../lib/fat.c  ****         fat_write_dir_entry(fd->fs, &fd->dir_entry);
 972:../lib/fat.c  **** #endif
 973:../lib/fat.c  **** 
 974:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
 975:../lib/fat.c  ****         free(fd);
 976:../lib/fat.c  **** #else
 977:../lib/fat.c  ****         fd->fs = 0;
 978:../lib/fat.c  **** #endif
 979:../lib/fat.c  ****     }
 980:../lib/fat.c  **** }
 981:../lib/fat.c  **** 
 982:../lib/fat.c  **** /**
 983:../lib/fat.c  ****  * \ingroup fat_file
 984:../lib/fat.c  ****  * Reads data from a file.
 985:../lib/fat.c  ****  * 
 986:../lib/fat.c  ****  * The data requested is read from the current file location.
 987:../lib/fat.c  ****  *
 988:../lib/fat.c  ****  * \param[in] fd The file handle of the file from which to read.
 989:../lib/fat.c  ****  * \param[out] buffer The buffer into which to write.
 990:../lib/fat.c  ****  * \param[in] buffer_len The amount of data to read.
 991:../lib/fat.c  ****  * \returns The number of bytes read, 0 on end of file, or -1 on failure.
 992:../lib/fat.c  ****  * \see fat_write_file
 993:../lib/fat.c  ****  */
 994:../lib/fat.c  **** intptr_t fat_read_file(struct fat_file_struct* fd, uint8_t* buffer, uintptr_t buffer_len)
 995:../lib/fat.c  **** {
 996:../lib/fat.c  ****     /* check arguments */
 997:../lib/fat.c  ****     if(!fd || !buffer || buffer_len < 1)
 998:../lib/fat.c  ****         return -1;
 999:../lib/fat.c  **** 
1000:../lib/fat.c  ****     /* determine number of bytes to read */
1001:../lib/fat.c  ****     if(fd->pos + buffer_len > fd->dir_entry.file_size)
1002:../lib/fat.c  ****         buffer_len = fd->dir_entry.file_size - fd->pos;
1003:../lib/fat.c  ****     if(buffer_len == 0)
1004:../lib/fat.c  ****         return 0;
1005:../lib/fat.c  ****     
1006:../lib/fat.c  ****     uint16_t cluster_size = fd->fs->header.cluster_size;
1007:../lib/fat.c  ****     cluster_t cluster_num = fd->pos_cluster;
1008:../lib/fat.c  ****     uintptr_t buffer_left = buffer_len;
1009:../lib/fat.c  ****     uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));
1010:../lib/fat.c  **** 
1011:../lib/fat.c  ****     /* find cluster in which to start reading */
1012:../lib/fat.c  ****     if(!cluster_num)
1013:../lib/fat.c  ****     {
1014:../lib/fat.c  ****         cluster_num = fd->dir_entry.cluster;
1015:../lib/fat.c  ****         
1016:../lib/fat.c  ****         if(!cluster_num)
1017:../lib/fat.c  ****         {
1018:../lib/fat.c  ****             if(!fd->pos)
1019:../lib/fat.c  ****                 return 0;
1020:../lib/fat.c  ****             else
1021:../lib/fat.c  ****                 return -1;
1022:../lib/fat.c  ****         }
1023:../lib/fat.c  **** 
1024:../lib/fat.c  ****         if(fd->pos)
1025:../lib/fat.c  ****         {
1026:../lib/fat.c  ****             uint32_t pos = fd->pos;
1027:../lib/fat.c  ****             while(pos >= cluster_size)
1028:../lib/fat.c  ****             {
1029:../lib/fat.c  ****                 pos -= cluster_size;
1030:../lib/fat.c  ****                 cluster_num = fat_get_next_cluster(fd->fs, cluster_num);
1031:../lib/fat.c  ****                 if(!cluster_num)
1032:../lib/fat.c  ****                     return -1;
1033:../lib/fat.c  ****             }
1034:../lib/fat.c  ****         }
1035:../lib/fat.c  ****     }
1036:../lib/fat.c  ****     
1037:../lib/fat.c  ****     /* read data */
1038:../lib/fat.c  ****     do
1039:../lib/fat.c  ****     {
1040:../lib/fat.c  ****         /* calculate data size to copy from cluster */
1041:../lib/fat.c  ****         offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
1042:../lib/fat.c  ****         uint16_t copy_length = cluster_size - first_cluster_offset;
1043:../lib/fat.c  ****         if(copy_length > buffer_left)
1044:../lib/fat.c  ****             copy_length = buffer_left;
1045:../lib/fat.c  **** 
1046:../lib/fat.c  ****         /* read data */
1047:../lib/fat.c  ****         if(!fd->fs->partition->device_read(cluster_offset, buffer, copy_length))
1048:../lib/fat.c  ****             return buffer_len - buffer_left;
1049:../lib/fat.c  **** 
1050:../lib/fat.c  ****         /* calculate new file position */
1051:../lib/fat.c  ****         buffer += copy_length;
1052:../lib/fat.c  ****         buffer_left -= copy_length;
1053:../lib/fat.c  ****         fd->pos += copy_length;
1054:../lib/fat.c  **** 
1055:../lib/fat.c  ****         if(first_cluster_offset + copy_length >= cluster_size)
1056:../lib/fat.c  ****         {
1057:../lib/fat.c  ****             /* we are on a cluster boundary, so get the next cluster */
1058:../lib/fat.c  ****             if((cluster_num = fat_get_next_cluster(fd->fs, cluster_num)))
1059:../lib/fat.c  ****             {
1060:../lib/fat.c  ****                 first_cluster_offset = 0;
1061:../lib/fat.c  ****             }
1062:../lib/fat.c  ****             else
1063:../lib/fat.c  ****             {
1064:../lib/fat.c  ****                 fd->pos_cluster = 0;
1065:../lib/fat.c  ****                 return buffer_len - buffer_left;
1066:../lib/fat.c  ****             }
1067:../lib/fat.c  ****         }
1068:../lib/fat.c  **** 
1069:../lib/fat.c  ****         fd->pos_cluster = cluster_num;
1070:../lib/fat.c  **** 
1071:../lib/fat.c  ****     } while(buffer_left > 0); /* check if we are done */
1072:../lib/fat.c  **** 
1073:../lib/fat.c  ****     return buffer_len;
1074:../lib/fat.c  **** }
1075:../lib/fat.c  **** 
1076:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
1077:../lib/fat.c  **** /**
1078:../lib/fat.c  ****  * \ingroup fat_file
1079:../lib/fat.c  ****  * Writes data to a file.
1080:../lib/fat.c  ****  * 
1081:../lib/fat.c  ****  * The data is written to the current file location.
1082:../lib/fat.c  ****  *
1083:../lib/fat.c  ****  * \param[in] fd The file handle of the file to which to write.
1084:../lib/fat.c  ****  * \param[in] buffer The buffer from which to read the data to be written.
1085:../lib/fat.c  ****  * \param[in] buffer_len The amount of data to write.
1086:../lib/fat.c  ****  * \returns The number of bytes written (0 or something less than \c buffer_len on disk full) or -1
1087:../lib/fat.c  ****  * \see fat_read_file
1088:../lib/fat.c  ****  */
1089:../lib/fat.c  **** intptr_t fat_write_file(struct fat_file_struct* fd, const uint8_t* buffer, uintptr_t buffer_len)
1090:../lib/fat.c  **** {
1091:../lib/fat.c  ****     /* check arguments */
1092:../lib/fat.c  ****     if(!fd || !buffer || buffer_len < 1)
1093:../lib/fat.c  ****         return -1;
1094:../lib/fat.c  ****     if(fd->pos > fd->dir_entry.file_size)
1095:../lib/fat.c  ****         return -1;
1096:../lib/fat.c  **** 
1097:../lib/fat.c  ****     uint16_t cluster_size = fd->fs->header.cluster_size;
1098:../lib/fat.c  ****     cluster_t cluster_num = fd->pos_cluster;
1099:../lib/fat.c  ****     uintptr_t buffer_left = buffer_len;
1100:../lib/fat.c  ****     uint16_t first_cluster_offset = (uint16_t) (fd->pos & (cluster_size - 1));
1101:../lib/fat.c  **** 
1102:../lib/fat.c  ****     /* find cluster in which to start writing */
1103:../lib/fat.c  ****     if(!cluster_num)
1104:../lib/fat.c  ****     {
1105:../lib/fat.c  ****         cluster_num = fd->dir_entry.cluster;
1106:../lib/fat.c  ****         
1107:../lib/fat.c  ****         if(!cluster_num)
1108:../lib/fat.c  ****         {
1109:../lib/fat.c  ****             if(!fd->pos)
1110:../lib/fat.c  ****             {
1111:../lib/fat.c  ****                 /* empty file */
1112:../lib/fat.c  ****                 fd->dir_entry.cluster = cluster_num = fat_append_clusters(fd->fs, 0, 1);
1113:../lib/fat.c  ****                 if(!cluster_num)
1114:../lib/fat.c  ****                     return 0;
1115:../lib/fat.c  ****             }
1116:../lib/fat.c  ****             else
1117:../lib/fat.c  ****             {
1118:../lib/fat.c  ****                 return -1;
1119:../lib/fat.c  ****             }
1120:../lib/fat.c  ****         }
1121:../lib/fat.c  **** 
1122:../lib/fat.c  ****         if(fd->pos)
1123:../lib/fat.c  ****         {
1124:../lib/fat.c  ****             uint32_t pos = fd->pos;
1125:../lib/fat.c  ****             cluster_t cluster_num_next;
1126:../lib/fat.c  ****             while(pos >= cluster_size)
1127:../lib/fat.c  ****             {
1128:../lib/fat.c  ****                 pos -= cluster_size;
1129:../lib/fat.c  ****                 cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
1130:../lib/fat.c  ****                 if(!cluster_num_next)
1131:../lib/fat.c  ****                 {
1132:../lib/fat.c  ****                     if(pos != 0)
1133:../lib/fat.c  ****                         return -1; /* current file position points beyond end of file */
1134:../lib/fat.c  **** 
1135:../lib/fat.c  ****                     /* the file exactly ends on a cluster boundary, and we append to it */
1136:../lib/fat.c  ****                     cluster_num_next = fat_append_clusters(fd->fs, cluster_num, 1);
1137:../lib/fat.c  ****                     if(!cluster_num_next)
1138:../lib/fat.c  ****                         return 0;
1139:../lib/fat.c  ****                 }
1140:../lib/fat.c  **** 
1141:../lib/fat.c  ****                 cluster_num = cluster_num_next;
1142:../lib/fat.c  ****             }
1143:../lib/fat.c  ****         }
1144:../lib/fat.c  ****     }
1145:../lib/fat.c  ****     
1146:../lib/fat.c  ****     /* write data */
1147:../lib/fat.c  ****     do
1148:../lib/fat.c  ****     {
1149:../lib/fat.c  ****         /* calculate data size to write to cluster */
1150:../lib/fat.c  ****         offset_t cluster_offset = fat_cluster_offset(fd->fs, cluster_num) + first_cluster_offset;
1151:../lib/fat.c  ****         uint16_t write_length = cluster_size - first_cluster_offset;
1152:../lib/fat.c  ****         if(write_length > buffer_left)
1153:../lib/fat.c  ****             write_length = buffer_left;
1154:../lib/fat.c  **** 
1155:../lib/fat.c  ****         /* write data which fits into the current cluster */
1156:../lib/fat.c  ****         if(!fd->fs->partition->device_write(cluster_offset, buffer, write_length))
1157:../lib/fat.c  ****             break;
1158:../lib/fat.c  **** 
1159:../lib/fat.c  ****         /* calculate new file position */
1160:../lib/fat.c  ****         buffer += write_length;
1161:../lib/fat.c  ****         buffer_left -= write_length;
1162:../lib/fat.c  ****         fd->pos += write_length;
1163:../lib/fat.c  **** 
1164:../lib/fat.c  ****         if(first_cluster_offset + write_length >= cluster_size)
1165:../lib/fat.c  ****         {
1166:../lib/fat.c  ****             /* we are on a cluster boundary, so get the next cluster */
1167:../lib/fat.c  ****             cluster_t cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
1168:../lib/fat.c  ****             if(!cluster_num_next && buffer_left > 0)
1169:../lib/fat.c  ****                 /* we reached the last cluster, append a new one */
1170:../lib/fat.c  ****                 cluster_num_next = fat_append_clusters(fd->fs, cluster_num, 1);
1171:../lib/fat.c  ****             if(!cluster_num_next)
1172:../lib/fat.c  ****             {
1173:../lib/fat.c  ****                 fd->pos_cluster = 0;
1174:../lib/fat.c  ****                 break;
1175:../lib/fat.c  ****             }
1176:../lib/fat.c  **** 
1177:../lib/fat.c  ****             cluster_num = cluster_num_next;
1178:../lib/fat.c  ****             first_cluster_offset = 0;
1179:../lib/fat.c  ****         }
1180:../lib/fat.c  **** 
1181:../lib/fat.c  ****         fd->pos_cluster = cluster_num;
1182:../lib/fat.c  **** 
1183:../lib/fat.c  ****     } while(buffer_left > 0); /* check if we are done */
1184:../lib/fat.c  **** 
1185:../lib/fat.c  ****     /* update directory entry */
1186:../lib/fat.c  ****     if(fd->pos > fd->dir_entry.file_size)
1187:../lib/fat.c  ****     {
1188:../lib/fat.c  **** #if !FAT_DELAY_DIRENTRY_UPDATE
1189:../lib/fat.c  ****         uint32_t size_old = fd->dir_entry.file_size;
1190:../lib/fat.c  **** #endif
1191:../lib/fat.c  **** 
1192:../lib/fat.c  ****         /* update file size */
1193:../lib/fat.c  ****         fd->dir_entry.file_size = fd->pos;
1194:../lib/fat.c  **** 
1195:../lib/fat.c  **** #if !FAT_DELAY_DIRENTRY_UPDATE
1196:../lib/fat.c  ****         /* write directory entry */
1197:../lib/fat.c  ****         if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
1198:../lib/fat.c  ****         {
1199:../lib/fat.c  ****             /* We do not return an error here since we actually wrote
1200:../lib/fat.c  ****              * some data to disk. So we calculate the amount of data
1201:../lib/fat.c  ****              * we wrote to disk and which lies within the old file size.
1202:../lib/fat.c  ****              */
1203:../lib/fat.c  ****             buffer_left = fd->pos - size_old;
1204:../lib/fat.c  ****             fd->pos = size_old;
1205:../lib/fat.c  ****         }
1206:../lib/fat.c  **** #endif
1207:../lib/fat.c  ****     }
1208:../lib/fat.c  **** 
1209:../lib/fat.c  ****     return buffer_len - buffer_left;
1210:../lib/fat.c  **** }
1211:../lib/fat.c  **** #endif
1212:../lib/fat.c  **** 
1213:../lib/fat.c  **** /**
1214:../lib/fat.c  ****  * \ingroup fat_file
1215:../lib/fat.c  ****  * Repositions the read/write file offset.
1216:../lib/fat.c  ****  *
1217:../lib/fat.c  ****  * Changes the file offset where the next call to fat_read_file()
1218:../lib/fat.c  ****  * or fat_write_file() starts reading/writing.
1219:../lib/fat.c  ****  *
1220:../lib/fat.c  ****  * If the new offset is beyond the end of the file, fat_resize_file()
1221:../lib/fat.c  ****  * is implicitly called, i.e. the file is expanded.
1222:../lib/fat.c  ****  *
1223:../lib/fat.c  ****  * The new offset can be given in different ways determined by
1224:../lib/fat.c  ****  * the \c whence parameter:
1225:../lib/fat.c  ****  * - \b FAT_SEEK_SET: \c *offset is relative to the beginning of the file.
1226:../lib/fat.c  ****  * - \b FAT_SEEK_CUR: \c *offset is relative to the current file position.
1227:../lib/fat.c  ****  * - \b FAT_SEEK_END: \c *offset is relative to the end of the file.
1228:../lib/fat.c  ****  *
1229:../lib/fat.c  ****  * The resulting absolute offset is written to the location the \c offset
1230:../lib/fat.c  ****  * parameter points to.
1231:../lib/fat.c  ****  *
1232:../lib/fat.c  ****  * Calling this function can also be used to retrieve the current file position:
1233:../lib/fat.c  ****    \code
1234:../lib/fat.c  ****    int32_t file_pos = 0;
1235:../lib/fat.c  ****    if(!fat_seek_file(fd, &file_pos, FAT_SEEK_CUR))
1236:../lib/fat.c  ****    {
1237:../lib/fat.c  ****        // error
1238:../lib/fat.c  ****    }
1239:../lib/fat.c  ****    // file_pos now contains the absolute file position
1240:../lib/fat.c  ****    \endcode
1241:../lib/fat.c  ****  * 
1242:../lib/fat.c  ****  * \param[in] fd The file decriptor of the file on which to seek.
1243:../lib/fat.c  ****  * \param[in,out] offset A pointer to the new offset, as affected by the \c whence
1244:../lib/fat.c  ****  *                   parameter. The function writes the new absolute offset
1245:../lib/fat.c  ****  *                   to this location before it returns.
1246:../lib/fat.c  ****  * \param[in] whence Affects the way \c offset is interpreted, see above.
1247:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
1248:../lib/fat.c  ****  */
1249:../lib/fat.c  **** uint8_t fat_seek_file(struct fat_file_struct* fd, int32_t* offset, uint8_t whence)
1250:../lib/fat.c  **** {
1251:../lib/fat.c  ****     if(!fd || !offset)
1252:../lib/fat.c  ****         return 0;
1253:../lib/fat.c  **** 
1254:../lib/fat.c  ****     uint32_t new_pos = fd->pos;
1255:../lib/fat.c  ****     switch(whence)
1256:../lib/fat.c  ****     {
1257:../lib/fat.c  ****         case FAT_SEEK_SET:
1258:../lib/fat.c  ****             new_pos = *offset;
1259:../lib/fat.c  ****             break;
1260:../lib/fat.c  ****         case FAT_SEEK_CUR:
1261:../lib/fat.c  ****             new_pos += *offset;
1262:../lib/fat.c  ****             break;
1263:../lib/fat.c  ****         case FAT_SEEK_END:
1264:../lib/fat.c  ****             new_pos = fd->dir_entry.file_size + *offset;
1265:../lib/fat.c  ****             break;
1266:../lib/fat.c  ****         default:
1267:../lib/fat.c  ****             return 0;
1268:../lib/fat.c  ****     }
1269:../lib/fat.c  **** 
1270:../lib/fat.c  ****     if(new_pos > fd->dir_entry.file_size
1271:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
1272:../lib/fat.c  ****        && !fat_resize_file(fd, new_pos)
1273:../lib/fat.c  **** #endif
1274:../lib/fat.c  ****        )
1275:../lib/fat.c  ****         return 0;
1276:../lib/fat.c  **** 
1277:../lib/fat.c  ****     fd->pos = new_pos;
1278:../lib/fat.c  ****     fd->pos_cluster = 0;
1279:../lib/fat.c  **** 
1280:../lib/fat.c  ****     *offset = (int32_t) new_pos;
1281:../lib/fat.c  ****     return 1;
1282:../lib/fat.c  **** }
1283:../lib/fat.c  **** 
1284:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
1285:../lib/fat.c  **** /**
1286:../lib/fat.c  ****  * \ingroup fat_file
1287:../lib/fat.c  ****  * Resizes a file to have a specific size.
1288:../lib/fat.c  ****  *
1289:../lib/fat.c  ****  * Enlarges or shrinks the file pointed to by the file descriptor to have
1290:../lib/fat.c  ****  * exactly the specified size.
1291:../lib/fat.c  ****  *
1292:../lib/fat.c  ****  * If the file is truncated, all bytes having an equal or larger offset
1293:../lib/fat.c  ****  * than the given size are lost. If the file is expanded, the additional
1294:../lib/fat.c  ****  * bytes are allocated.
1295:../lib/fat.c  ****  *
1296:../lib/fat.c  ****  * \note Please be aware that this function just allocates or deallocates disk
1297:../lib/fat.c  ****  * space, it does not explicitely clear it. To avoid data leakage, this
1298:../lib/fat.c  ****  * must be done manually.
1299:../lib/fat.c  ****  *
1300:../lib/fat.c  ****  * \param[in] fd The file decriptor of the file which to resize.
1301:../lib/fat.c  ****  * \param[in] size The new size of the file.
1302:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
1303:../lib/fat.c  ****  */
1304:../lib/fat.c  **** uint8_t fat_resize_file(struct fat_file_struct* fd, uint32_t size)
1305:../lib/fat.c  **** {
1306:../lib/fat.c  ****     if(!fd)
1307:../lib/fat.c  ****         return 0;
1308:../lib/fat.c  **** 
1309:../lib/fat.c  ****     cluster_t cluster_num = fd->dir_entry.cluster;
1310:../lib/fat.c  ****     uint16_t cluster_size = fd->fs->header.cluster_size;
1311:../lib/fat.c  ****     uint32_t size_new = size;
1312:../lib/fat.c  **** 
1313:../lib/fat.c  ****     do
1314:../lib/fat.c  ****     {
1315:../lib/fat.c  ****         if(cluster_num == 0 && size_new == 0)
1316:../lib/fat.c  ****             /* the file stays empty */
1317:../lib/fat.c  ****             break;
1318:../lib/fat.c  **** 
1319:../lib/fat.c  ****         /* seek to the next cluster as long as we need the space */
1320:../lib/fat.c  ****         while(size_new > cluster_size)
1321:../lib/fat.c  ****         {
1322:../lib/fat.c  ****             /* get next cluster of file */
1323:../lib/fat.c  ****             cluster_t cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
1324:../lib/fat.c  ****             if(cluster_num_next)
1325:../lib/fat.c  ****             {
1326:../lib/fat.c  ****                 cluster_num = cluster_num_next;
1327:../lib/fat.c  ****                 size_new -= cluster_size;
1328:../lib/fat.c  ****             }
1329:../lib/fat.c  ****             else
1330:../lib/fat.c  ****             {
1331:../lib/fat.c  ****                 break;
1332:../lib/fat.c  ****             }
1333:../lib/fat.c  ****         }
1334:../lib/fat.c  **** 
1335:../lib/fat.c  ****         if(size_new > cluster_size || cluster_num == 0)
1336:../lib/fat.c  ****         {
1337:../lib/fat.c  ****             /* Allocate new cluster chain and append
1338:../lib/fat.c  ****              * it to the existing one, if available.
1339:../lib/fat.c  ****              */
1340:../lib/fat.c  ****             cluster_t cluster_count = (size_new + cluster_size - 1) / cluster_size;
1341:../lib/fat.c  ****             cluster_t cluster_new_chain = fat_append_clusters(fd->fs, cluster_num, cluster_count);
1342:../lib/fat.c  ****             if(!cluster_new_chain)
1343:../lib/fat.c  ****                 return 0;
1344:../lib/fat.c  **** 
1345:../lib/fat.c  ****             if(!cluster_num)
1346:../lib/fat.c  ****             {
1347:../lib/fat.c  ****                 cluster_num = cluster_new_chain;
1348:../lib/fat.c  ****                 fd->dir_entry.cluster = cluster_num;
1349:../lib/fat.c  ****             }
1350:../lib/fat.c  ****         }
1351:../lib/fat.c  **** 
1352:../lib/fat.c  ****         /* write new directory entry */
1353:../lib/fat.c  ****         fd->dir_entry.file_size = size;
1354:../lib/fat.c  ****         if(size == 0)
1355:../lib/fat.c  ****             fd->dir_entry.cluster = 0;
1356:../lib/fat.c  ****         if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
1357:../lib/fat.c  ****             return 0;
1358:../lib/fat.c  **** 
1359:../lib/fat.c  ****         if(size == 0)
1360:../lib/fat.c  ****         {
1361:../lib/fat.c  ****             /* free all clusters of file */
1362:../lib/fat.c  ****             fat_free_clusters(fd->fs, cluster_num);
1363:../lib/fat.c  ****         }
1364:../lib/fat.c  ****         else if(size_new <= cluster_size)
1365:../lib/fat.c  ****         {
1366:../lib/fat.c  ****             /* free all clusters no longer needed */
1367:../lib/fat.c  ****             fat_terminate_clusters(fd->fs, cluster_num);
1368:../lib/fat.c  ****         }
1369:../lib/fat.c  **** 
1370:../lib/fat.c  ****     } while(0);
1371:../lib/fat.c  **** 
1372:../lib/fat.c  ****     /* correct file position */
1373:../lib/fat.c  ****     if(size < fd->pos)
1374:../lib/fat.c  ****     {
1375:../lib/fat.c  ****         fd->pos = size;
1376:../lib/fat.c  ****         fd->pos_cluster = 0;
1377:../lib/fat.c  ****     }
1378:../lib/fat.c  **** 
1379:../lib/fat.c  ****     return 1;
1380:../lib/fat.c  **** }
1381:../lib/fat.c  **** #endif
1382:../lib/fat.c  **** 
1383:../lib/fat.c  **** /**
1384:../lib/fat.c  ****  * \ingroup fat_dir
1385:../lib/fat.c  ****  * Opens a directory.
1386:../lib/fat.c  ****  *
1387:../lib/fat.c  ****  * \param[in] fs The filesystem on which the directory to open resides.
1388:../lib/fat.c  ****  * \param[in] dir_entry The directory entry which stands for the directory to open.
1389:../lib/fat.c  ****  * \returns An opaque directory descriptor on success, 0 on failure.
1390:../lib/fat.c  ****  * \see fat_close_dir
1391:../lib/fat.c  ****  */
1392:../lib/fat.c  **** struct fat_dir_struct* fat_open_dir(struct fat_fs_struct* fs, const struct fat_dir_entry_struct* di
1393:../lib/fat.c  **** {
1394:../lib/fat.c  ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT_ATTRIB_DIR))
1395:../lib/fat.c  ****         return 0;
1396:../lib/fat.c  **** 
1397:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
1398:../lib/fat.c  ****     struct fat_dir_struct* dd = malloc(sizeof(*dd));
1399:../lib/fat.c  ****     if(!dd)
1400:../lib/fat.c  ****         return 0;
1401:../lib/fat.c  **** #else
1402:../lib/fat.c  ****     struct fat_dir_struct* dd = fat_dir_handles;
1403:../lib/fat.c  ****     uint8_t i;
1404:../lib/fat.c  ****     for(i = 0; i < FAT_DIR_COUNT; ++i)
1405:../lib/fat.c  ****     {
1406:../lib/fat.c  ****         if(!dd->fs)
1407:../lib/fat.c  ****             break;
1408:../lib/fat.c  **** 
1409:../lib/fat.c  ****         ++dd;
1410:../lib/fat.c  ****     }
1411:../lib/fat.c  ****     if(i >= FAT_DIR_COUNT)
1412:../lib/fat.c  ****         return 0;
1413:../lib/fat.c  **** #endif
1414:../lib/fat.c  ****     
1415:../lib/fat.c  ****     memcpy(&dd->dir_entry, dir_entry, sizeof(*dir_entry));
1416:../lib/fat.c  ****     dd->fs = fs;
1417:../lib/fat.c  ****     dd->entry_cluster = dir_entry->cluster;
1418:../lib/fat.c  ****     dd->entry_offset = 0;
1419:../lib/fat.c  **** 
1420:../lib/fat.c  ****     return dd;
1421:../lib/fat.c  **** }
1422:../lib/fat.c  **** 
1423:../lib/fat.c  **** /**
1424:../lib/fat.c  ****  * \ingroup fat_dir
1425:../lib/fat.c  ****  * Closes a directory descriptor.
1426:../lib/fat.c  ****  *
1427:../lib/fat.c  ****  * This function destroys a directory descriptor which was
1428:../lib/fat.c  ****  * previously obtained by calling fat_open_dir(). When this
1429:../lib/fat.c  ****  * function returns, the given descriptor will be invalid.
1430:../lib/fat.c  ****  *
1431:../lib/fat.c  ****  * \param[in] dd The directory descriptor to close.
1432:../lib/fat.c  ****  * \see fat_open_dir
1433:../lib/fat.c  ****  */
1434:../lib/fat.c  **** void fat_close_dir(struct fat_dir_struct* dd)
1435:../lib/fat.c  **** {
1436:../lib/fat.c  ****     if(dd)
1437:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
1438:../lib/fat.c  ****         free(dd);
1439:../lib/fat.c  **** #else
1440:../lib/fat.c  ****         dd->fs = 0;
1441:../lib/fat.c  **** #endif
1442:../lib/fat.c  **** }
1443:../lib/fat.c  **** 
1444:../lib/fat.c  **** /**
1445:../lib/fat.c  ****  * \ingroup fat_dir
1446:../lib/fat.c  ****  * Reads the next directory entry contained within a parent directory.
1447:../lib/fat.c  ****  *
1448:../lib/fat.c  ****  * \param[in] dd The descriptor of the parent directory from which to read the entry.
1449:../lib/fat.c  ****  * \param[out] dir_entry Pointer to a buffer into which to write the directory entry information.
1450:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
1451:../lib/fat.c  ****  * \see fat_reset_dir
1452:../lib/fat.c  ****  */
1453:../lib/fat.c  **** uint8_t fat_read_dir(struct fat_dir_struct* dd, struct fat_dir_entry_struct* dir_entry)
1454:../lib/fat.c  **** {
1455:../lib/fat.c  ****     if(!dd || !dir_entry)
1456:../lib/fat.c  ****         return 0;
1457:../lib/fat.c  **** 
1458:../lib/fat.c  ****     /* get current position of directory handle */
1459:../lib/fat.c  ****     struct fat_fs_struct* fs = dd->fs;
1460:../lib/fat.c  ****     const struct fat_header_struct* header = &fs->header;
1461:../lib/fat.c  ****     uint16_t cluster_size = header->cluster_size;
1462:../lib/fat.c  ****     cluster_t cluster_num = dd->entry_cluster;
1463:../lib/fat.c  ****     uint16_t cluster_offset = dd->entry_offset;
1464:../lib/fat.c  ****     struct fat_read_dir_callback_arg arg;
1465:../lib/fat.c  **** 
1466:../lib/fat.c  ****     if(cluster_offset >= cluster_size)
1467:../lib/fat.c  ****     {
1468:../lib/fat.c  ****         /* The latest call hit the border of the last cluster in
1469:../lib/fat.c  ****          * the chain, but it still returned a directory entry.
1470:../lib/fat.c  ****          * So we now reset the handle and signal the caller the
1471:../lib/fat.c  ****          * end of the listing.
1472:../lib/fat.c  ****          */
1473:../lib/fat.c  ****         fat_reset_dir(dd);
1474:../lib/fat.c  ****         return 0;
1475:../lib/fat.c  ****     }
1476:../lib/fat.c  **** 
1477:../lib/fat.c  ****     /* reset callback arguments */
1478:../lib/fat.c  ****     memset(&arg, 0, sizeof(arg));
1479:../lib/fat.c  ****     memset(dir_entry, 0, sizeof(*dir_entry));
1480:../lib/fat.c  ****     arg.dir_entry = dir_entry;
1481:../lib/fat.c  **** 
1482:../lib/fat.c  ****     /* check if we read from the root directory */
1483:../lib/fat.c  ****     if(cluster_num == 0)
1484:../lib/fat.c  ****     {
1485:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
1486:../lib/fat.c  ****         if(fs->partition->type == PARTITION_TYPE_FAT32)
1487:../lib/fat.c  ****             cluster_num = header->root_dir_cluster;
1488:../lib/fat.c  ****         else
1489:../lib/fat.c  **** #endif
1490:../lib/fat.c  ****             cluster_size = header->cluster_zero_offset - header->root_dir_offset;
1491:../lib/fat.c  ****     }
1492:../lib/fat.c  **** 
1493:../lib/fat.c  ****     /* read entries */
1494:../lib/fat.c  ****     uint8_t buffer[32];
1495:../lib/fat.c  ****     while(!arg.finished)
1496:../lib/fat.c  ****     {
1497:../lib/fat.c  ****         /* read directory entries up to the cluster border */
1498:../lib/fat.c  ****         uint16_t cluster_left = cluster_size - cluster_offset;
1499:../lib/fat.c  ****         offset_t pos = cluster_offset;
1500:../lib/fat.c  ****         if(cluster_num == 0)
1501:../lib/fat.c  ****             pos += header->root_dir_offset;
1502:../lib/fat.c  ****         else
1503:../lib/fat.c  ****             pos += fat_cluster_offset(fs, cluster_num);
1504:../lib/fat.c  **** 
1505:../lib/fat.c  ****         arg.bytes_read = 0;
1506:../lib/fat.c  ****         if(!fs->partition->device_read_interval(pos,
1507:../lib/fat.c  ****                                                 buffer,
1508:../lib/fat.c  ****                                                 sizeof(buffer),
1509:../lib/fat.c  ****                                                 cluster_left,
1510:../lib/fat.c  ****                                                 fat_dir_entry_read_callback,
1511:../lib/fat.c  ****                                                 &arg)
1512:../lib/fat.c  ****           )
1513:../lib/fat.c  ****             return 0;
1514:../lib/fat.c  **** 
1515:../lib/fat.c  ****         cluster_offset += arg.bytes_read;
1516:../lib/fat.c  **** 
1517:../lib/fat.c  ****         if(cluster_offset >= cluster_size)
1518:../lib/fat.c  ****         {
1519:../lib/fat.c  ****             /* we reached the cluster border and switch to the next cluster */
1520:../lib/fat.c  **** 
1521:../lib/fat.c  ****             /* get number of next cluster */
1522:../lib/fat.c  ****             if((cluster_num = fat_get_next_cluster(fs, cluster_num)) != 0)
1523:../lib/fat.c  ****             {
1524:../lib/fat.c  ****                 cluster_offset = 0;
1525:../lib/fat.c  ****                 continue;
1526:../lib/fat.c  ****             }
1527:../lib/fat.c  **** 
1528:../lib/fat.c  ****             /* we are at the end of the cluster chain */
1529:../lib/fat.c  ****             if(!arg.finished)
1530:../lib/fat.c  ****             {
1531:../lib/fat.c  ****                 /* directory entry not found, reset directory handle */
1532:../lib/fat.c  ****                 fat_reset_dir(dd);
1533:../lib/fat.c  ****                 return 0;
1534:../lib/fat.c  ****             }
1535:../lib/fat.c  ****             else
1536:../lib/fat.c  ****             {
1537:../lib/fat.c  ****                 /* The current execution of the function has been successful,
1538:../lib/fat.c  ****                  * so we can not signal an end of the directory listing to
1539:../lib/fat.c  ****                  * the caller, but must wait for the next call. So we keep an
1540:../lib/fat.c  ****                  * invalid cluster offset to mark this directory handle's
1541:../lib/fat.c  ****                  * traversal as finished.
1542:../lib/fat.c  ****                  */
1543:../lib/fat.c  ****             }
1544:../lib/fat.c  **** 
1545:../lib/fat.c  ****             break;
1546:../lib/fat.c  ****         }
1547:../lib/fat.c  ****     }
1548:../lib/fat.c  **** 
1549:../lib/fat.c  ****     dd->entry_cluster = cluster_num;
1550:../lib/fat.c  ****     dd->entry_offset = cluster_offset;
1551:../lib/fat.c  **** 
1552:../lib/fat.c  ****     return arg.finished;
1553:../lib/fat.c  **** }
1554:../lib/fat.c  **** 
1555:../lib/fat.c  **** /**
1556:../lib/fat.c  ****  * \ingroup fat_dir
1557:../lib/fat.c  ****  * Resets a directory handle.
1558:../lib/fat.c  ****  *
1559:../lib/fat.c  ****  * Resets the directory handle such that reading restarts
1560:../lib/fat.c  ****  * with the first directory entry.
1561:../lib/fat.c  ****  *
1562:../lib/fat.c  ****  * \param[in] dd The directory handle to reset.
1563:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
1564:../lib/fat.c  ****  * \see fat_read_dir
1565:../lib/fat.c  ****  */
1566:../lib/fat.c  **** uint8_t fat_reset_dir(struct fat_dir_struct* dd)
1567:../lib/fat.c  **** {
1568:../lib/fat.c  ****     if(!dd)
1569:../lib/fat.c  ****         return 0;
1570:../lib/fat.c  **** 
1571:../lib/fat.c  ****     dd->entry_cluster = dd->dir_entry.cluster;
1572:../lib/fat.c  ****     dd->entry_offset = 0;
1573:../lib/fat.c  ****     return 1;
1574:../lib/fat.c  **** }
1575:../lib/fat.c  **** 
1576:../lib/fat.c  **** /**
1577:../lib/fat.c  ****  * \ingroup fat_fs
1578:../lib/fat.c  ****  * Callback function for reading a directory entry.
1579:../lib/fat.c  ****  *
1580:../lib/fat.c  ****  * Interprets a raw directory entry and puts the contained
1581:../lib/fat.c  ****  * information into a fat_dir_entry_struct structure.
1582:../lib/fat.c  ****  * 
1583:../lib/fat.c  ****  * For a single file there may exist multiple directory
1584:../lib/fat.c  ****  * entries. All except the last one are lfn entries, which
1585:../lib/fat.c  ****  * contain parts of the long filename. The last directory
1586:../lib/fat.c  ****  * entry is a traditional 8.3 style one. It contains all
1587:../lib/fat.c  ****  * other information like size, cluster, date and time.
1588:../lib/fat.c  ****  * 
1589:../lib/fat.c  ****  * \param[in] buffer A pointer to 32 bytes of raw data.
1590:../lib/fat.c  ****  * \param[in] offset The absolute offset of the raw data.
1591:../lib/fat.c  ****  * \param[in,out] p An argument structure controlling operation.
1592:../lib/fat.c  ****  * \returns 0 on failure or completion, 1 if reading has
1593:../lib/fat.c  ****  *          to be continued
1594:../lib/fat.c  ****  */
1595:../lib/fat.c  **** uint8_t fat_dir_entry_read_callback(uint8_t* buffer, offset_t offset, void* p)
1596:../lib/fat.c  **** {
1597:../lib/fat.c  ****     struct fat_read_dir_callback_arg* arg = p;
1598:../lib/fat.c  ****     struct fat_dir_entry_struct* dir_entry = arg->dir_entry;
1599:../lib/fat.c  **** 
1600:../lib/fat.c  ****     arg->bytes_read += 32;
1601:../lib/fat.c  **** 
1602:../lib/fat.c  ****     /* skip deleted or empty entries */
1603:../lib/fat.c  ****     if(buffer[0] == FAT_DIRENTRY_DELETED || !buffer[0])
1604:../lib/fat.c  ****     {
1605:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1606:../lib/fat.c  ****         arg->checksum = 0;
1607:../lib/fat.c  **** #endif
1608:../lib/fat.c  ****         return 1;
1609:../lib/fat.c  ****     }
1610:../lib/fat.c  **** 
1611:../lib/fat.c  **** #if !FAT_LFN_SUPPORT
1612:../lib/fat.c  ****     /* skip lfn entries */
1613:../lib/fat.c  ****     if(buffer[11] == 0x0f)
1614:../lib/fat.c  ****         return 1;
1615:../lib/fat.c  **** #endif
1616:../lib/fat.c  **** 
1617:../lib/fat.c  ****     char* long_name = dir_entry->long_name;
1618:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1619:../lib/fat.c  ****     if(buffer[11] == 0x0f)
1620:../lib/fat.c  ****     {
1621:../lib/fat.c  ****         /* checksum validation */
1622:../lib/fat.c  ****         if(arg->checksum == 0 || arg->checksum != buffer[13])
1623:../lib/fat.c  ****         {
1624:../lib/fat.c  ****             /* reset directory entry */
1625:../lib/fat.c  ****             memset(dir_entry, 0, sizeof(*dir_entry));
1626:../lib/fat.c  **** 
1627:../lib/fat.c  ****             arg->checksum = buffer[13];
1628:../lib/fat.c  ****             dir_entry->entry_offset = offset;
1629:../lib/fat.c  ****         }
1630:../lib/fat.c  **** 
1631:../lib/fat.c  ****         /* lfn supports unicode, but we do not, for now.
1632:../lib/fat.c  ****          * So we assume pure ascii and read only every
1633:../lib/fat.c  ****          * second byte.
1634:../lib/fat.c  ****          */
1635:../lib/fat.c  ****         uint16_t char_offset = ((buffer[0] & 0x3f) - 1) * 13;
1636:../lib/fat.c  ****         const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
1637:../lib/fat.c  ****         for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
1638:../lib/fat.c  ****             long_name[char_offset + i] = buffer[char_mapping[i]];
1639:../lib/fat.c  **** 
1640:../lib/fat.c  ****         return 1;
1641:../lib/fat.c  ****     }
1642:../lib/fat.c  ****     else
1643:../lib/fat.c  **** #endif
1644:../lib/fat.c  ****     {
1645:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1646:../lib/fat.c  ****         /* if we do not have a long name or the previous lfn does not match, take the 8.3 name */
1647:../lib/fat.c  ****         if(long_name[0] == '\0' || arg->checksum != fat_calc_83_checksum(buffer))
1648:../lib/fat.c  **** #endif
1649:../lib/fat.c  ****         {
1650:../lib/fat.c  ****             /* reset directory entry */
1651:../lib/fat.c  ****             memset(dir_entry, 0, sizeof(*dir_entry));
1652:../lib/fat.c  ****             dir_entry->entry_offset = offset;
1653:../lib/fat.c  **** 
1654:../lib/fat.c  ****             uint8_t i;
1655:../lib/fat.c  ****             for(i = 0; i < 8; ++i)
1656:../lib/fat.c  ****             {
1657:../lib/fat.c  ****                 if(buffer[i] == ' ')
1658:../lib/fat.c  ****                     break;
1659:../lib/fat.c  ****                 long_name[i] = buffer[i];
1660:../lib/fat.c  **** 
1661:../lib/fat.c  ****                 /* Windows NT and later versions do not store lfn entries
1662:../lib/fat.c  ****                  * for 8.3 names which have a lowercase basename, extension
1663:../lib/fat.c  ****                  * or both when everything else is uppercase. They use two
1664:../lib/fat.c  ****                  * extra bits to signal a lowercase basename or extension.
1665:../lib/fat.c  ****                  */
1666:../lib/fat.c  ****                 if((buffer[12] & 0x08) && buffer[i] >= 'A' && buffer[i] <= 'Z')
1667:../lib/fat.c  ****                     long_name[i] += 'a' - 'A';
1668:../lib/fat.c  ****             }
1669:../lib/fat.c  ****             if(long_name[0] == 0x05)
1670:../lib/fat.c  ****                 long_name[0] = (char) FAT_DIRENTRY_DELETED;
1671:../lib/fat.c  **** 
1672:../lib/fat.c  ****             if(buffer[8] != ' ')
1673:../lib/fat.c  ****             {
1674:../lib/fat.c  ****                 long_name[i++] = '.';
1675:../lib/fat.c  **** 
1676:../lib/fat.c  ****                 uint8_t j = 8;
1677:../lib/fat.c  ****                 for(; j < 11; ++j)
1678:../lib/fat.c  ****                 {
1679:../lib/fat.c  ****                     if(buffer[j] == ' ')
1680:../lib/fat.c  ****                         break;
1681:../lib/fat.c  ****                     long_name[i] = buffer[j];
1682:../lib/fat.c  **** 
1683:../lib/fat.c  ****                     /* See above for the lowercase 8.3 name handling of
1684:../lib/fat.c  ****                      * Windows NT and later.
1685:../lib/fat.c  ****                      */
1686:../lib/fat.c  ****                     if((buffer[12] & 0x10) && buffer[j] >= 'A' && buffer[j] <= 'Z')
1687:../lib/fat.c  ****                         long_name[i] += 'a' - 'A';
1688:../lib/fat.c  **** 
1689:../lib/fat.c  ****                     ++i;
1690:../lib/fat.c  ****                 }
1691:../lib/fat.c  ****             } 
1692:../lib/fat.c  **** 
1693:../lib/fat.c  ****             long_name[i] = '\0';
1694:../lib/fat.c  ****         }
1695:../lib/fat.c  ****         
1696:../lib/fat.c  ****         /* extract properties of file and store them within the structure */
1697:../lib/fat.c  ****         dir_entry->attributes = buffer[11];
1698:../lib/fat.c  ****         dir_entry->cluster = read16(&buffer[26]);
1699:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
1700:../lib/fat.c  ****         dir_entry->cluster |= ((cluster_t) read16(&buffer[20])) << 16;
1701:../lib/fat.c  **** #endif
1702:../lib/fat.c  ****         dir_entry->file_size = read32(&buffer[28]);
1703:../lib/fat.c  **** 
1704:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
1705:../lib/fat.c  ****         dir_entry->modification_time = read16(&buffer[22]);
1706:../lib/fat.c  ****         dir_entry->modification_date = read16(&buffer[24]);
1707:../lib/fat.c  **** #endif
1708:../lib/fat.c  **** 
1709:../lib/fat.c  ****         arg->finished = 1;
1710:../lib/fat.c  ****         return 0;
1711:../lib/fat.c  ****     }
1712:../lib/fat.c  **** }
1713:../lib/fat.c  **** 
1714:../lib/fat.c  **** #if DOXYGEN || FAT_LFN_SUPPORT
1715:../lib/fat.c  **** /**
1716:../lib/fat.c  ****  * \ingroup fat_fs
1717:../lib/fat.c  ****  * Calculates the checksum for 8.3 names used within the
1718:../lib/fat.c  ****  * corresponding lfn directory entries.
1719:../lib/fat.c  ****  *
1720:../lib/fat.c  ****  * \param[in] file_name_83 The 11-byte file name buffer.
1721:../lib/fat.c  ****  * \returns The checksum of the given file name.
1722:../lib/fat.c  ****  */
1723:../lib/fat.c  **** uint8_t fat_calc_83_checksum(const uint8_t* file_name_83)
1724:../lib/fat.c  **** {
  28              		.loc 1 1724 0
  29              		.cfi_startproc
  30              		@ Function supports interworking.
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              	.LVL2:
1725:../lib/fat.c  ****     uint8_t checksum = file_name_83[0];
  35              		.loc 1 1725 0
  36 0008 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
  37              	.LVL3:
1726:../lib/fat.c  ****     for(uint8_t i = 1; i < 11; ++i)
  38              		.loc 1 1726 0
  39 000c 0120A0E3 		mov	r2, #1
  40              	.LVL4:
  41              	.L3:
  42              	.LBB15:
1727:../lib/fat.c  ****         checksum = ((checksum >> 1) | (checksum << 7)) + file_name_83[i];
  43              		.loc 1 1727 0 discriminator 2
  44 0010 A310A0E1 		mov	r1, r3, lsr #1
  45 0014 833381E1 		orr	r3, r1, r3, asl #7
1726:../lib/fat.c  ****     for(uint8_t i = 1; i < 11; ++i)
  46              		.loc 1 1726 0 discriminator 2
  47 0018 012082E2 		add	r2, r2, #1
  48              		.loc 1 1727 0 discriminator 2
  49 001c 0110F0E5 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
1726:../lib/fat.c  ****     for(uint8_t i = 1; i < 11; ++i)
  50              		.loc 1 1726 0 discriminator 2
  51 0020 FF2002E2 		and	r2, r2, #255
  52              		.loc 1 1727 0 discriminator 2
  53 0024 013083E0 		add	r3, r3, r1
1726:../lib/fat.c  ****     for(uint8_t i = 1; i < 11; ++i)
  54              		.loc 1 1726 0 discriminator 2
  55 0028 0B0052E3 		cmp	r2, #11
  56              		.loc 1 1727 0 discriminator 2
  57 002c FF3003E2 		and	r3, r3, #255
  58              	.LVL5:
1726:../lib/fat.c  ****     for(uint8_t i = 1; i < 11; ++i)
  59              		.loc 1 1726 0 discriminator 2
  60 0030 F6FFFF1A 		bne	.L3
  61              	.LBE15:
1728:../lib/fat.c  **** 
1729:../lib/fat.c  ****     return checksum;
1730:../lib/fat.c  **** }
  62              		.loc 1 1730 0
  63 0034 0300A0E1 		mov	r0, r3
  64 0038 1EFF2FE1 		bx	lr
  65              		.cfi_endproc
  66              	.LFE22:
  68              		.align	2
  70              	fat_get_fs_free_32_callback:
  71              	.LFB32:
1731:../lib/fat.c  **** #endif
1732:../lib/fat.c  **** 
1733:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
1734:../lib/fat.c  **** /**
1735:../lib/fat.c  ****  * \ingroup fat_fs
1736:../lib/fat.c  ****  * Searches for space where to store a directory entry.
1737:../lib/fat.c  ****  *
1738:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
1739:../lib/fat.c  ****  * \param[in] parent The directory in which to search.
1740:../lib/fat.c  ****  * \param[in] dir_entry The directory entry for which to search space.
1741:../lib/fat.c  ****  * \returns 0 on failure, a device offset on success.
1742:../lib/fat.c  ****  */
1743:../lib/fat.c  **** offset_t fat_find_offset_for_dir_entry(struct fat_fs_struct* fs, const struct fat_dir_struct* paren
1744:../lib/fat.c  **** {
1745:../lib/fat.c  ****     if(!fs || !dir_entry)
1746:../lib/fat.c  ****         return 0;
1747:../lib/fat.c  **** 
1748:../lib/fat.c  ****     /* search for a place where to write the directory entry to disk */
1749:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1750:../lib/fat.c  ****     uint8_t free_dir_entries_needed = (strlen(dir_entry->long_name) + 12) / 13 + 1;
1751:../lib/fat.c  ****     uint8_t free_dir_entries_found = 0;
1752:../lib/fat.c  **** #endif
1753:../lib/fat.c  ****     cluster_t cluster_num = parent->dir_entry.cluster;
1754:../lib/fat.c  ****     offset_t dir_entry_offset = 0;
1755:../lib/fat.c  ****     offset_t offset = 0;
1756:../lib/fat.c  ****     offset_t offset_to = 0;
1757:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
1758:../lib/fat.c  ****     uint8_t is_fat32 = (fs->partition->type == PARTITION_TYPE_FAT32);
1759:../lib/fat.c  **** #endif
1760:../lib/fat.c  **** 
1761:../lib/fat.c  ****     if(cluster_num == 0)
1762:../lib/fat.c  ****     {
1763:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
1764:../lib/fat.c  ****         if(is_fat32)
1765:../lib/fat.c  ****         {
1766:../lib/fat.c  ****             cluster_num = fs->header.root_dir_cluster;
1767:../lib/fat.c  ****         }
1768:../lib/fat.c  ****         else
1769:../lib/fat.c  **** #endif
1770:../lib/fat.c  ****         {
1771:../lib/fat.c  ****             /* we read/write from the root directory entry */
1772:../lib/fat.c  ****             offset = fs->header.root_dir_offset;
1773:../lib/fat.c  ****             offset_to = fs->header.cluster_zero_offset;
1774:../lib/fat.c  ****             dir_entry_offset = offset;
1775:../lib/fat.c  ****         }
1776:../lib/fat.c  ****     }
1777:../lib/fat.c  ****     
1778:../lib/fat.c  ****     while(1)
1779:../lib/fat.c  ****     {
1780:../lib/fat.c  ****         if(offset == offset_to)
1781:../lib/fat.c  ****         {
1782:../lib/fat.c  ****             if(cluster_num == 0)
1783:../lib/fat.c  ****                 /* We iterated through the whole root directory and
1784:../lib/fat.c  ****                  * could not find enough space for the directory entry.
1785:../lib/fat.c  ****                  */
1786:../lib/fat.c  ****                 return 0;
1787:../lib/fat.c  **** 
1788:../lib/fat.c  ****             if(offset)
1789:../lib/fat.c  ****             {
1790:../lib/fat.c  ****                 /* We reached a cluster boundary and have to
1791:../lib/fat.c  ****                  * switch to the next cluster.
1792:../lib/fat.c  ****                  */
1793:../lib/fat.c  **** 
1794:../lib/fat.c  ****                 cluster_t cluster_next = fat_get_next_cluster(fs, cluster_num);
1795:../lib/fat.c  ****                 if(!cluster_next)
1796:../lib/fat.c  ****                 {
1797:../lib/fat.c  ****                     cluster_next = fat_append_clusters(fs, cluster_num, 1);
1798:../lib/fat.c  ****                     if(!cluster_next)
1799:../lib/fat.c  ****                         return 0;
1800:../lib/fat.c  **** 
1801:../lib/fat.c  ****                     /* we appended a new cluster and know it is free */
1802:../lib/fat.c  ****                     dir_entry_offset = fs->header.cluster_zero_offset +
1803:../lib/fat.c  ****                                        (offset_t) (cluster_next - 2) * fs->header.cluster_size;
1804:../lib/fat.c  **** 
1805:../lib/fat.c  ****                     /* clear cluster to avoid garbage directory entries */
1806:../lib/fat.c  ****                     fat_clear_cluster(fs, cluster_next);
1807:../lib/fat.c  **** 
1808:../lib/fat.c  ****                     break;
1809:../lib/fat.c  ****                 }
1810:../lib/fat.c  ****                 cluster_num = cluster_next;
1811:../lib/fat.c  ****             }
1812:../lib/fat.c  **** 
1813:../lib/fat.c  ****             offset = fat_cluster_offset(fs, cluster_num);
1814:../lib/fat.c  ****             offset_to = offset + fs->header.cluster_size;
1815:../lib/fat.c  ****             dir_entry_offset = offset;
1816:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1817:../lib/fat.c  ****             free_dir_entries_found = 0;
1818:../lib/fat.c  **** #endif
1819:../lib/fat.c  ****         }
1820:../lib/fat.c  ****         
1821:../lib/fat.c  ****         /* read next lfn or 8.3 entry */
1822:../lib/fat.c  ****         uint8_t first_char;
1823:../lib/fat.c  ****         if(!fs->partition->device_read(offset, &first_char, sizeof(first_char)))
1824:../lib/fat.c  ****             return 0;
1825:../lib/fat.c  **** 
1826:../lib/fat.c  ****         /* check if we found a free directory entry */
1827:../lib/fat.c  ****         if(first_char == FAT_DIRENTRY_DELETED || !first_char)
1828:../lib/fat.c  ****         {
1829:../lib/fat.c  ****             /* check if we have the needed number of available entries */
1830:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1831:../lib/fat.c  ****             ++free_dir_entries_found;
1832:../lib/fat.c  ****             if(free_dir_entries_found >= free_dir_entries_needed)
1833:../lib/fat.c  **** #endif
1834:../lib/fat.c  ****                 break;
1835:../lib/fat.c  **** 
1836:../lib/fat.c  ****             offset += 32;
1837:../lib/fat.c  ****         }
1838:../lib/fat.c  ****         else
1839:../lib/fat.c  ****         {
1840:../lib/fat.c  ****             offset += 32;
1841:../lib/fat.c  ****             dir_entry_offset = offset;
1842:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1843:../lib/fat.c  ****             free_dir_entries_found = 0;
1844:../lib/fat.c  **** #endif
1845:../lib/fat.c  ****         }
1846:../lib/fat.c  ****     }
1847:../lib/fat.c  **** 
1848:../lib/fat.c  ****     return dir_entry_offset;
1849:../lib/fat.c  **** }
1850:../lib/fat.c  **** #endif
1851:../lib/fat.c  **** 
1852:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
1853:../lib/fat.c  **** /**
1854:../lib/fat.c  ****  * \ingroup fat_fs
1855:../lib/fat.c  ****  * Writes a directory entry to disk.
1856:../lib/fat.c  ****  *
1857:../lib/fat.c  ****  * \note The file name is not checked for invalid characters.
1858:../lib/fat.c  ****  *
1859:../lib/fat.c  ****  * \note The generation of the short 8.3 file name is quite
1860:../lib/fat.c  ****  * simple. The first eight characters are used for the filename.
1861:../lib/fat.c  ****  * The extension, if any, is made up of the first three characters
1862:../lib/fat.c  ****  * following the last dot within the long filename. If the
1863:../lib/fat.c  ****  * filename (without the extension) is longer than eight characters,
1864:../lib/fat.c  ****  * the lower byte of the cluster number replaces the last two
1865:../lib/fat.c  ****  * characters to avoid name clashes. In any other case, it is your
1866:../lib/fat.c  ****  * responsibility to avoid name clashes.
1867:../lib/fat.c  ****  *
1868:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
1869:../lib/fat.c  ****  * \param[in] dir_entry The directory entry to write.
1870:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
1871:../lib/fat.c  ****  */
1872:../lib/fat.c  **** uint8_t fat_write_dir_entry(const struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry)
1873:../lib/fat.c  **** {
1874:../lib/fat.c  ****     if(!fs || !dir_entry)
1875:../lib/fat.c  ****         return 0;
1876:../lib/fat.c  ****     
1877:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
1878:../lib/fat.c  ****     {
1879:../lib/fat.c  ****         uint16_t year;
1880:../lib/fat.c  ****         uint8_t month;
1881:../lib/fat.c  ****         uint8_t day;
1882:../lib/fat.c  ****         uint8_t hour;
1883:../lib/fat.c  ****         uint8_t min;
1884:../lib/fat.c  ****         uint8_t sec;
1885:../lib/fat.c  **** 
1886:../lib/fat.c  ****         fat_get_datetime(&year, &month, &day, &hour, &min, &sec);
1887:../lib/fat.c  ****         fat_set_file_modification_date(dir_entry, year, month, day);
1888:../lib/fat.c  ****         fat_set_file_modification_time(dir_entry, hour, min, sec);
1889:../lib/fat.c  ****     }
1890:../lib/fat.c  **** #endif
1891:../lib/fat.c  **** 
1892:../lib/fat.c  ****     device_write_t device_write = fs->partition->device_write;
1893:../lib/fat.c  ****     offset_t offset = dir_entry->entry_offset;
1894:../lib/fat.c  ****     const char* name = dir_entry->long_name;
1895:../lib/fat.c  ****     uint8_t name_len = strlen(name);
1896:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1897:../lib/fat.c  ****     uint8_t lfn_entry_count = (name_len + 12) / 13;
1898:../lib/fat.c  **** #endif
1899:../lib/fat.c  ****     uint8_t buffer[32];
1900:../lib/fat.c  **** 
1901:../lib/fat.c  ****     /* write 8.3 entry */
1902:../lib/fat.c  **** 
1903:../lib/fat.c  ****     /* generate 8.3 file name */
1904:../lib/fat.c  ****     memset(&buffer[0], ' ', 11);
1905:../lib/fat.c  ****     char* name_ext = strrchr(name, '.');
1906:../lib/fat.c  ****     if(name_ext && *++name_ext)
1907:../lib/fat.c  ****     {
1908:../lib/fat.c  ****         uint8_t name_ext_len = strlen(name_ext);
1909:../lib/fat.c  ****         name_len -= name_ext_len + 1;
1910:../lib/fat.c  **** 
1911:../lib/fat.c  ****         if(name_ext_len > 3)
1912:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1913:../lib/fat.c  ****             name_ext_len = 3;
1914:../lib/fat.c  **** #else
1915:../lib/fat.c  ****             return 0;
1916:../lib/fat.c  **** #endif
1917:../lib/fat.c  ****         
1918:../lib/fat.c  ****         memcpy(&buffer[8], name_ext, name_ext_len);
1919:../lib/fat.c  ****     }
1920:../lib/fat.c  ****     
1921:../lib/fat.c  ****     if(name_len <= 8)
1922:../lib/fat.c  ****     {
1923:../lib/fat.c  ****         memcpy(buffer, name, name_len);
1924:../lib/fat.c  **** 
1925:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1926:../lib/fat.c  ****         /* For now, we create lfn entries for all files,
1927:../lib/fat.c  ****          * except the "." and ".." directory references.
1928:../lib/fat.c  ****          * This is to avoid difficulties with capitalization,
1929:../lib/fat.c  ****          * as 8.3 filenames allow uppercase letters only.
1930:../lib/fat.c  ****          *
1931:../lib/fat.c  ****          * Theoretically it would be possible to leave
1932:../lib/fat.c  ****          * the 8.3 entry alone if the basename and the
1933:../lib/fat.c  ****          * extension have no mixed capitalization.
1934:../lib/fat.c  ****          */
1935:../lib/fat.c  ****         if(name[0] == '.' &&
1936:../lib/fat.c  ****            ((name[1] == '.' && name[2] == '\0') ||
1937:../lib/fat.c  ****             name[1] == '\0')
1938:../lib/fat.c  ****           )
1939:../lib/fat.c  ****             lfn_entry_count = 0;
1940:../lib/fat.c  **** #endif
1941:../lib/fat.c  ****     }
1942:../lib/fat.c  ****     else
1943:../lib/fat.c  ****     {
1944:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1945:../lib/fat.c  ****         memcpy(buffer, name, 8);
1946:../lib/fat.c  **** 
1947:../lib/fat.c  ****         /* Minimize 8.3 name clashes by appending
1948:../lib/fat.c  ****          * the lower byte of the cluster number.
1949:../lib/fat.c  ****          */
1950:../lib/fat.c  ****         uint8_t num = dir_entry->cluster & 0xff;
1951:../lib/fat.c  **** 
1952:../lib/fat.c  ****         buffer[6] = (num < 0xa0) ? ('0' + (num >> 4)) : ('a' + (num >> 4));
1953:../lib/fat.c  ****         num &= 0x0f;
1954:../lib/fat.c  ****         buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
1955:../lib/fat.c  **** #else
1956:../lib/fat.c  ****         return 0;
1957:../lib/fat.c  **** #endif
1958:../lib/fat.c  ****     }
1959:../lib/fat.c  ****     if(buffer[0] == FAT_DIRENTRY_DELETED)
1960:../lib/fat.c  ****         buffer[0] = 0x05;
1961:../lib/fat.c  **** 
1962:../lib/fat.c  ****     /* fill directory entry buffer */
1963:../lib/fat.c  ****     memset(&buffer[11], 0, sizeof(buffer) - 11);
1964:../lib/fat.c  ****     buffer[0x0b] = dir_entry->attributes;
1965:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
1966:../lib/fat.c  ****     write16(&buffer[0x16], dir_entry->modification_time);
1967:../lib/fat.c  ****     write16(&buffer[0x18], dir_entry->modification_date);
1968:../lib/fat.c  **** #endif
1969:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
1970:../lib/fat.c  ****     write16(&buffer[0x14], (uint16_t) (dir_entry->cluster >> 16));
1971:../lib/fat.c  **** #endif
1972:../lib/fat.c  ****     write16(&buffer[0x1a], dir_entry->cluster);
1973:../lib/fat.c  ****     write32(&buffer[0x1c], dir_entry->file_size);
1974:../lib/fat.c  **** 
1975:../lib/fat.c  ****     /* write to disk */
1976:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1977:../lib/fat.c  ****     if(!device_write(offset + (uint16_t) lfn_entry_count * 32, buffer, sizeof(buffer)))
1978:../lib/fat.c  **** #else
1979:../lib/fat.c  ****     if(!device_write(offset, buffer, sizeof(buffer)))
1980:../lib/fat.c  **** #endif
1981:../lib/fat.c  ****         return 0;
1982:../lib/fat.c  ****     
1983:../lib/fat.c  **** #if FAT_LFN_SUPPORT
1984:../lib/fat.c  ****     /* calculate checksum of 8.3 name */
1985:../lib/fat.c  ****     uint8_t checksum = fat_calc_83_checksum(buffer);
1986:../lib/fat.c  ****     
1987:../lib/fat.c  ****     /* write lfn entries */
1988:../lib/fat.c  ****     for(uint8_t lfn_entry = lfn_entry_count; lfn_entry > 0; --lfn_entry)
1989:../lib/fat.c  ****     {
1990:../lib/fat.c  ****         memset(buffer, 0xff, sizeof(buffer));
1991:../lib/fat.c  ****         
1992:../lib/fat.c  ****         /* set file name */
1993:../lib/fat.c  ****         const char* long_name_curr = name + (lfn_entry - 1) * 13;
1994:../lib/fat.c  ****         uint8_t i = 1;
1995:../lib/fat.c  ****         while(i < 0x1f)
1996:../lib/fat.c  ****         {
1997:../lib/fat.c  ****             buffer[i++] = *long_name_curr;
1998:../lib/fat.c  ****             buffer[i++] = 0;
1999:../lib/fat.c  **** 
2000:../lib/fat.c  ****             switch(i)
2001:../lib/fat.c  ****             {
2002:../lib/fat.c  ****                 case 0x0b:
2003:../lib/fat.c  ****                     i = 0x0e;
2004:../lib/fat.c  ****                     break;
2005:../lib/fat.c  ****                 case 0x1a:
2006:../lib/fat.c  ****                     i = 0x1c;
2007:../lib/fat.c  ****                     break;
2008:../lib/fat.c  ****             }
2009:../lib/fat.c  **** 
2010:../lib/fat.c  ****             if(!*long_name_curr++)
2011:../lib/fat.c  ****                 break;
2012:../lib/fat.c  ****         }
2013:../lib/fat.c  ****         
2014:../lib/fat.c  ****         /* set index of lfn entry */
2015:../lib/fat.c  ****         buffer[0x00] = lfn_entry;
2016:../lib/fat.c  ****         if(lfn_entry == lfn_entry_count)
2017:../lib/fat.c  ****             buffer[0x00] |= FAT_DIRENTRY_LFNLAST;
2018:../lib/fat.c  **** 
2019:../lib/fat.c  ****         /* mark as lfn entry */
2020:../lib/fat.c  ****         buffer[0x0b] = 0x0f;
2021:../lib/fat.c  **** 
2022:../lib/fat.c  ****         /* set 8.3 checksum */
2023:../lib/fat.c  ****         buffer[0x0d] = checksum;
2024:../lib/fat.c  **** 
2025:../lib/fat.c  ****         /* clear reserved bytes */
2026:../lib/fat.c  ****         buffer[0x0c] = 0;
2027:../lib/fat.c  ****         buffer[0x1a] = 0;
2028:../lib/fat.c  ****         buffer[0x1b] = 0;
2029:../lib/fat.c  **** 
2030:../lib/fat.c  ****         /* write entry */
2031:../lib/fat.c  ****         device_write(offset, buffer, sizeof(buffer));
2032:../lib/fat.c  ****     
2033:../lib/fat.c  ****         offset += sizeof(buffer);
2034:../lib/fat.c  ****     }
2035:../lib/fat.c  **** #endif
2036:../lib/fat.c  ****     
2037:../lib/fat.c  ****     return 1;
2038:../lib/fat.c  **** }
2039:../lib/fat.c  **** #endif
2040:../lib/fat.c  **** 
2041:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
2042:../lib/fat.c  **** /**
2043:../lib/fat.c  ****  * \ingroup fat_file
2044:../lib/fat.c  ****  * Creates a file.
2045:../lib/fat.c  ****  *
2046:../lib/fat.c  ****  * Creates a file and obtains the directory entry of the
2047:../lib/fat.c  ****  * new file. If the file to create already exists, the
2048:../lib/fat.c  ****  * directory entry of the existing file will be returned
2049:../lib/fat.c  ****  * within the dir_entry parameter.
2050:../lib/fat.c  ****  *
2051:../lib/fat.c  ****  * \note The file name is not checked for invalid characters.
2052:../lib/fat.c  ****  *
2053:../lib/fat.c  ****  * \note The generation of the short 8.3 file name is quite
2054:../lib/fat.c  ****  * simple. The first eight characters are used for the filename.
2055:../lib/fat.c  ****  * The extension, if any, is made up of the first three characters
2056:../lib/fat.c  ****  * following the last dot within the long filename. If the
2057:../lib/fat.c  ****  * filename (without the extension) is longer than eight characters,
2058:../lib/fat.c  ****  * the lower byte of the cluster number replaces the last two
2059:../lib/fat.c  ****  * characters to avoid name clashes. In any other case, it is your
2060:../lib/fat.c  ****  * responsibility to avoid name clashes.
2061:../lib/fat.c  ****  *
2062:../lib/fat.c  ****  * \param[in] parent The handle of the directory in which to create the file.
2063:../lib/fat.c  ****  * \param[in] file The name of the file to create.
2064:../lib/fat.c  ****  * \param[out] dir_entry The directory entry to fill for the new (or existing) file.
2065:../lib/fat.c  ****  * \returns 0 on failure, 1 on success, 2 if the file already existed.
2066:../lib/fat.c  ****  * \see fat_delete_file
2067:../lib/fat.c  ****  */
2068:../lib/fat.c  **** uint8_t fat_create_file(struct fat_dir_struct* parent, const char* file, struct fat_dir_entry_struc
2069:../lib/fat.c  **** {
2070:../lib/fat.c  ****     if(!parent || !file || !file[0] || !dir_entry)
2071:../lib/fat.c  ****         return 0;
2072:../lib/fat.c  **** 
2073:../lib/fat.c  ****     /* check if the file already exists */
2074:../lib/fat.c  ****     while(1)
2075:../lib/fat.c  ****     {
2076:../lib/fat.c  ****         if(!fat_read_dir(parent, dir_entry))
2077:../lib/fat.c  ****             break;
2078:../lib/fat.c  **** 
2079:../lib/fat.c  ****         if(strcmp(file, dir_entry->long_name) == 0)
2080:../lib/fat.c  ****         {
2081:../lib/fat.c  ****             fat_reset_dir(parent);
2082:../lib/fat.c  ****             return 2;
2083:../lib/fat.c  ****         }
2084:../lib/fat.c  ****     }
2085:../lib/fat.c  **** 
2086:../lib/fat.c  ****     struct fat_fs_struct* fs = parent->fs;
2087:../lib/fat.c  **** 
2088:../lib/fat.c  ****     /* prepare directory entry with values already known */
2089:../lib/fat.c  ****     memset(dir_entry, 0, sizeof(*dir_entry));
2090:../lib/fat.c  ****     strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
2091:../lib/fat.c  **** 
2092:../lib/fat.c  ****     /* find place where to store directory entry */
2093:../lib/fat.c  ****     if(!(dir_entry->entry_offset = fat_find_offset_for_dir_entry(fs, parent, dir_entry)))
2094:../lib/fat.c  ****         return 0;
2095:../lib/fat.c  ****     
2096:../lib/fat.c  ****     /* write directory entry to disk */
2097:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
2098:../lib/fat.c  ****         return 0;
2099:../lib/fat.c  ****     
2100:../lib/fat.c  ****     return 1;
2101:../lib/fat.c  **** }
2102:../lib/fat.c  **** #endif
2103:../lib/fat.c  **** 
2104:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
2105:../lib/fat.c  **** /**
2106:../lib/fat.c  ****  * \ingroup fat_file
2107:../lib/fat.c  ****  * Deletes a file or directory.
2108:../lib/fat.c  ****  *
2109:../lib/fat.c  ****  * If a directory is deleted without first deleting its
2110:../lib/fat.c  ****  * subdirectories and files, disk space occupied by these
2111:../lib/fat.c  ****  * files will get wasted as there is no chance to release
2112:../lib/fat.c  ****  * it and mark it as free.
2113:../lib/fat.c  ****  * 
2114:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
2115:../lib/fat.c  ****  * \param[in] dir_entry The directory entry of the file to delete.
2116:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
2117:../lib/fat.c  ****  * \see fat_create_file
2118:../lib/fat.c  ****  */
2119:../lib/fat.c  **** uint8_t fat_delete_file(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry)
2120:../lib/fat.c  **** {
2121:../lib/fat.c  ****     if(!fs || !dir_entry)
2122:../lib/fat.c  ****         return 0;
2123:../lib/fat.c  **** 
2124:../lib/fat.c  ****     /* get offset of the file's directory entry */
2125:../lib/fat.c  ****     offset_t dir_entry_offset = dir_entry->entry_offset;
2126:../lib/fat.c  ****     if(!dir_entry_offset)
2127:../lib/fat.c  ****         return 0;
2128:../lib/fat.c  **** 
2129:../lib/fat.c  **** #if FAT_LFN_SUPPORT
2130:../lib/fat.c  ****     uint8_t buffer[12];
2131:../lib/fat.c  ****     while(1)
2132:../lib/fat.c  ****     {
2133:../lib/fat.c  ****         /* read directory entry */
2134:../lib/fat.c  ****         if(!fs->partition->device_read(dir_entry_offset, buffer, sizeof(buffer)))
2135:../lib/fat.c  ****             return 0;
2136:../lib/fat.c  ****         
2137:../lib/fat.c  ****         /* mark the directory entry as deleted */
2138:../lib/fat.c  ****         buffer[0] = FAT_DIRENTRY_DELETED;
2139:../lib/fat.c  ****         
2140:../lib/fat.c  ****         /* write back entry */
2141:../lib/fat.c  ****         if(!fs->partition->device_write(dir_entry_offset, buffer, sizeof(buffer)))
2142:../lib/fat.c  ****             return 0;
2143:../lib/fat.c  **** 
2144:../lib/fat.c  ****         /* check if we deleted the whole entry */
2145:../lib/fat.c  ****         if(buffer[11] != 0x0f)
2146:../lib/fat.c  ****             break;
2147:../lib/fat.c  **** 
2148:../lib/fat.c  ****         dir_entry_offset += 32;
2149:../lib/fat.c  ****     }
2150:../lib/fat.c  **** #else
2151:../lib/fat.c  ****     /* mark the directory entry as deleted */
2152:../lib/fat.c  ****     uint8_t first_char = FAT_DIRENTRY_DELETED;
2153:../lib/fat.c  ****     if(!fs->partition->device_write(dir_entry_offset, &first_char, 1))
2154:../lib/fat.c  ****         return 0;
2155:../lib/fat.c  **** #endif
2156:../lib/fat.c  **** 
2157:../lib/fat.c  ****     /* We deleted the directory entry. The next thing to do is
2158:../lib/fat.c  ****      * marking all occupied clusters as free.
2159:../lib/fat.c  ****      */
2160:../lib/fat.c  ****     return (dir_entry->cluster == 0 || fat_free_clusters(fs, dir_entry->cluster));
2161:../lib/fat.c  **** }
2162:../lib/fat.c  **** #endif
2163:../lib/fat.c  **** 
2164:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
2165:../lib/fat.c  **** /**
2166:../lib/fat.c  ****  * \ingroup fat_file
2167:../lib/fat.c  ****  * Moves or renames a file.
2168:../lib/fat.c  ****  *
2169:../lib/fat.c  ****  * Changes a file's name, optionally moving it into another
2170:../lib/fat.c  ****  * directory as well. Before calling this function, the
2171:../lib/fat.c  ****  * target file name must not exist. Moving a file to a
2172:../lib/fat.c  ****  * different filesystem (i.e. \a parent_new doesn't lie on
2173:../lib/fat.c  ****  * \a fs) is not supported.
2174:../lib/fat.c  ****  * 
2175:../lib/fat.c  ****  * After successfully renaming (and moving) the file, the
2176:../lib/fat.c  ****  * given directory entry is updated such that it points to
2177:../lib/fat.c  ****  * the file's new location.
2178:../lib/fat.c  ****  *
2179:../lib/fat.c  ****  * \note The notes which apply to fat_create_file() also
2180:../lib/fat.c  ****  * apply to this function.
2181:../lib/fat.c  ****  *
2182:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
2183:../lib/fat.c  ****  * \param[in,out] dir_entry The directory entry of the file to move.
2184:../lib/fat.c  ****  * \param[in] parent_new The handle of the new parent directory of the file.
2185:../lib/fat.c  ****  * \param[in] file_new The file's new name.
2186:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
2187:../lib/fat.c  ****  * \see fat_create_file, fat_delete_file, fat_move_dir
2188:../lib/fat.c  ****  */
2189:../lib/fat.c  **** uint8_t fat_move_file(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry, struct fat_
2190:../lib/fat.c  **** {
2191:../lib/fat.c  ****     if(!fs || !dir_entry || !parent_new || (file_new && !file_new[0]))
2192:../lib/fat.c  ****         return 0;
2193:../lib/fat.c  ****     if(fs != parent_new->fs)
2194:../lib/fat.c  ****         return 0;
2195:../lib/fat.c  **** 
2196:../lib/fat.c  ****     /* use existing file name if none has been specified */
2197:../lib/fat.c  ****     if(!file_new)
2198:../lib/fat.c  ****         file_new = dir_entry->long_name;
2199:../lib/fat.c  **** 
2200:../lib/fat.c  ****     /* create file with new file name */
2201:../lib/fat.c  ****     struct fat_dir_entry_struct dir_entry_new;
2202:../lib/fat.c  ****     if(!fat_create_file(parent_new, file_new, &dir_entry_new))
2203:../lib/fat.c  ****         return 0;
2204:../lib/fat.c  **** 
2205:../lib/fat.c  ****     /* copy members of directory entry which do not change with rename */
2206:../lib/fat.c  ****     dir_entry_new.attributes = dir_entry->attributes;
2207:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
2208:../lib/fat.c  ****     dir_entry_new.modification_time = dir_entry->modification_time;
2209:../lib/fat.c  ****     dir_entry_new.modification_date = dir_entry->modification_date;
2210:../lib/fat.c  **** #endif
2211:../lib/fat.c  ****     dir_entry_new.cluster = dir_entry->cluster;
2212:../lib/fat.c  ****     dir_entry_new.file_size = dir_entry->file_size;
2213:../lib/fat.c  **** 
2214:../lib/fat.c  ****     /* make the new file name point to the old file's content */
2215:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, &dir_entry_new))
2216:../lib/fat.c  ****     {
2217:../lib/fat.c  ****         fat_delete_file(fs, &dir_entry_new);
2218:../lib/fat.c  ****         return 0;
2219:../lib/fat.c  ****     }
2220:../lib/fat.c  ****     
2221:../lib/fat.c  ****     /* delete the old file, but not its clusters, which have already been remapped above */
2222:../lib/fat.c  ****     dir_entry->cluster = 0;
2223:../lib/fat.c  ****     if(!fat_delete_file(fs, dir_entry))
2224:../lib/fat.c  ****         return 0;
2225:../lib/fat.c  **** 
2226:../lib/fat.c  ****     *dir_entry = dir_entry_new;
2227:../lib/fat.c  ****     return 1;
2228:../lib/fat.c  **** }
2229:../lib/fat.c  **** #endif
2230:../lib/fat.c  **** 
2231:../lib/fat.c  **** #if DOXYGEN || FAT_WRITE_SUPPORT
2232:../lib/fat.c  **** /**
2233:../lib/fat.c  ****  * \ingroup fat_dir
2234:../lib/fat.c  ****  * Creates a directory.
2235:../lib/fat.c  ****  *
2236:../lib/fat.c  ****  * Creates a directory and obtains its directory entry.
2237:../lib/fat.c  ****  * If the directory to create already exists, its
2238:../lib/fat.c  ****  * directory entry will be returned within the dir_entry
2239:../lib/fat.c  ****  * parameter.
2240:../lib/fat.c  ****  *
2241:../lib/fat.c  ****  * \note The notes which apply to fat_create_file() also
2242:../lib/fat.c  ****  * apply to this function.
2243:../lib/fat.c  ****  *
2244:../lib/fat.c  ****  * \param[in] parent The handle of the parent directory of the new directory.
2245:../lib/fat.c  ****  * \param[in] dir The name of the directory to create.
2246:../lib/fat.c  ****  * \param[out] dir_entry The directory entry to fill for the new directory.
2247:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
2248:../lib/fat.c  ****  * \see fat_delete_dir
2249:../lib/fat.c  ****  */
2250:../lib/fat.c  **** uint8_t fat_create_dir(struct fat_dir_struct* parent, const char* dir, struct fat_dir_entry_struct*
2251:../lib/fat.c  **** {
2252:../lib/fat.c  ****     if(!parent || !dir || !dir[0] || !dir_entry)
2253:../lib/fat.c  ****         return 0;
2254:../lib/fat.c  **** 
2255:../lib/fat.c  ****     /* check if the file or directory already exists */
2256:../lib/fat.c  ****     while(fat_read_dir(parent, dir_entry))
2257:../lib/fat.c  ****     {
2258:../lib/fat.c  ****         if(strcmp(dir, dir_entry->long_name) == 0)
2259:../lib/fat.c  ****         {
2260:../lib/fat.c  ****             fat_reset_dir(parent);
2261:../lib/fat.c  ****             return 0;
2262:../lib/fat.c  ****         }
2263:../lib/fat.c  ****     }
2264:../lib/fat.c  **** 
2265:../lib/fat.c  ****     struct fat_fs_struct* fs = parent->fs;
2266:../lib/fat.c  **** 
2267:../lib/fat.c  ****     /* allocate cluster which will hold directory entries */
2268:../lib/fat.c  ****     cluster_t dir_cluster = fat_append_clusters(fs, 0, 1);
2269:../lib/fat.c  ****     if(!dir_cluster)
2270:../lib/fat.c  ****         return 0;
2271:../lib/fat.c  **** 
2272:../lib/fat.c  ****     /* clear cluster to prevent bogus directory entries */
2273:../lib/fat.c  ****     fat_clear_cluster(fs, dir_cluster);
2274:../lib/fat.c  ****     
2275:../lib/fat.c  ****     memset(dir_entry, 0, sizeof(*dir_entry));
2276:../lib/fat.c  ****     dir_entry->attributes = FAT_ATTRIB_DIR;
2277:../lib/fat.c  **** 
2278:../lib/fat.c  ****     /* create "." directory self reference */
2279:../lib/fat.c  ****     dir_entry->entry_offset = fs->header.cluster_zero_offset +
2280:../lib/fat.c  ****                               (offset_t) (dir_cluster - 2) * fs->header.cluster_size;
2281:../lib/fat.c  ****     dir_entry->long_name[0] = '.';
2282:../lib/fat.c  ****     dir_entry->cluster = dir_cluster;
2283:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
2284:../lib/fat.c  ****     {
2285:../lib/fat.c  ****         fat_free_clusters(fs, dir_cluster);
2286:../lib/fat.c  ****         return 0;
2287:../lib/fat.c  ****     }
2288:../lib/fat.c  **** 
2289:../lib/fat.c  ****     /* create ".." parent directory reference */
2290:../lib/fat.c  ****     dir_entry->entry_offset += 32;
2291:../lib/fat.c  ****     dir_entry->long_name[1] = '.';
2292:../lib/fat.c  ****     dir_entry->cluster = parent->dir_entry.cluster;
2293:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
2294:../lib/fat.c  ****     {
2295:../lib/fat.c  ****         fat_free_clusters(fs, dir_cluster);
2296:../lib/fat.c  ****         return 0;
2297:../lib/fat.c  ****     }
2298:../lib/fat.c  **** 
2299:../lib/fat.c  ****     /* fill directory entry */
2300:../lib/fat.c  ****     strncpy(dir_entry->long_name, dir, sizeof(dir_entry->long_name) - 1);
2301:../lib/fat.c  ****     dir_entry->cluster = dir_cluster;
2302:../lib/fat.c  **** 
2303:../lib/fat.c  ****     /* find place where to store directory entry */
2304:../lib/fat.c  ****     if(!(dir_entry->entry_offset = fat_find_offset_for_dir_entry(fs, parent, dir_entry)))
2305:../lib/fat.c  ****     {
2306:../lib/fat.c  ****         fat_free_clusters(fs, dir_cluster);
2307:../lib/fat.c  ****         return 0;
2308:../lib/fat.c  ****     }
2309:../lib/fat.c  **** 
2310:../lib/fat.c  ****     /* write directory to disk */
2311:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
2312:../lib/fat.c  ****     {
2313:../lib/fat.c  ****         fat_free_clusters(fs, dir_cluster);
2314:../lib/fat.c  ****         return 0;
2315:../lib/fat.c  ****     }
2316:../lib/fat.c  **** 
2317:../lib/fat.c  ****     return 1;
2318:../lib/fat.c  **** }
2319:../lib/fat.c  **** #endif
2320:../lib/fat.c  **** 
2321:../lib/fat.c  **** /**
2322:../lib/fat.c  ****  * \ingroup fat_dir
2323:../lib/fat.c  ****  * Deletes a directory.
2324:../lib/fat.c  ****  *
2325:../lib/fat.c  ****  * This is just a synonym for fat_delete_file().
2326:../lib/fat.c  ****  * If a directory is deleted without first deleting its
2327:../lib/fat.c  ****  * subdirectories and files, disk space occupied by these
2328:../lib/fat.c  ****  * files will get wasted as there is no chance to release
2329:../lib/fat.c  ****  * it and mark it as free.
2330:../lib/fat.c  ****  * 
2331:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
2332:../lib/fat.c  ****  * \param[in] dir_entry The directory entry of the directory to delete.
2333:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
2334:../lib/fat.c  ****  * \see fat_create_dir
2335:../lib/fat.c  ****  */
2336:../lib/fat.c  **** #ifdef DOXYGEN
2337:../lib/fat.c  **** uint8_t fat_delete_dir(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry);
2338:../lib/fat.c  **** #endif
2339:../lib/fat.c  **** 
2340:../lib/fat.c  **** /**
2341:../lib/fat.c  ****  * \ingroup fat_dir
2342:../lib/fat.c  ****  * Moves or renames a directory.
2343:../lib/fat.c  ****  *
2344:../lib/fat.c  ****  * This is just a synonym for fat_move_file().
2345:../lib/fat.c  ****  * 
2346:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
2347:../lib/fat.c  ****  * \param[in,out] dir_entry The directory entry of the directory to move.
2348:../lib/fat.c  ****  * \param[in] parent_new The handle of the new parent directory.
2349:../lib/fat.c  ****  * \param[in] dir_new The directory's new name.
2350:../lib/fat.c  ****  * \returns 0 on failure, 1 on success.
2351:../lib/fat.c  ****  * \see fat_create_dir, fat_delete_dir, fat_move_file
2352:../lib/fat.c  ****  */
2353:../lib/fat.c  **** #ifdef DOXYGEN
2354:../lib/fat.c  **** uint8_t fat_move_dir(struct fat_fs_struct* fs, struct fat_dir_entry_struct* dir_entry, struct fat_d
2355:../lib/fat.c  **** #endif
2356:../lib/fat.c  **** 
2357:../lib/fat.c  **** #if DOXYGEN || FAT_DATETIME_SUPPORT
2358:../lib/fat.c  **** /**
2359:../lib/fat.c  ****  * \ingroup fat_file
2360:../lib/fat.c  ****  * Returns the modification date of a file.
2361:../lib/fat.c  ****  *
2362:../lib/fat.c  ****  * \param[in] dir_entry The directory entry of which to return the modification date.
2363:../lib/fat.c  ****  * \param[out] year The year the file was last modified.
2364:../lib/fat.c  ****  * \param[out] month The month the file was last modified.
2365:../lib/fat.c  ****  * \param[out] day The day the file was last modified.
2366:../lib/fat.c  ****  */
2367:../lib/fat.c  **** void fat_get_file_modification_date(const struct fat_dir_entry_struct* dir_entry, uint16_t* year, u
2368:../lib/fat.c  **** {
2369:../lib/fat.c  ****     if(!dir_entry)
2370:../lib/fat.c  ****         return;
2371:../lib/fat.c  **** 
2372:../lib/fat.c  ****     *year = 1980 + ((dir_entry->modification_date >> 9) & 0x7f);
2373:../lib/fat.c  ****     *month = (dir_entry->modification_date >> 5) & 0x0f;
2374:../lib/fat.c  ****     *day = (dir_entry->modification_date >> 0) & 0x1f;
2375:../lib/fat.c  **** }
2376:../lib/fat.c  **** #endif
2377:../lib/fat.c  **** 
2378:../lib/fat.c  **** #if DOXYGEN || FAT_DATETIME_SUPPORT
2379:../lib/fat.c  **** /**
2380:../lib/fat.c  ****  * \ingroup fat_file
2381:../lib/fat.c  ****  * Returns the modification time of a file.
2382:../lib/fat.c  ****  *
2383:../lib/fat.c  ****  * \param[in] dir_entry The directory entry of which to return the modification time.
2384:../lib/fat.c  ****  * \param[out] hour The hour the file was last modified.
2385:../lib/fat.c  ****  * \param[out] min The min the file was last modified.
2386:../lib/fat.c  ****  * \param[out] sec The sec the file was last modified.
2387:../lib/fat.c  ****  */
2388:../lib/fat.c  **** void fat_get_file_modification_time(const struct fat_dir_entry_struct* dir_entry, uint8_t* hour, ui
2389:../lib/fat.c  **** {
2390:../lib/fat.c  ****     if(!dir_entry)
2391:../lib/fat.c  ****         return;
2392:../lib/fat.c  **** 
2393:../lib/fat.c  ****     *hour = (dir_entry->modification_time >> 11) & 0x1f;
2394:../lib/fat.c  ****     *min = (dir_entry->modification_time >> 5) & 0x3f;
2395:../lib/fat.c  ****     *sec = ((dir_entry->modification_time >> 0) & 0x1f) * 2;
2396:../lib/fat.c  **** }
2397:../lib/fat.c  **** #endif
2398:../lib/fat.c  **** 
2399:../lib/fat.c  **** #if DOXYGEN || (FAT_WRITE_SUPPORT && FAT_DATETIME_SUPPORT)
2400:../lib/fat.c  **** /**
2401:../lib/fat.c  ****  * \ingroup fat_file
2402:../lib/fat.c  ****  * Sets the modification time of a date.
2403:../lib/fat.c  ****  *
2404:../lib/fat.c  ****  * \param[in] dir_entry The directory entry for which to set the modification date.
2405:../lib/fat.c  ****  * \param[in] year The year the file was last modified.
2406:../lib/fat.c  ****  * \param[in] month The month the file was last modified.
2407:../lib/fat.c  ****  * \param[in] day The day the file was last modified.
2408:../lib/fat.c  ****  */
2409:../lib/fat.c  **** void fat_set_file_modification_date(struct fat_dir_entry_struct* dir_entry, uint16_t year, uint8_t 
2410:../lib/fat.c  **** {
2411:../lib/fat.c  ****     if(!dir_entry)
2412:../lib/fat.c  ****         return;
2413:../lib/fat.c  **** 
2414:../lib/fat.c  ****     dir_entry->modification_date =
2415:../lib/fat.c  ****         ((year - 1980) << 9) |
2416:../lib/fat.c  ****         ((uint16_t) month << 5) |
2417:../lib/fat.c  ****         ((uint16_t) day << 0);
2418:../lib/fat.c  **** }
2419:../lib/fat.c  **** #endif
2420:../lib/fat.c  **** 
2421:../lib/fat.c  **** #if DOXYGEN || (FAT_WRITE_SUPPORT && FAT_DATETIME_SUPPORT)
2422:../lib/fat.c  **** /**
2423:../lib/fat.c  ****  * \ingroup fat_file
2424:../lib/fat.c  ****  * Sets the modification time of a file.
2425:../lib/fat.c  ****  *
2426:../lib/fat.c  ****  * \param[in] dir_entry The directory entry for which to set the modification time.
2427:../lib/fat.c  ****  * \param[in] hour The year the file was last modified.
2428:../lib/fat.c  ****  * \param[in] min The month the file was last modified.
2429:../lib/fat.c  ****  * \param[in] sec The day the file was last modified.
2430:../lib/fat.c  ****  */
2431:../lib/fat.c  **** void fat_set_file_modification_time(struct fat_dir_entry_struct* dir_entry, uint8_t hour, uint8_t m
2432:../lib/fat.c  **** {
2433:../lib/fat.c  ****     if(!dir_entry)
2434:../lib/fat.c  ****         return;
2435:../lib/fat.c  **** 
2436:../lib/fat.c  ****     dir_entry->modification_time =
2437:../lib/fat.c  ****         ((uint16_t) hour << 11) |
2438:../lib/fat.c  ****         ((uint16_t) min << 5) |
2439:../lib/fat.c  ****         ((uint16_t) sec >> 1) ;
2440:../lib/fat.c  **** }
2441:../lib/fat.c  **** #endif
2442:../lib/fat.c  **** 
2443:../lib/fat.c  **** /**
2444:../lib/fat.c  ****  * \ingroup fat_fs
2445:../lib/fat.c  ****  * Returns the amount of total storage capacity of the filesystem in bytes.
2446:../lib/fat.c  ****  *
2447:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
2448:../lib/fat.c  ****  * \returns 0 on failure, the filesystem size in bytes otherwise.
2449:../lib/fat.c  ****  */
2450:../lib/fat.c  **** offset_t fat_get_fs_size(const struct fat_fs_struct* fs)
2451:../lib/fat.c  **** {
2452:../lib/fat.c  ****     if(!fs)
2453:../lib/fat.c  ****         return 0;
2454:../lib/fat.c  **** 
2455:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
2456:../lib/fat.c  ****     if(fs->partition->type == PARTITION_TYPE_FAT32)
2457:../lib/fat.c  ****         return (offset_t) (fs->header.fat_size / 4 - 2) * fs->header.cluster_size;
2458:../lib/fat.c  ****     else
2459:../lib/fat.c  **** #endif
2460:../lib/fat.c  ****         return (offset_t) (fs->header.fat_size / 2 - 2) * fs->header.cluster_size;
2461:../lib/fat.c  **** }
2462:../lib/fat.c  **** 
2463:../lib/fat.c  **** /**
2464:../lib/fat.c  ****  * \ingroup fat_fs
2465:../lib/fat.c  ****  * Returns the amount of free storage capacity on the filesystem in bytes.
2466:../lib/fat.c  ****  *
2467:../lib/fat.c  ****  * \note As the FAT filesystem is cluster based, this function does not
2468:../lib/fat.c  ****  *       return continuous values but multiples of the cluster size.
2469:../lib/fat.c  ****  *
2470:../lib/fat.c  ****  * \param[in] fs The filesystem on which to operate.
2471:../lib/fat.c  ****  * \returns 0 on failure, the free filesystem space in bytes otherwise.
2472:../lib/fat.c  ****  */
2473:../lib/fat.c  **** offset_t fat_get_fs_free(const struct fat_fs_struct* fs)
2474:../lib/fat.c  **** {
2475:../lib/fat.c  ****     if(!fs)
2476:../lib/fat.c  ****         return 0;
2477:../lib/fat.c  **** 
2478:../lib/fat.c  ****     uint8_t fat[32];
2479:../lib/fat.c  ****     struct fat_usage_count_callback_arg count_arg;
2480:../lib/fat.c  ****     count_arg.cluster_count = 0;
2481:../lib/fat.c  ****     count_arg.buffer_size = sizeof(fat);
2482:../lib/fat.c  **** 
2483:../lib/fat.c  ****     offset_t fat_offset = fs->header.fat_offset;
2484:../lib/fat.c  ****     uint32_t fat_size = fs->header.fat_size;
2485:../lib/fat.c  ****     while(fat_size > 0)
2486:../lib/fat.c  ****     {
2487:../lib/fat.c  ****         uintptr_t length = UINT32_MAX - 1;
2488:../lib/fat.c  ****         if(fat_size < length)
2489:../lib/fat.c  ****             length = fat_size;
2490:../lib/fat.c  **** 
2491:../lib/fat.c  ****         if(!fs->partition->device_read_interval(fat_offset,
2492:../lib/fat.c  ****                                                 fat,
2493:../lib/fat.c  ****                                                 sizeof(fat),
2494:../lib/fat.c  ****                                                 length,
2495:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
2496:../lib/fat.c  ****                                                 (fs->partition->type == PARTITION_TYPE_FAT16) ?
2497:../lib/fat.c  ****                                                     fat_get_fs_free_16_callback :
2498:../lib/fat.c  ****                                                     fat_get_fs_free_32_callback,
2499:../lib/fat.c  **** #else
2500:../lib/fat.c  ****                                                 fat_get_fs_free_16_callback,
2501:../lib/fat.c  **** #endif
2502:../lib/fat.c  ****                                                 &count_arg
2503:../lib/fat.c  ****                                                )
2504:../lib/fat.c  ****           )
2505:../lib/fat.c  ****             return 0;
2506:../lib/fat.c  **** 
2507:../lib/fat.c  ****         fat_offset += length;
2508:../lib/fat.c  ****         fat_size -= length;
2509:../lib/fat.c  ****     }
2510:../lib/fat.c  **** 
2511:../lib/fat.c  ****     return (offset_t) count_arg.cluster_count * fs->header.cluster_size;
2512:../lib/fat.c  **** }
2513:../lib/fat.c  **** 
2514:../lib/fat.c  **** /**
2515:../lib/fat.c  ****  * \ingroup fat_fs
2516:../lib/fat.c  ****  * Callback function used for counting free clusters in a FAT.
2517:../lib/fat.c  ****  */
2518:../lib/fat.c  **** uint8_t fat_get_fs_free_16_callback(uint8_t* buffer, offset_t offset, void* p)
2519:../lib/fat.c  **** {
2520:../lib/fat.c  ****     struct fat_usage_count_callback_arg* count_arg = (struct fat_usage_count_callback_arg*) p;
2521:../lib/fat.c  ****     uintptr_t buffer_size = count_arg->buffer_size;
2522:../lib/fat.c  **** 
2523:../lib/fat.c  ****     for(uintptr_t i = 0; i < buffer_size; i += 2, buffer += 2)
2524:../lib/fat.c  ****     {
2525:../lib/fat.c  ****         uint16_t cluster = read16(buffer);
2526:../lib/fat.c  ****         if(cluster == HTOL16(FAT16_CLUSTER_FREE))
2527:../lib/fat.c  ****             ++(count_arg->cluster_count);
2528:../lib/fat.c  ****     }
2529:../lib/fat.c  **** 
2530:../lib/fat.c  ****     return 1;
2531:../lib/fat.c  **** }
2532:../lib/fat.c  **** 
2533:../lib/fat.c  **** #if DOXYGEN || FAT_FAT32_SUPPORT
2534:../lib/fat.c  **** /**
2535:../lib/fat.c  ****  * \ingroup fat_fs
2536:../lib/fat.c  ****  * Callback function used for counting free clusters in a FAT32.
2537:../lib/fat.c  ****  */
2538:../lib/fat.c  **** uint8_t fat_get_fs_free_32_callback(uint8_t* buffer, offset_t offset, void* p)
2539:../lib/fat.c  **** {
  72              		.loc 1 2539 0
  73              		.cfi_startproc
  74              		@ Function supports interworking.
  75              		@ args = 0, pretend = 0, frame = 0
  76              		@ frame_needed = 0, uses_anonymous_args = 0
  77              	.LVL6:
  78 003c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
  79              	.LCFI0:
  80              		.cfi_def_cfa_offset 20
  81              		.cfi_offset 4, -20
  82              		.cfi_offset 5, -16
  83              		.cfi_offset 6, -12
  84              		.cfi_offset 7, -8
  85              		.cfi_offset 14, -4
  86              		.loc 1 2539 0
  87 0040 0060A0E1 		mov	r6, r0
  88 0044 0350A0E1 		mov	r5, r3
2540:../lib/fat.c  ****     struct fat_usage_count_callback_arg* count_arg = (struct fat_usage_count_callback_arg*) p;
2541:../lib/fat.c  ****     uintptr_t buffer_size = count_arg->buffer_size;
  89              		.loc 1 2541 0
  90 0048 047093E5 		ldr	r7, [r3, #4]
  91              	.LVL7:
  92              	.LBB16:
2542:../lib/fat.c  **** 
2543:../lib/fat.c  ****     for(uintptr_t i = 0; i < buffer_size; i += 4, buffer += 4)
  93              		.loc 1 2543 0
  94 004c 0040A0E3 		mov	r4, #0
  95 0050 050000EA 		b	.L6
  96              	.LVL8:
  97              	.L8:
  98              	.LBB17:
2544:../lib/fat.c  ****     {
2545:../lib/fat.c  ****         uint32_t cluster = read32(buffer);
  99              		.loc 1 2545 0
 100 0054 FEFFFFEB 		bl	read32
 101              	.LVL9:
2546:../lib/fat.c  ****         if(cluster == HTOL32(FAT32_CLUSTER_FREE))
 102              		.loc 1 2546 0
 103 0058 000050E3 		cmp	r0, #0
2547:../lib/fat.c  ****             ++(count_arg->cluster_count);
 104              		.loc 1 2547 0
 105 005c 00309505 		ldreq	r3, [r5, #0]
 106 0060 01308302 		addeq	r3, r3, #1
 107 0064 00308505 		streq	r3, [r5, #0]
 108              	.LBE17:
2543:../lib/fat.c  ****     {
 109              		.loc 1 2543 0
 110 0068 044084E2 		add	r4, r4, #4
 111              	.LVL10:
 112              	.L6:
2543:../lib/fat.c  ****     {
 113              		.loc 1 2543 0 is_stmt 0 discriminator 1
 114 006c 070054E1 		cmp	r4, r7
2538:../lib/fat.c  **** {
 115              		.loc 1 2538 0 is_stmt 1 discriminator 1
 116 0070 040086E0 		add	r0, r6, r4
 117              	.LVL11:
2543:../lib/fat.c  ****     {
 118              		.loc 1 2543 0 discriminator 1
 119 0074 F6FFFF3A 		bcc	.L8
 120              	.LBE16:
2548:../lib/fat.c  ****     }
2549:../lib/fat.c  **** 
2550:../lib/fat.c  ****     return 1;
2551:../lib/fat.c  **** }
 121              		.loc 1 2551 0
 122 0078 0100A0E3 		mov	r0, #1
 123              	.LVL12:
 124 007c F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 125 0080 1EFF2FE1 		bx	lr
 126              		.cfi_endproc
 127              	.LFE32:
 129              		.align	2
 131              	fat_get_fs_free_16_callback:
 132              	.LFB31:
2519:../lib/fat.c  ****     struct fat_usage_count_callback_arg* count_arg = (struct fat_usage_count_callback_arg*) p;
 133              		.loc 1 2519 0
 134              		.cfi_startproc
 135              		@ Function supports interworking.
 136              		@ args = 0, pretend = 0, frame = 0
 137              		@ frame_needed = 0, uses_anonymous_args = 0
 138              	.LVL13:
 139 0084 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 140              	.LCFI1:
 141              		.cfi_def_cfa_offset 20
 142              		.cfi_offset 4, -20
 143              		.cfi_offset 5, -16
 144              		.cfi_offset 6, -12
 145              		.cfi_offset 7, -8
 146              		.cfi_offset 14, -4
2519:../lib/fat.c  ****     struct fat_usage_count_callback_arg* count_arg = (struct fat_usage_count_callback_arg*) p;
 147              		.loc 1 2519 0
 148 0088 0060A0E1 		mov	r6, r0
 149 008c 0350A0E1 		mov	r5, r3
2521:../lib/fat.c  **** 
 150              		.loc 1 2521 0
 151 0090 047093E5 		ldr	r7, [r3, #4]
 152              	.LVL14:
 153              	.LBB18:
2523:../lib/fat.c  ****     {
 154              		.loc 1 2523 0
 155 0094 0040A0E3 		mov	r4, #0
 156 0098 050000EA 		b	.L10
 157              	.LVL15:
 158              	.L12:
 159              	.LBB19:
2525:../lib/fat.c  ****         if(cluster == HTOL16(FAT16_CLUSTER_FREE))
 160              		.loc 1 2525 0
 161 009c FEFFFFEB 		bl	read16
 162              	.LVL16:
2526:../lib/fat.c  ****             ++(count_arg->cluster_count);
 163              		.loc 1 2526 0
 164 00a0 000050E3 		cmp	r0, #0
2527:../lib/fat.c  ****     }
 165              		.loc 1 2527 0
 166 00a4 00309505 		ldreq	r3, [r5, #0]
 167 00a8 01308302 		addeq	r3, r3, #1
 168 00ac 00308505 		streq	r3, [r5, #0]
 169              	.LBE19:
2523:../lib/fat.c  ****     {
 170              		.loc 1 2523 0
 171 00b0 024084E2 		add	r4, r4, #2
 172              	.LVL17:
 173              	.L10:
2523:../lib/fat.c  ****     {
 174              		.loc 1 2523 0 is_stmt 0 discriminator 1
 175 00b4 070054E1 		cmp	r4, r7
2518:../lib/fat.c  **** {
 176              		.loc 1 2518 0 is_stmt 1 discriminator 1
 177 00b8 040086E0 		add	r0, r6, r4
 178              	.LVL18:
2523:../lib/fat.c  ****     {
 179              		.loc 1 2523 0 discriminator 1
 180 00bc F6FFFF3A 		bcc	.L12
 181              	.LBE18:
2531:../lib/fat.c  **** 
 182              		.loc 1 2531 0
 183 00c0 0100A0E3 		mov	r0, #1
 184              	.LVL19:
 185 00c4 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 186 00c8 1EFF2FE1 		bx	lr
 187              		.cfi_endproc
 188              	.LFE31:
 190              		.align	2
 192              	fat_dir_entry_read_callback:
 193              	.LFB21:
1596:../lib/fat.c  ****     struct fat_read_dir_callback_arg* arg = p;
 194              		.loc 1 1596 0
 195              		.cfi_startproc
 196              		@ Function supports interworking.
 197              		@ args = 0, pretend = 0, frame = 16
 198              		@ frame_needed = 0, uses_anonymous_args = 0
 199              	.LVL20:
 200 00cc FF412DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 201              	.LCFI2:
 202              		.cfi_def_cfa_offset 40
 203              		.cfi_offset 0, -40
 204              		.cfi_offset 1, -36
 205              		.cfi_offset 2, -32
 206              		.cfi_offset 3, -28
 207              		.cfi_offset 4, -24
 208              		.cfi_offset 5, -20
 209              		.cfi_offset 6, -16
 210              		.cfi_offset 7, -12
 211              		.cfi_offset 8, -8
 212              		.cfi_offset 14, -4
1596:../lib/fat.c  ****     struct fat_read_dir_callback_arg* arg = p;
 213              		.loc 1 1596 0
 214 00d0 0380A0E1 		mov	r8, r3
1598:../lib/fat.c  **** 
 215              		.loc 1 1598 0
 216 00d4 006093E5 		ldr	r6, [r3, #0]
 217              	.LVL21:
1600:../lib/fat.c  **** 
 218              		.loc 1 1600 0
 219 00d8 043093E5 		ldr	r3, [r3, #4]
 220              	.LVL22:
 221 00dc 203083E2 		add	r3, r3, #32
 222 00e0 043088E5 		str	r3, [r8, #4]
1603:../lib/fat.c  ****     {
 223              		.loc 1 1603 0
 224 00e4 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 225 00e8 E50053E3 		cmp	r3, #229
 226 00ec 00005313 		cmpne	r3, #0
1606:../lib/fat.c  **** #endif
 227              		.loc 1 1606 0
 228 00f0 0030A003 		moveq	r3, #0
1596:../lib/fat.c  ****     struct fat_read_dir_callback_arg* arg = p;
 229              		.loc 1 1596 0
 230 00f4 0070A0E1 		mov	r7, r0
 231 00f8 0140A0E1 		mov	r4, r1
 232 00fc 0250A0E1 		mov	r5, r2
1606:../lib/fat.c  **** #endif
 233              		.loc 1 1606 0
 234 0100 0830C805 		streqb	r3, [r8, #8]
1603:../lib/fat.c  ****     {
 235              		.loc 1 1603 0
 236 0104 2300000A 		beq	.L21
 237              	.L14:
 238              	.LVL23:
1619:../lib/fat.c  ****     {
 239              		.loc 1 1619 0
 240 0108 0B30D0E5 		ldrb	r3, [r0, #11]	@ zero_extendqisi2
 241 010c 0F0053E3 		cmp	r3, #15
 242 0110 2600001A 		bne	.L16
 243              	.LBB20:
1622:../lib/fat.c  ****         {
 244              		.loc 1 1622 0
 245 0114 0830D8E5 		ldrb	r3, [r8, #8]	@ zero_extendqisi2
 246 0118 000053E3 		cmp	r3, #0
 247 011c 0200000A 		beq	.L17
1622:../lib/fat.c  ****         {
 248              		.loc 1 1622 0 is_stmt 0 discriminator 1
 249 0120 0D20D0E5 		ldrb	r2, [r0, #13]	@ zero_extendqisi2
 250 0124 030052E1 		cmp	r2, r3
 251 0128 0700000A 		beq	.L18
 252              	.L17:
1625:../lib/fat.c  **** 
 253              		.loc 1 1625 0 is_stmt 1
 254 012c 0600A0E1 		mov	r0, r6
 255              	.LVL24:
 256 0130 0010A0E3 		mov	r1, #0
 257              	.LVL25:
 258 0134 3420A0E3 		mov	r2, #52
 259 0138 FEFFFFEB 		bl	memset
 260              	.LVL26:
1627:../lib/fat.c  ****             dir_entry->entry_offset = offset;
 261              		.loc 1 1627 0
 262 013c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 263 0140 0830C8E5 		strb	r3, [r8, #8]
1628:../lib/fat.c  ****         }
 264              		.loc 1 1628 0
 265 0144 2C4086E5 		str	r4, [r6, #44]
 266 0148 305086E5 		str	r5, [r6, #48]
 267              	.L18:
1635:../lib/fat.c  ****         const uint8_t char_mapping[] = { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
 268              		.loc 1 1635 0
 269 014c 0040D7E5 		ldrb	r4, [r7, #0]	@ zero_extendqisi2
 270 0150 3F4004E2 		and	r4, r4, #63
 271 0154 0D20A0E3 		mov	r2, #13
 272 0158 014044E2 		sub	r4, r4, #1
 273 015c 920404E0 		mul	r4, r2, r4
 274 0160 0448A0E1 		mov	r4, r4, asl #16
 275 0164 2448A0E1 		mov	r4, r4, lsr #16
 276              	.LVL27:
1636:../lib/fat.c  ****         for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
 277              		.loc 1 1636 0
 278 0168 0D00A0E1 		mov	r0, sp
 279 016c 8C119FE5 		ldr	r1, .L55
 280 0170 FEFFFFEB 		bl	memcpy
 281              	.LVL28:
 282              	.LBB21:
1595:../lib/fat.c  **** {
 283              		.loc 1 1595 0
 284 0174 046086E0 		add	r6, r6, r4
 285              	.LVL29:
 286              	.LBE21:
1636:../lib/fat.c  ****         for(uint8_t i = 0; i <= 12 && char_offset + i < sizeof(dir_entry->long_name) - 1; ++i)
 287              		.loc 1 1636 0
 288 0178 0030A0E3 		mov	r3, #0
 289 017c 070000EA 		b	.L19
 290              	.LVL30:
 291              	.L20:
 292              	.LBB22:
1638:../lib/fat.c  **** 
 293              		.loc 1 1638 0 discriminator 1
 294 0180 0320DDE7 		ldrb	r2, [sp, r3]	@ zero_extendqisi2
 295 0184 0220D7E7 		ldrb	r2, [r7, r2]	@ zero_extendqisi2
 296 0188 0320C6E7 		strb	r2, [r6, r3]
 297 018c 013083E2 		add	r3, r3, #1
1637:../lib/fat.c  ****             long_name[char_offset + i] = buffer[char_mapping[i]];
 298              		.loc 1 1637 0 discriminator 1
 299 0190 0D0053E3 		cmp	r3, #13
 300 0194 0100001A 		bne	.L19
 301              	.LVL31:
 302              	.L21:
 303              	.LBE22:
1640:../lib/fat.c  ****     }
 304              		.loc 1 1640 0
 305 0198 0100A0E3 		mov	r0, #1
 306 019c 540000EA 		b	.L15
 307              	.LVL32:
 308              	.L19:
 309              	.LBB23:
1637:../lib/fat.c  ****             long_name[char_offset + i] = buffer[char_mapping[i]];
 310              		.loc 1 1637 0 discriminator 2
 311 01a0 042083E0 		add	r2, r3, r4
 312 01a4 1E0052E3 		cmp	r2, #30
 313 01a8 F4FFFF9A 		bls	.L20
 314 01ac F9FFFFEA 		b	.L21
 315              	.LVL33:
 316              	.L16:
 317              	.LBE23:
 318              	.LBE20:
1647:../lib/fat.c  **** #endif
 319              		.loc 1 1647 0
 320 01b0 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 321 01b4 000053E3 		cmp	r3, #0
 322 01b8 0300000A 		beq	.L22
1647:../lib/fat.c  **** #endif
 323              		.loc 1 1647 0 is_stmt 0 discriminator 1
 324 01bc 91FFFFEB 		bl	fat_calc_83_checksum
 325              	.LVL34:
 326 01c0 0830D8E5 		ldrb	r3, [r8, #8]	@ zero_extendqisi2
 327 01c4 000053E1 		cmp	r3, r0
 328 01c8 3900000A 		beq	.L23
 329              	.L22:
 330              	.LBB24:
1651:../lib/fat.c  ****             dir_entry->entry_offset = offset;
 331              		.loc 1 1651 0 is_stmt 1
 332 01cc 0010A0E3 		mov	r1, #0
 333 01d0 0600A0E1 		mov	r0, r6
 334 01d4 3420A0E3 		mov	r2, #52
 335 01d8 FEFFFFEB 		bl	memset
 336              	.LVL35:
1652:../lib/fat.c  **** 
 337              		.loc 1 1652 0
 338 01dc 2C4086E5 		str	r4, [r6, #44]
 339 01e0 305086E5 		str	r5, [r6, #48]
 340              	.LVL36:
 341 01e4 0010A0E3 		mov	r1, #0
 342              	.LVL37:
 343              	.L26:
1657:../lib/fat.c  ****                     break;
 344              		.loc 1 1657 0
 345 01e8 0130D7E7 		ldrb	r3, [r7, r1]	@ zero_extendqisi2
 346 01ec 200053E3 		cmp	r3, #32
 347 01f0 FF2001E2 		and	r2, r1, #255
 348 01f4 0D00000A 		beq	.L24
1659:../lib/fat.c  **** 
 349              		.loc 1 1659 0
 350 01f8 0130C6E7 		strb	r3, [r6, r1]
1666:../lib/fat.c  ****                     long_name[i] += 'a' - 'A';
 351              		.loc 1 1666 0
 352 01fc 0C20D7E5 		ldrb	r2, [r7, #12]	@ zero_extendqisi2
 353 0200 080012E3 		tst	r2, #8
 354 0204 0500000A 		beq	.L25
1666:../lib/fat.c  ****                     long_name[i] += 'a' - 'A';
 355              		.loc 1 1666 0 is_stmt 0 discriminator 1
 356 0208 0120D7E7 		ldrb	r2, [r7, r1]	@ zero_extendqisi2
 357 020c 400052E3 		cmp	r2, #64
 358 0210 0200009A 		bls	.L25
 359 0214 5A0052E3 		cmp	r2, #90
1667:../lib/fat.c  ****             }
 360              		.loc 1 1667 0 is_stmt 1 discriminator 1
 361 0218 20308392 		addls	r3, r3, #32
 362 021c 0130C697 		strlsb	r3, [r6, r1]
 363              	.L25:
 364 0220 011081E2 		add	r1, r1, #1
1655:../lib/fat.c  ****             {
 365              		.loc 1 1655 0
 366 0224 080051E3 		cmp	r1, #8
 367 0228 EEFFFF1A 		bne	.L26
 368 022c 0120A0E1 		mov	r2, r1
 369              	.L24:
1669:../lib/fat.c  ****                 long_name[0] = (char) FAT_DIRENTRY_DELETED;
 370              		.loc 1 1669 0
 371 0230 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 372 0234 050053E3 		cmp	r3, #5
1670:../lib/fat.c  **** 
 373              		.loc 1 1670 0
 374 0238 1A30E003 		mvneq	r3, #26
 375 023c 0030C605 		streqb	r3, [r6, #0]
1672:../lib/fat.c  ****             {
 376              		.loc 1 1672 0
 377 0240 0830D7E5 		ldrb	r3, [r7, #8]	@ zero_extendqisi2
 378 0244 200053E3 		cmp	r3, #32
 379 0248 1700000A 		beq	.L28
 380              	.LBB25:
1674:../lib/fat.c  **** 
 381              		.loc 1 1674 0
 382 024c 2E30A0E3 		mov	r3, #46
 383 0250 0230C6E7 		strb	r3, [r6, r2]
 384 0254 011082E2 		add	r1, r2, #1
 385              	.LVL38:
1595:../lib/fat.c  **** {
 386              		.loc 1 1595 0
 387 0258 042082E2 		add	r2, r2, #4
 388              	.LVL39:
 389 025c FFC002E2 		and	ip, r2, #255
 390 0260 083087E2 		add	r3, r7, #8
 391              	.LBE25:
1674:../lib/fat.c  **** 
 392              		.loc 1 1674 0
 393 0264 FF2001E2 		and	r2, r1, #255
 394              	.LVL40:
 395              	.L30:
 396              	.LBB26:
1679:../lib/fat.c  ****                         break;
 397              		.loc 1 1679 0
 398 0268 0110D3E4 		ldrb	r1, [r3], #1	@ zero_extendqisi2
 399 026c 200051E3 		cmp	r1, #32
 400 0270 0D00000A 		beq	.L28
1681:../lib/fat.c  **** 
 401              		.loc 1 1681 0
 402 0274 0210C6E7 		strb	r1, [r6, r2]
1686:../lib/fat.c  ****                         long_name[i] += 'a' - 'A';
 403              		.loc 1 1686 0
 404 0278 0C00D7E5 		ldrb	r0, [r7, #12]	@ zero_extendqisi2
 405 027c 100010E3 		tst	r0, #16
 406 0280 0500000A 		beq	.L29
1686:../lib/fat.c  ****                         long_name[i] += 'a' - 'A';
 407              		.loc 1 1686 0 is_stmt 0 discriminator 1
 408 0284 010053E5 		ldrb	r0, [r3, #-1]	@ zero_extendqisi2
 409 0288 400050E3 		cmp	r0, #64
 410 028c 0200009A 		bls	.L29
 411 0290 5A0050E3 		cmp	r0, #90
1687:../lib/fat.c  **** 
 412              		.loc 1 1687 0 is_stmt 1 discriminator 1
 413 0294 20108192 		addls	r1, r1, #32
 414 0298 0210C697 		strlsb	r1, [r6, r2]
 415              	.L29:
1689:../lib/fat.c  ****                 }
 416              		.loc 1 1689 0
 417 029c 012082E2 		add	r2, r2, #1
 418 02a0 FF2002E2 		and	r2, r2, #255
 419              	.LVL41:
1677:../lib/fat.c  ****                 {
 420              		.loc 1 1677 0
 421 02a4 0C0052E1 		cmp	r2, ip
 422 02a8 EEFFFF1A 		bne	.L30
 423              	.LVL42:
 424              	.L28:
 425              	.LBE26:
1693:../lib/fat.c  ****         }
 426              		.loc 1 1693 0
 427 02ac 0030A0E3 		mov	r3, #0
 428 02b0 0230C6E7 		strb	r3, [r6, r2]
 429              	.LVL43:
 430              	.L23:
 431              	.LBE24:
1697:../lib/fat.c  ****         dir_entry->cluster = read16(&buffer[26]);
 432              		.loc 1 1697 0
 433 02b4 0B30D7E5 		ldrb	r3, [r7, #11]	@ zero_extendqisi2
1698:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 434              		.loc 1 1698 0
 435 02b8 1A0087E2 		add	r0, r7, #26
1697:../lib/fat.c  ****         dir_entry->cluster = read16(&buffer[26]);
 436              		.loc 1 1697 0
 437 02bc 2030C6E5 		strb	r3, [r6, #32]
1698:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 438              		.loc 1 1698 0
 439 02c0 FEFFFFEB 		bl	read16
 440              	.LVL44:
 441 02c4 0040A0E1 		mov	r4, r0
 442 02c8 240086E5 		str	r0, [r6, #36]
1700:../lib/fat.c  **** #endif
 443              		.loc 1 1700 0
 444 02cc 140087E2 		add	r0, r7, #20
 445 02d0 FEFFFFEB 		bl	read16
 446              	.LVL45:
 447 02d4 000884E1 		orr	r0, r4, r0, asl #16
 448 02d8 240086E5 		str	r0, [r6, #36]
1702:../lib/fat.c  **** 
 449              		.loc 1 1702 0
 450 02dc 1C0087E2 		add	r0, r7, #28
 451 02e0 FEFFFFEB 		bl	read32
 452              	.LVL46:
1709:../lib/fat.c  ****         return 0;
 453              		.loc 1 1709 0
 454 02e4 0130A0E3 		mov	r3, #1
1702:../lib/fat.c  **** 
 455              		.loc 1 1702 0
 456 02e8 280086E5 		str	r0, [r6, #40]
1709:../lib/fat.c  ****         return 0;
 457              		.loc 1 1709 0
 458 02ec 0930C8E5 		strb	r3, [r8, #9]
1710:../lib/fat.c  ****     }
 459              		.loc 1 1710 0
 460 02f0 0000A0E3 		mov	r0, #0
 461              	.LVL47:
 462              	.L15:
1712:../lib/fat.c  **** 
 463              		.loc 1 1712 0
 464 02f4 10D08DE2 		add	sp, sp, #16
 465 02f8 F041BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, lr}
 466 02fc 1EFF2FE1 		bx	lr
 467              	.L56:
 468              		.align	2
 469              	.L55:
 470 0300 00000000 		.word	.LANCHOR0
 471              		.cfi_endproc
 472              	.LFE21:
 474              		.align	2
 476              	fat_get_next_cluster:
 477              	.LFB3:
 441:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 478              		.loc 1 441 0
 479              		.cfi_startproc
 480              		@ Function supports interworking.
 481              		@ args = 0, pretend = 0, frame = 8
 482              		@ frame_needed = 0, uses_anonymous_args = 0
 483              	.LVL48:
 442:../lib/fat.c  ****         return 0;
 484              		.loc 1 442 0
 485 0304 000050E3 		cmp	r0, #0
 486 0308 01005113 		cmpne	r1, #1
 441:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 487              		.loc 1 441 0
 488 030c 03402DE9 		stmfd	sp!, {r0, r1, lr}
 489              	.LCFI3:
 490              		.cfi_def_cfa_offset 12
 491              		.cfi_offset 0, -12
 492              		.cfi_offset 1, -8
 493              		.cfi_offset 14, -4
 441:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 494              		.loc 1 441 0
 495 0310 0120A0E1 		mov	r2, r1
 442:../lib/fat.c  ****         return 0;
 496              		.loc 1 442 0
 497 0314 2B00009A 		bls	.L63
 498              	.LVL49:
 499              	.LBB31:
 500              	.LBB32:
 446:../lib/fat.c  ****     {
 501              		.loc 1 446 0
 502 0318 00C090E5 		ldr	ip, [r0, #0]
 503 031c 1030DCE5 		ldrb	r3, [ip, #16]	@ zero_extendqisi2
 504 0320 0B0053E3 		cmp	r3, #11
 505 0324 0C1080E2 		add	r1, r0, #12
 506 0328 030091E8 		ldmia	r1, {r0-r1}
 507              	.LVL50:
 508 032c 1100001A 		bne	.L59
 509              	.LBB33:
 450:../lib/fat.c  ****             return 0;
 510              		.loc 1 450 0
 511 0330 0430A0E3 		mov	r3, #4
 512 0334 9302A1E0 		umlal	r0, r1, r3, r2
 513 0338 03208DE0 		add	r2, sp, r3
 514 033c 00C09CE5 		ldr	ip, [ip, #0]
 515 0340 0FE0A0E1 		mov	lr, pc
 516 0344 1CFF2FE1 		bx	ip
 517              	.LVL51:
 518 0348 000050E3 		cmp	r0, #0
 519 034c 1D00000A 		beq	.L63
 520              	.LVL52:
 454:../lib/fat.c  ****         
 521              		.loc 1 454 0
 522 0350 04009DE5 		ldr	r0, [sp, #4]
 523              	.LVL53:
 456:../lib/fat.c  ****            cluster_num == FAT32_CLUSTER_BAD ||
 524              		.loc 1 456 0
 525 0354 9F0270E3 		cmn	r0, #-268435447
 526 0358 00005013 		cmpne	r0, #0
 527 035c 1900000A 		beq	.L63
 458:../lib/fat.c  ****            (cluster_num >= FAT32_CLUSTER_LAST_MIN && cluster_num <= FAT32_CLUSTER_LAST_MAX))
 528              		.loc 1 458 0
 529 0360 0F3280E2 		add	r3, r0, #-268435456
 530 0364 103083E2 		add	r3, r3, #16
 457:../lib/fat.c  ****            (cluster_num >= FAT32_CLUSTER_RESERVED_MIN && cluster_num <= FAT32_CLUSTER_RESERVED_MAX)
 531              		.loc 1 457 0
 532 0368 060053E3 		cmp	r3, #6
 459:../lib/fat.c  ****             return 0;
 533              		.loc 1 459 0
 534 036c 8F328082 		addhi	r3, r0, #-268435448
 457:../lib/fat.c  ****            (cluster_num >= FAT32_CLUSTER_RESERVED_MIN && cluster_num <= FAT32_CLUSTER_RESERVED_MAX)
 535              		.loc 1 457 0
 536 0370 1200008A 		bhi	.L71
 537 0374 130000EA 		b	.L63
 538              	.LVL54:
 539              	.L59:
 540              	.LBE33:
 541              	.LBB34:
 467:../lib/fat.c  ****             return 0;
 542              		.loc 1 467 0
 543 0378 0230A0E3 		mov	r3, #2
 544 037c 9302A1E0 		umlal	r0, r1, r3, r2
 545 0380 03208DE0 		add	r2, sp, r3
 546 0384 00C09CE5 		ldr	ip, [ip, #0]
 547 0388 0FE0A0E1 		mov	lr, pc
 548 038c 1CFF2FE1 		bx	ip
 549              	.LVL55:
 550 0390 000050E3 		cmp	r0, #0
 551 0394 0B00000A 		beq	.L63
 552              	.LVL56:
 471:../lib/fat.c  ****         
 553              		.loc 1 471 0
 554 0398 B200DDE1 		ldrh	r0, [sp, #2]
 555              	.LVL57:
 473:../lib/fat.c  ****            cluster_num == FAT16_CLUSTER_BAD ||
 556              		.loc 1 473 0
 557 039c 30309FE5 		ldr	r3, .L72
 558 03a0 000050E3 		cmp	r0, #0
 559 03a4 03005011 		cmpne	r0, r3
 560 03a8 0600000A 		beq	.L63
 475:../lib/fat.c  ****            (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 561              		.loc 1 475 0
 562 03ac FF3C40E2 		sub	r3, r0, #65280
 563 03b0 F02043E2 		sub	r2, r3, #240
 474:../lib/fat.c  ****            (cluster_num >= FAT16_CLUSTER_RESERVED_MIN && cluster_num <= FAT16_CLUSTER_RESERVED_MAX)
 564              		.loc 1 474 0
 565 03b4 060052E3 		cmp	r2, #6
 566 03b8 0200009A 		bls	.L63
 476:../lib/fat.c  ****             return 0;
 567              		.loc 1 476 0
 568 03bc F83043E2 		sub	r3, r3, #248
 569              	.LVL58:
 570              	.L71:
 475:../lib/fat.c  ****            (cluster_num >= FAT16_CLUSTER_LAST_MIN && cluster_num <= FAT16_CLUSTER_LAST_MAX))
 571              		.loc 1 475 0
 572 03c0 070053E3 		cmp	r3, #7
 573 03c4 0000008A 		bhi	.L58
 574              	.LVL59:
 575              	.L63:
 576              	.LBE34:
 577              	.LBE32:
 578              	.LBE31:
 443:../lib/fat.c  **** 
 579              		.loc 1 443 0
 580 03c8 0000A0E3 		mov	r0, #0
 581              	.L58:
 481:../lib/fat.c  **** 
 582              		.loc 1 481 0
 583 03cc 0C40BDE8 		ldmfd	sp!, {r2, r3, lr}
 584 03d0 1EFF2FE1 		bx	lr
 585              	.L73:
 586              		.align	2
 587              	.L72:
 588 03d4 F7FF0000 		.word	65527
 589              		.cfi_endproc
 590              	.LFE3:
 592              		.align	2
 594              	fat_free_clusters:
 595              	.LFB5:
 654:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 596              		.loc 1 654 0
 597              		.cfi_startproc
 598              		@ Function supports interworking.
 599              		@ args = 0, pretend = 0, frame = 12
 600              		@ frame_needed = 0, uses_anonymous_args = 0
 601              	.LVL60:
 655:../lib/fat.c  ****         return 0;
 602              		.loc 1 655 0
 603 03d8 000050E3 		cmp	r0, #0
 604 03dc 01005113 		cmpne	r1, #1
 654:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 605              		.loc 1 654 0
 606 03e0 F74F2DE9 		stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 607              	.LCFI4:
 608              		.cfi_def_cfa_offset 48
 609              		.cfi_offset 0, -48
 610              		.cfi_offset 1, -44
 611              		.cfi_offset 2, -40
 612              		.cfi_offset 4, -36
 613              		.cfi_offset 5, -32
 614              		.cfi_offset 6, -28
 615              		.cfi_offset 7, -24
 616              		.cfi_offset 8, -20
 617              		.cfi_offset 9, -16
 618              		.cfi_offset 10, -12
 619              		.cfi_offset 11, -8
 620              		.cfi_offset 14, -4
 654:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 621              		.loc 1 654 0
 622 03e4 01A0A0E1 		mov	sl, r1
 655:../lib/fat.c  ****         return 0;
 623              		.loc 1 655 0
 624 03e8 0080A0E1 		mov	r8, r0
 625 03ec 0090A083 		movhi	r9, #0
 626 03f0 0190A093 		movls	r9, #1
 627 03f4 5700009A 		bls	.L85
 628              	.LVL61:
 629              	.LBB41:
 630              	.LBB42:
 660:../lib/fat.c  ****     {
 631              		.loc 1 660 0
 632 03f8 003090E5 		ldr	r3, [r0, #0]
 633 03fc 1030D3E5 		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 634 0400 0B0053E3 		cmp	r3, #11
 658:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 635              		.loc 1 658 0
 636 0404 0C5080E2 		add	r5, r0, #12
 637 0408 300095E8 		ldmia	r5, {r4-r5}
 638              	.LVL62:
 639              	.LBB43:
 640              	.LBB44:
 705:../lib/fat.c  ****                 return 0;
 641              		.loc 1 705 0
 642 040c 02B0A013 		movne	fp, #2
 719:../lib/fat.c  ****                 cluster_num_next = 0;
 643              		.loc 1 719 0
 644 0410 4C919F15 		ldrne	r9, .L99
 645              	.LBE44:
 646              	.LBE43:
 660:../lib/fat.c  ****     {
 647              		.loc 1 660 0
 648 0414 2B00001A 		bne	.L95
 649 0418 010000EA 		b	.L97
 650              	.LVL63:
 651              	.L90:
 652              	.LBB47:
 696:../lib/fat.c  ****         }
 653              		.loc 1 696 0
 654 041c 0CA0A0E1 		mov	sl, ip
 655 0420 000000EA 		b	.L98
 656              	.LVL64:
 657              	.L97:
 658              	.LBB48:
 665:../lib/fat.c  ****                 return 0;
 659              		.loc 1 665 0
 660 0424 04B0A0E3 		mov	fp, #4
 661              	.LVL65:
 662              	.L98:
 663 0428 0460A0E1 		mov	r6, r4
 664 042c 0570A0E1 		mov	r7, r5
 665 0430 9B6AA7E0 		umlal	r6, r7, fp, sl
 666 0434 00C098E5 		ldr	ip, [r8, #0]
 667 0438 0600A0E1 		mov	r0, r6
 668 043c 0710A0E1 		mov	r1, r7
 669 0440 08208DE2 		add	r2, sp, #8
 670 0444 0430A0E3 		mov	r3, #4
 671 0448 00C09CE5 		ldr	ip, [ip, #0]
 672 044c 0FE0A0E1 		mov	lr, pc
 673 0450 1CFF2FE1 		bx	ip
 674              	.LVL66:
 675 0454 000050E3 		cmp	r0, #0
 676 0458 3F00000A 		beq	.L75
 669:../lib/fat.c  **** 
 677              		.loc 1 669 0
 678 045c 08C09DE5 		ldr	ip, [sp, #8]
 679              	.LVL67:
 671:../lib/fat.c  ****                 return 1;
 680              		.loc 1 671 0
 681 0460 00005CE3 		cmp	ip, #0
 682 0464 3900000A 		beq	.L92
 673:../lib/fat.c  ****                (cluster_num_next >= FAT32_CLUSTER_RESERVED_MIN &&
 683              		.loc 1 673 0
 684 0468 0F328CE2 		add	r3, ip, #-268435456
 685 046c 103083E2 		add	r3, r3, #16
 686 0470 070053E3 		cmp	r3, #7
 687 0474 3700009A 		bls	.L85
 679:../lib/fat.c  ****                 cluster_num_next = 0;
 688              		.loc 1 679 0
 689 0478 8F328CE2 		add	r3, ip, #-268435448
 680:../lib/fat.c  **** 
 690              		.loc 1 680 0
 691 047c 070053E3 		cmp	r3, #7
 685:../lib/fat.c  ****                 fs->cluster_free = cluster_num;
 692              		.loc 1 685 0
 693 0480 303098E5 		ldr	r3, [r8, #48]
 680:../lib/fat.c  **** 
 694              		.loc 1 680 0
 695 0484 00C0A093 		movls	ip, #0
 696              	.LVL68:
 685:../lib/fat.c  ****                 fs->cluster_free = cluster_num;
 697              		.loc 1 685 0
 698 0488 000053E3 		cmp	r3, #0
 686:../lib/fat.c  **** 
 699              		.loc 1 686 0
 700 048c 30A08805 		streq	sl, [r8, #48]
 689:../lib/fat.c  ****             fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (u
 701              		.loc 1 689 0
 702 0490 08908DE5 		str	r9, [sp, #8]
 690:../lib/fat.c  **** 
 703              		.loc 1 690 0
 704 0494 00A098E5 		ldr	sl, [r8, #0]
 705              	.LVL69:
 706 0498 0600A0E1 		mov	r0, r6
 707 049c 00C08DE5 		str	ip, [sp, #0]
 708 04a0 0710A0E1 		mov	r1, r7
 709 04a4 08208DE2 		add	r2, sp, #8
 710 04a8 0430A0E3 		mov	r3, #4
 711 04ac 08C09AE5 		ldr	ip, [sl, #8]
 712 04b0 0FE0A0E1 		mov	lr, pc
 713 04b4 1CFF2FE1 		bx	ip
 714              	.LVL70:
 715              	.LBE48:
 663:../lib/fat.c  ****         {
 716              		.loc 1 663 0
 717 04b8 00C09DE5 		ldr	ip, [sp, #0]
 718 04bc 00005CE3 		cmp	ip, #0
 719 04c0 D5FFFF1A 		bne	.L90
 720 04c4 210000EA 		b	.L92
 721              	.LVL71:
 722              	.L95:
 723              	.LBE47:
 724              	.LBB49:
 725              	.LBB45:
 705:../lib/fat.c  ****                 return 0;
 726              		.loc 1 705 0
 727 04c8 0460A0E1 		mov	r6, r4
 728 04cc 0570A0E1 		mov	r7, r5
 729 04d0 9B6AA7E0 		umlal	r6, r7, fp, sl
 730 04d4 00C098E5 		ldr	ip, [r8, #0]
 731 04d8 0600A0E1 		mov	r0, r6
 732 04dc 0710A0E1 		mov	r1, r7
 733 04e0 06208DE2 		add	r2, sp, #6
 734 04e4 0230A0E3 		mov	r3, #2
 735 04e8 00C09CE5 		ldr	ip, [ip, #0]
 736 04ec 0FE0A0E1 		mov	lr, pc
 737 04f0 1CFF2FE1 		bx	ip
 738              	.LVL72:
 739 04f4 000050E3 		cmp	r0, #0
 740 04f8 1700000A 		beq	.L75
 709:../lib/fat.c  **** 
 741              		.loc 1 709 0
 742 04fc B6A0DDE1 		ldrh	sl, [sp, #6]
 743              	.LVL73:
 711:../lib/fat.c  ****                 return 1;
 744              		.loc 1 711 0
 745 0500 00005AE3 		cmp	sl, #0
 746 0504 1100000A 		beq	.L92
 713:../lib/fat.c  ****                (cluster_num_next >= FAT16_CLUSTER_RESERVED_MIN &&
 747              		.loc 1 713 0
 748 0508 10308AE2 		add	r3, sl, #16
 749 050c 0338A0E1 		mov	r3, r3, asl #16
 750 0510 070853E3 		cmp	r3, #458752
 751 0514 0F00009A 		bls	.L85
 720:../lib/fat.c  **** 
 752              		.loc 1 720 0
 753 0518 09005AE1 		cmp	sl, r9
 723:../lib/fat.c  ****             fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (u
 754              		.loc 1 723 0
 755 051c 0030A0E3 		mov	r3, #0
 720:../lib/fat.c  **** 
 756              		.loc 1 720 0
 757 0520 00A0A083 		movhi	sl, #0
 758              	.LVL74:
 723:../lib/fat.c  ****             fs->partition->device_write(fat_offset + (offset_t) cluster_num * sizeof(fat_entry), (u
 759              		.loc 1 723 0
 760 0524 B630CDE1 		strh	r3, [sp, #6]	@ movhi
 724:../lib/fat.c  **** 
 761              		.loc 1 724 0
 762 0528 00C098E5 		ldr	ip, [r8, #0]
 763 052c 0600A0E1 		mov	r0, r6
 764 0530 0710A0E1 		mov	r1, r7
 765 0534 06208DE2 		add	r2, sp, #6
 766 0538 0230A0E3 		mov	r3, #2
 767 053c 08C09CE5 		ldr	ip, [ip, #8]
 768 0540 0FE0A0E1 		mov	lr, pc
 769 0544 1CFF2FE1 		bx	ip
 770              	.LVL75:
 771              	.LBE45:
 703:../lib/fat.c  ****         {
 772              		.loc 1 703 0
 773 0548 00005AE3 		cmp	sl, #0
 774 054c DDFFFF1A 		bne	.L95
 775              	.LVL76:
 776              	.L92:
 777              	.LBB46:
 712:../lib/fat.c  ****             if(cluster_num_next == FAT16_CLUSTER_BAD ||
 778              		.loc 1 712 0
 779 0550 0100A0E3 		mov	r0, #1
 780 0554 000000EA 		b	.L75
 781              	.LVL77:
 782              	.L85:
 783              	.LBE46:
 784              	.LBE49:
 785              	.LBE42:
 786              	.LBE41:
 656:../lib/fat.c  **** 
 787              		.loc 1 656 0
 788 0558 0000A0E3 		mov	r0, #0
 789              	.L75:
 735:../lib/fat.c  **** #endif
 790              		.loc 1 735 0
 791 055c FE4FBDE8 		ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 792 0560 1EFF2FE1 		bx	lr
 793              	.L100:
 794              		.align	2
 795              	.L99:
 796 0564 F7FF0000 		.word	65527
 797              		.cfi_endproc
 798              	.LFE5:
 800              		.align	2
 802              	fat_append_clusters:
 803              	.LFB4:
 496:../lib/fat.c  ****     if(!fs)
 804              		.loc 1 496 0
 805              		.cfi_startproc
 806              		@ Function supports interworking.
 807              		@ args = 0, pretend = 0, frame = 32
 808              		@ frame_needed = 0, uses_anonymous_args = 0
 809              	.LVL78:
 810 0568 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 811              	.LCFI5:
 812              		.cfi_def_cfa_offset 36
 813              		.cfi_offset 4, -36
 814              		.cfi_offset 5, -32
 815              		.cfi_offset 6, -28
 816              		.cfi_offset 7, -24
 817              		.cfi_offset 8, -20
 818              		.cfi_offset 9, -16
 819              		.cfi_offset 10, -12
 820              		.cfi_offset 11, -8
 821              		.cfi_offset 14, -4
 497:../lib/fat.c  ****         return 0;
 822              		.loc 1 497 0
 823 056c 007050E2 		subs	r7, r0, #0
 496:../lib/fat.c  ****     if(!fs)
 824              		.loc 1 496 0
 825 0570 20D04DE2 		sub	sp, sp, #32
 826              	.LCFI6:
 827              		.cfi_def_cfa_offset 68
 496:../lib/fat.c  ****     if(!fs)
 828              		.loc 1 496 0
 829 0574 01B0A0E1 		mov	fp, r1
 497:../lib/fat.c  ****         return 0;
 830              		.loc 1 497 0
 831 0578 7400000A 		beq	.L159
 832              	.L102:
 500:../lib/fat.c  ****     device_write_t device_write = fs->partition->device_write;
 833              		.loc 1 500 0
 834 057c 003097E5 		ldr	r3, [r7, #0]
 502:../lib/fat.c  ****     cluster_t count_left = count;
 835              		.loc 1 502 0
 836 0580 0C1087E2 		add	r1, r7, #12
 837 0584 030091E8 		ldmia	r1, {r0-r1}
 838              	.LVL79:
 500:../lib/fat.c  ****     device_write_t device_write = fs->partition->device_write;
 839              		.loc 1 500 0
 840 0588 00C093E5 		ldr	ip, [r3, #0]
 501:../lib/fat.c  ****     offset_t fat_offset = fs->header.fat_offset;
 841              		.loc 1 501 0
 842 058c 08A093E5 		ldr	sl, [r3, #8]
 510:../lib/fat.c  **** 
 843              		.loc 1 510 0
 844 0590 1030D3E5 		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 502:../lib/fat.c  ****     cluster_t count_left = count;
 845              		.loc 1 502 0
 846 0594 03008DE8 		stmia	sp, {r0-r1}
 510:../lib/fat.c  **** 
 847              		.loc 1 510 0
 848 0598 0B1053E2 		subs	r1, r3, #11
 849              	.LVL80:
 850 059c 003071E2 		rsbs	r3, r1, #0
 851 05a0 0130B3E0 		adcs	r3, r3, r1
 512:../lib/fat.c  ****         cluster_count = fs->header.fat_size / sizeof(fat_entry32);
 852              		.loc 1 512 0
 853 05a4 000053E3 		cmp	r3, #0
 510:../lib/fat.c  **** 
 854              		.loc 1 510 0
 855 05a8 10308DE5 		str	r3, [sp, #16]
 856 05ac 143097E5 		ldr	r3, [r7, #20]
 513:../lib/fat.c  ****     else
 857              		.loc 1 513 0
 858 05b0 2331A011 		movne	r3, r3, lsr #2
 516:../lib/fat.c  **** 
 859              		.loc 1 516 0
 860 05b4 A330A001 		moveq	r3, r3, lsr #1
 861 05b8 08308DE5 		str	r3, [sp, #8]
 500:../lib/fat.c  ****     device_write_t device_write = fs->partition->device_write;
 862              		.loc 1 500 0
 863 05bc 14C08DE5 		str	ip, [sp, #20]
 864              	.LVL81:
 865              	.LBB50:
 519:../lib/fat.c  ****     {
 866              		.loc 1 519 0
 867 05c0 08C09DE5 		ldr	ip, [sp, #8]
 868              	.LVL82:
 869              	.LBE50:
 518:../lib/fat.c  ****     for(cluster_t cluster_left = cluster_count; cluster_left > 0; --cluster_left, ++cluster_current
 870              		.loc 1 518 0
 871 05c4 0060A0E3 		mov	r6, #0
 504:../lib/fat.c  ****     cluster_t cluster_next = 0;
 872              		.loc 1 504 0
 873 05c8 309097E5 		ldr	r9, [r7, #48]
 874              	.LVL83:
 875              	.LBB51:
 519:../lib/fat.c  ****     {
 876              		.loc 1 519 0
 877 05cc 0CC08DE5 		str	ip, [sp, #12]
 878              	.LBE51:
 518:../lib/fat.c  ****     for(cluster_t cluster_left = cluster_count; cluster_left > 0; --cluster_left, ++cluster_current
 879              		.loc 1 518 0
 880 05d0 306087E5 		str	r6, [r7, #48]
 881              	.LVL84:
 882              	.LBB52:
 503:../lib/fat.c  ****     cluster_t cluster_current = fs->cluster_free;
 883              		.loc 1 503 0
 884 05d4 0280A0E1 		mov	r8, r2
 519:../lib/fat.c  ****     {
 885              		.loc 1 519 0
 886 05d8 450000EA 		b	.L106
 887              	.LVL85:
 888              	.L122:
 521:../lib/fat.c  ****             cluster_current = 2;
 889              		.loc 1 521 0
 890 05dc 010059E3 		cmp	r9, #1
 891 05e0 08C09DE5 		ldr	ip, [sp, #8]
 892              	.LVL86:
 893 05e4 0030A083 		movhi	r3, #0
 894 05e8 0130A093 		movls	r3, #1
 895 05ec 0C0059E1 		cmp	r9, ip
 896 05f0 01308323 		orrcs	r3, r3, #1
 525:../lib/fat.c  ****         {
 897              		.loc 1 525 0
 898 05f4 10C09DE5 		ldr	ip, [sp, #16]
 522:../lib/fat.c  **** 
 899              		.loc 1 522 0
 900 05f8 000053E3 		cmp	r3, #0
 901 05fc 0290A013 		movne	r9, #2
 902              	.LVL87:
 525:../lib/fat.c  ****         {
 903              		.loc 1 525 0
 904 0600 00005CE3 		cmp	ip, #0
 905 0604 0B00000A 		beq	.L108
 527:../lib/fat.c  ****                 return 0;
 906              		.loc 1 527 0
 907 0608 30009DE8 		ldmia	sp, {r4-r5}
 908 060c 0430A0E3 		mov	r3, #4
 909 0610 9349A5E0 		umlal	r4, r5, r3, r9
 910 0614 1C208DE2 		add	r2, sp, #28
 911 0618 0400A0E1 		mov	r0, r4
 912 061c 0510A0E1 		mov	r1, r5
 913 0620 14C09DE5 		ldr	ip, [sp, #20]
 914 0624 0FE0A0E1 		mov	lr, pc
 915 0628 1CFF2FE1 		bx	ip
 916              	.LVL88:
 917 062c 000050E3 		cmp	r0, #0
 918 0630 4C00001A 		bne	.L151
 919 0634 450000EA 		b	.L159
 920              	.L108:
 533:../lib/fat.c  ****                 return 0;
 921              		.loc 1 533 0
 922 0638 30009DE8 		ldmia	sp, {r4-r5}
 923 063c 0200A0E3 		mov	r0, #2
 924 0640 9049A5E0 		umlal	r4, r5, r0, r9
 925 0644 1A208DE2 		add	r2, sp, #26
 926 0648 0400A0E1 		mov	r0, r4
 927 064c 0510A0E1 		mov	r1, r5
 928 0650 0230A0E3 		mov	r3, #2
 929 0654 14C09DE5 		ldr	ip, [sp, #20]
 930 0658 0FE0A0E1 		mov	lr, pc
 931 065c 1CFF2FE1 		bx	ip
 932              	.LVL89:
 933 0660 000050E3 		cmp	r0, #0
 934 0664 3B00001A 		bne	.L152
 935 0668 380000EA 		b	.L159
 936              	.LVL90:
 937              	.L154:
 548:../lib/fat.c  ****             {
 938              		.loc 1 548 0
 939 066c 000058E3 		cmp	r8, #0
 940 0670 1000000A 		beq	.L157
 941              	.L112:
 555:../lib/fat.c  ****                 fat_entry32 = HTOL32(FAT32_CLUSTER_LAST_MAX);
 942              		.loc 1 555 0
 943 0674 000056E3 		cmp	r6, #0
 556:../lib/fat.c  ****             else
 944              		.loc 1 556 0
 945 0678 0F32E003 		mvneq	r3, #-268435456
 946              	.LVL91:
 558:../lib/fat.c  **** 
 947              		.loc 1 558 0
 948 067c 1C608D15 		strne	r6, [sp, #28]
 556:../lib/fat.c  ****             else
 949              		.loc 1 556 0
 950 0680 1C308D05 		streq	r3, [sp, #28]
 560:../lib/fat.c  ****                 break;
 951              		.loc 1 560 0
 952 0684 0400A0E1 		mov	r0, r4
 953 0688 0510A0E1 		mov	r1, r5
 954 068c 1C208DE2 		add	r2, sp, #28
 955 0690 0430A0E3 		mov	r3, #4
 956              	.L156:
 957 0694 0FE0A0E1 		mov	lr, pc
 958 0698 1AFF2FE1 		bx	sl
 959              	.LVL92:
 960 069c 000050E3 		cmp	r0, #0
 961 06a0 2700000A 		beq	.L124
 962              	.LVL93:
 591:../lib/fat.c  ****     }
 963              		.loc 1 591 0
 964 06a4 018048E2 		sub	r8, r8, #1
 965              	.LVL94:
 966 06a8 0960A0E1 		mov	r6, r9
 967 06ac 0C0000EA 		b	.L117
 968              	.LVL95:
 969              	.L153:
 574:../lib/fat.c  ****             {
 970              		.loc 1 574 0
 971 06b0 000058E3 		cmp	r8, #0
 972 06b4 0100001A 		bne	.L118
 973              	.LVL96:
 974              	.L157:
 576:../lib/fat.c  ****                 break;
 975              		.loc 1 576 0
 976 06b8 309087E5 		str	r9, [r7, #48]
 577:../lib/fat.c  ****             }
 977              		.loc 1 577 0
 978 06bc 110000EA 		b	.L123
 979              	.LVL97:
 980              	.L118:
 581:../lib/fat.c  ****                 fat_entry16 = HTOL16(FAT16_CLUSTER_LAST_MAX);
 981              		.loc 1 581 0
 982 06c0 000056E3 		cmp	r6, #0
 582:../lib/fat.c  ****             else
 983              		.loc 1 582 0
 984 06c4 0030E003 		mvneq	r3, #0
 985              	.LVL98:
 986 06c8 BA31CD01 		streqh	r3, [sp, #26]	@ movhi
 987              	.LVL99:
 584:../lib/fat.c  **** 
 988              		.loc 1 584 0
 989 06cc BA61CD11 		strneh	r6, [sp, #26]	@ movhi
 586:../lib/fat.c  ****                 break;
 990              		.loc 1 586 0
 991 06d0 0400A0E1 		mov	r0, r4
 992 06d4 0510A0E1 		mov	r1, r5
 993 06d8 1A208DE2 		add	r2, sp, #26
 994 06dc 0230A0E3 		mov	r3, #2
 995 06e0 EBFFFFEA 		b	.L156
 996              	.L117:
 519:../lib/fat.c  ****     {
 997              		.loc 1 519 0
 998 06e4 0CC09DE5 		ldr	ip, [sp, #12]
 999 06e8 01C04CE2 		sub	ip, ip, #1
 1000 06ec 0CC08DE5 		str	ip, [sp, #12]
 1001              	.LVL100:
 1002 06f0 019089E2 		add	r9, r9, #1
 1003              	.LVL101:
 1004              	.L106:
 519:../lib/fat.c  ****     {
 1005              		.loc 1 519 0 is_stmt 0 discriminator 1
 1006 06f4 0CC09DE5 		ldr	ip, [sp, #12]
 1007 06f8 00005CE3 		cmp	ip, #0
 1008 06fc B6FFFF1A 		bne	.L122
 1009              	.LBE52:
 596:../lib/fat.c  ****             break;
 1010              		.loc 1 596 0 is_stmt 1
 1011 0700 000058E3 		cmp	r8, #0
 1012 0704 0E00001A 		bne	.L124
 1013              	.L123:
 602:../lib/fat.c  ****         {
 1014              		.loc 1 602 0
 1015 0708 01005BE3 		cmp	fp, #1
 1016 070c 1900009A 		bls	.L137
 605:../lib/fat.c  ****             {
 1017              		.loc 1 605 0
 1018 0710 10C09DE5 		ldr	ip, [sp, #16]
 617:../lib/fat.c  ****                     break;
 1019              		.loc 1 617 0
 1020 0714 03009DE8 		ldmia	sp, {r0-r1}
 605:../lib/fat.c  ****             {
 1021              		.loc 1 605 0
 1022 0718 00005CE3 		cmp	ip, #0
 607:../lib/fat.c  **** 
 1023              		.loc 1 607 0
 1024 071c 20208DE2 		add	r2, sp, #32
 609:../lib/fat.c  ****                     break;
 1025              		.loc 1 609 0
 1026 0720 0430A013 		movne	r3, #4
 617:../lib/fat.c  ****                     break;
 1027              		.loc 1 617 0
 1028 0724 0230A003 		moveq	r3, #2
 607:../lib/fat.c  **** 
 1029              		.loc 1 607 0
 1030 0728 04602215 		strne	r6, [r2, #-4]!
 1031              	.LVL102:
 615:../lib/fat.c  **** 
 1032              		.loc 1 615 0
 1033 072c B6606201 		streqh	r6, [r2, #-6]!	@ movhi
 1034              	.LVL103:
 617:../lib/fat.c  ****                     break;
 1035              		.loc 1 617 0
 1036 0730 930BA1E0 		umlal	r0, r1, r3, fp
 1037 0734 0FE0A0E1 		mov	lr, pc
 1038 0738 1AFF2FE1 		bx	sl
 1039              	.LVL104:
 1040 073c 000050E3 		cmp	r0, #0
 1041 0740 0C00001A 		bne	.L137
 1042              	.LVL105:
 1043              	.L124:
 629:../lib/fat.c  **** 
 1044              		.loc 1 629 0
 1045 0744 0700A0E1 		mov	r0, r7
 1046 0748 0610A0E1 		mov	r1, r6
 1047 074c 21FFFFEB 		bl	fat_free_clusters
 1048              	.LVL106:
 1049              	.L159:
 631:../lib/fat.c  **** }
 1050              		.loc 1 631 0
 1051 0750 0060A0E3 		mov	r6, #0
 1052 0754 070000EA 		b	.L137
 1053              	.LVL107:
 1054              	.L152:
 1055              	.LBB53:
 567:../lib/fat.c  ****                 continue;
 1056              		.loc 1 567 0
 1057 0758 BA31DDE1 		ldrh	r3, [sp, #26]
 1058              	.LVL108:
 1059 075c 000053E3 		cmp	r3, #0
 1060              	.LVL109:
 1061 0760 DFFFFF1A 		bne	.L117
 1062 0764 D1FFFFEA 		b	.L153
 1063              	.LVL110:
 1064              	.L151:
 541:../lib/fat.c  ****                 continue;
 1065              		.loc 1 541 0
 1066 0768 1C309DE5 		ldr	r3, [sp, #28]
 1067 076c 000053E3 		cmp	r3, #0
 1068 0770 DBFFFF1A 		bne	.L117
 1069 0774 BCFFFFEA 		b	.L154
 1070              	.LVL111:
 1071              	.L137:
 1072              	.LBE53:
 632:../lib/fat.c  **** #endif
 1073              		.loc 1 632 0
 1074 0778 0600A0E1 		mov	r0, r6
 1075 077c 20D08DE2 		add	sp, sp, #32
 1076 0780 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1077 0784 1EFF2FE1 		bx	lr
 1078              		.cfi_endproc
 1079              	.LFE4:
 1081              		.align	2
 1083              	fat_cluster_offset:
 1084              	.LFB9:
 832:../lib/fat.c  ****     if(!fs || cluster_num < 2)
 1085              		.loc 1 832 0
 1086              		.cfi_startproc
 1087              		@ Function supports interworking.
 1088              		@ args = 0, pretend = 0, frame = 0
 1089              		@ frame_needed = 0, uses_anonymous_args = 0
 1090              		@ link register save eliminated.
 1091              	.LVL112:
 833:../lib/fat.c  ****         return 0;
 1092              		.loc 1 833 0
 1093 0788 000050E3 		cmp	r0, #0
 1094 078c 01005113 		cmpne	r1, #1
 834:../lib/fat.c  **** 
 1095              		.loc 1 834 0
 1096 0790 0020A093 		movls	r2, #0
 1097 0794 0030A093 		movls	r3, #0
 833:../lib/fat.c  ****         return 0;
 1098              		.loc 1 833 0
 1099              	.LVL113:
 1100              	.LBB56:
 1101              	.LBB57:
 836:../lib/fat.c  **** }
 1102              		.loc 1 836 0
 1103 0798 BAC1D081 		ldrhih	ip, [r0, #26]
 1104 079c 1C308082 		addhi	r3, r0, #28
 1105 07a0 0C009388 		ldmhiia	r3, {r2-r3}
 1106 07a4 02104182 		subhi	r1, r1, #2
 1107              	.LVL114:
 1108 07a8 9C21A380 		umlalhi	r2, r3, ip, r1
 1109 07ac FFFFFFEA 		b	.L161
 1110              	.LVL115:
 1111              	.L161:
 1112              	.LBE57:
 1113              	.LBE56:
 837:../lib/fat.c  **** 
 1114              		.loc 1 837 0
 1115 07b0 0200A0E1 		mov	r0, r2
 1116              	.LVL116:
 1117 07b4 0310A0E1 		mov	r1, r3
 1118 07b8 1EFF2FE1 		bx	lr
 1119              		.cfi_endproc
 1120              	.LFE9:
 1122              		.align	2
 1124              	fat_clear_cluster.part.3:
 1125              	.LFB38:
 794:../lib/fat.c  **** {
 1126              		.loc 1 794 0
 1127              		.cfi_startproc
 1128              		@ Function supports interworking.
 1129              		@ args = 0, pretend = 0, frame = 16
 1130              		@ frame_needed = 0, uses_anonymous_args = 0
 1131              	.LVL117:
 1132 07bc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1133              	.LCFI7:
 1134              		.cfi_def_cfa_offset 16
 1135              		.cfi_offset 4, -16
 1136              		.cfi_offset 5, -12
 1137              		.cfi_offset 6, -8
 1138              		.cfi_offset 14, -4
 1139 07c0 18D04DE2 		sub	sp, sp, #24
 1140              	.LCFI8:
 1141              		.cfi_def_cfa_offset 40
 794:../lib/fat.c  **** {
 1142              		.loc 1 794 0
 1143 07c4 0060A0E1 		mov	r6, r0
 799:../lib/fat.c  **** 
 1144              		.loc 1 799 0
 1145 07c8 EEFFFFEB 		bl	fat_cluster_offset
 1146              	.LVL118:
 802:../lib/fat.c  ****     return fs->partition->device_write_interval(cluster_offset,
 1147              		.loc 1 802 0
 1148 07cc 1020A0E3 		mov	r2, #16
 799:../lib/fat.c  **** 
 1149              		.loc 1 799 0
 1150 07d0 0040A0E1 		mov	r4, r0
 1151 07d4 0150A0E1 		mov	r5, r1
 1152              	.LVL119:
 802:../lib/fat.c  ****     return fs->partition->device_write_interval(cluster_offset,
 1153              		.loc 1 802 0
 1154 07d8 08008DE2 		add	r0, sp, #8
 1155 07dc 0010A0E3 		mov	r1, #0
 1156 07e0 FEFFFFEB 		bl	memset
 1157              	.LVL120:
 803:../lib/fat.c  ****                                                 zero,
 1158              		.loc 1 803 0
 1159 07e4 34209FE5 		ldr	r2, .L164
 1160 07e8 00208DE5 		str	r2, [sp, #0]
 1161 07ec 0020A0E3 		mov	r2, #0
 1162 07f0 04208DE5 		str	r2, [sp, #4]
 1163 07f4 00C096E5 		ldr	ip, [r6, #0]
 1164 07f8 BA31D6E1 		ldrh	r3, [r6, #26]
 1165 07fc 0400A0E1 		mov	r0, r4
 1166 0800 0510A0E1 		mov	r1, r5
 1167 0804 08208DE2 		add	r2, sp, #8
 1168 0808 0CC09CE5 		ldr	ip, [ip, #12]
 1169 080c 0FE0A0E1 		mov	lr, pc
 1170 0810 1CFF2FE1 		bx	ip
 1171              	.LVL121:
 809:../lib/fat.c  **** #endif
 1172              		.loc 1 809 0
 1173 0814 18D08DE2 		add	sp, sp, #24
 1174 0818 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 1175 081c 1EFF2FE1 		bx	lr
 1176              	.L165:
 1177              		.align	2
 1178              	.L164:
 1179 0820 00000000 		.word	fat_clear_cluster_callback
 1180              		.cfi_endproc
 1181              	.LFE38:
 1183              		.global	__divsi3
 1184              		.align	2
 1186              	fat_write_dir_entry:
 1187              	.LFB24:
1873:../lib/fat.c  ****     if(!fs || !dir_entry)
 1188              		.loc 1 1873 0
 1189              		.cfi_startproc
 1190              		@ Function supports interworking.
 1191              		@ args = 0, pretend = 0, frame = 36
 1192              		@ frame_needed = 0, uses_anonymous_args = 0
 1193              	.LVL122:
 1194 0824 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1195              	.LCFI9:
 1196              		.cfi_def_cfa_offset 36
 1197              		.cfi_offset 4, -36
 1198              		.cfi_offset 5, -32
 1199              		.cfi_offset 6, -28
 1200              		.cfi_offset 7, -24
 1201              		.cfi_offset 8, -20
 1202              		.cfi_offset 9, -16
 1203              		.cfi_offset 10, -12
 1204              		.cfi_offset 11, -8
 1205              		.cfi_offset 14, -4
1874:../lib/fat.c  ****         return 0;
 1206              		.loc 1 1874 0
 1207 0828 000050E3 		cmp	r0, #0
 1208 082c 00005113 		cmpne	r1, #0
1873:../lib/fat.c  ****     if(!fs || !dir_entry)
 1209              		.loc 1 1873 0
 1210 0830 24D04DE2 		sub	sp, sp, #36
 1211              	.LCFI10:
 1212              		.cfi_def_cfa_offset 72
1874:../lib/fat.c  ****         return 0;
 1213              		.loc 1 1874 0
 1214 0834 0160A0E1 		mov	r6, r1
1875:../lib/fat.c  ****     
 1215              		.loc 1 1875 0
 1216 0838 0000A003 		moveq	r0, #0
 1217              	.LVL123:
1874:../lib/fat.c  ****         return 0;
 1218              		.loc 1 1874 0
 1219 083c 9A00000A 		beq	.L167
 1220              	.LVL124:
 1221              	.LBB64:
 1222              	.LBB65:
1892:../lib/fat.c  ****     offset_t offset = dir_entry->entry_offset;
 1223              		.loc 1 1892 0
 1224 0840 003090E5 		ldr	r3, [r0, #0]
1895:../lib/fat.c  **** #if FAT_LFN_SUPPORT
 1225              		.loc 1 1895 0
 1226 0844 0100A0E1 		mov	r0, r1
 1227              	.LVL125:
1892:../lib/fat.c  ****     offset_t offset = dir_entry->entry_offset;
 1228              		.loc 1 1892 0
 1229 0848 08A093E5 		ldr	sl, [r3, #8]
 1230              	.LVL126:
1893:../lib/fat.c  ****     const char* name = dir_entry->long_name;
 1231              		.loc 1 1893 0
 1232 084c 2C5081E2 		add	r5, r1, #44
 1233 0850 300095E8 		ldmia	r5, {r4-r5}
 1234              	.LVL127:
1895:../lib/fat.c  **** #if FAT_LFN_SUPPORT
 1235              		.loc 1 1895 0
 1236 0854 FEFFFFEB 		bl	strlen
 1237              	.LVL128:
 1238 0858 FF8000E2 		and	r8, r0, #255
 1239              	.LVL129:
1897:../lib/fat.c  **** #endif
 1240              		.loc 1 1897 0
 1241 085c 0D10A0E3 		mov	r1, #13
 1242 0860 0C0088E2 		add	r0, r8, #12
 1243 0864 FEFFFFEB 		bl	__divsi3
 1244              	.LVL130:
1904:../lib/fat.c  ****     char* name_ext = strrchr(name, '.');
 1245              		.loc 1 1904 0
 1246 0868 2010A0E3 		mov	r1, #32
 1247 086c 0B20A0E3 		mov	r2, #11
1897:../lib/fat.c  **** #endif
 1248              		.loc 1 1897 0
 1249 0870 FF7000E2 		and	r7, r0, #255
 1250              	.LVL131:
1904:../lib/fat.c  ****     char* name_ext = strrchr(name, '.');
 1251              		.loc 1 1904 0
 1252 0874 04008DE2 		add	r0, sp, #4
 1253 0878 FEFFFFEB 		bl	memset
 1254              	.LVL132:
1905:../lib/fat.c  ****     if(name_ext && *++name_ext)
 1255              		.loc 1 1905 0
 1256 087c 0600A0E1 		mov	r0, r6
 1257 0880 2E10A0E3 		mov	r1, #46
 1258 0884 FEFFFFEB 		bl	strrchr
 1259              	.LVL133:
1906:../lib/fat.c  ****     {
 1260              		.loc 1 1906 0
 1261 0888 000050E3 		cmp	r0, #0
 1262 088c 0E00000A 		beq	.L168
 1263              	.LVL134:
 1264 0890 0130D0E5 		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 1265 0894 000053E3 		cmp	r3, #0
 1266 0898 0B00000A 		beq	.L168
 1267 089c 019080E2 		add	r9, r0, #1
 1268              	.LVL135:
 1269              	.LBB66:
1908:../lib/fat.c  ****         name_len -= name_ext_len + 1;
 1270              		.loc 1 1908 0
 1271 08a0 0900A0E1 		mov	r0, r9
 1272 08a4 FEFFFFEB 		bl	strlen
 1273              	.LVL136:
 1274 08a8 FF2000E2 		and	r2, r0, #255
 1275              	.LVL137:
1909:../lib/fat.c  **** 
 1276              		.loc 1 1909 0
 1277 08ac 0230E0E1 		mvn	r3, r2
 1278 08b0 038088E0 		add	r8, r8, r3
 1279              	.LVL138:
1918:../lib/fat.c  ****     }
 1280              		.loc 1 1918 0
 1281 08b4 0C008DE2 		add	r0, sp, #12
 1282 08b8 0910A0E1 		mov	r1, r9
 1283 08bc 030052E3 		cmp	r2, #3
 1284 08c0 0320A023 		movcs	r2, #3
 1285              	.LVL139:
1909:../lib/fat.c  **** 
 1286              		.loc 1 1909 0
 1287 08c4 FF8008E2 		and	r8, r8, #255
 1288              	.LVL140:
1918:../lib/fat.c  ****     }
 1289              		.loc 1 1918 0
 1290 08c8 FEFFFFEB 		bl	memcpy
 1291              	.LVL141:
 1292              	.L168:
 1293              	.LBE66:
1921:../lib/fat.c  ****     {
 1294              		.loc 1 1921 0
 1295 08cc 080058E3 		cmp	r8, #8
1923:../lib/fat.c  **** 
 1296              		.loc 1 1923 0
 1297 08d0 04008DE2 		add	r0, sp, #4
 1298 08d4 0610A0E1 		mov	r1, r6
1921:../lib/fat.c  ****     {
 1299              		.loc 1 1921 0
 1300 08d8 0A00008A 		bhi	.L169
 1301              	.LVL142:
1923:../lib/fat.c  **** 
 1302              		.loc 1 1923 0
 1303 08dc 0820A0E1 		mov	r2, r8
 1304 08e0 FEFFFFEB 		bl	memcpy
 1305              	.LVL143:
1935:../lib/fat.c  ****            ((name[1] == '.' && name[2] == '\0') ||
 1306              		.loc 1 1935 0
 1307 08e4 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 1308 08e8 2E0053E3 		cmp	r3, #46
 1309 08ec 1300001A 		bne	.L170
1936:../lib/fat.c  ****             name[1] == '\0')
 1310              		.loc 1 1936 0
 1311 08f0 0130D6E5 		ldrb	r3, [r6, #1]	@ zero_extendqisi2
1935:../lib/fat.c  ****            ((name[1] == '.' && name[2] == '\0') ||
 1312              		.loc 1 1935 0
 1313 08f4 2E0053E3 		cmp	r3, #46
1936:../lib/fat.c  ****             name[1] == '\0')
 1314              		.loc 1 1936 0
 1315 08f8 0230D605 		ldreqb	r3, [r6, #2]	@ zero_extendqisi2
1939:../lib/fat.c  **** #endif
 1316              		.loc 1 1939 0
 1317 08fc 000053E3 		cmp	r3, #0
 1318 0900 0070A003 		moveq	r7, #0
 1319              	.LVL144:
 1320 0904 0D0000EA 		b	.L170
 1321              	.LVL145:
 1322              	.L169:
 1323              	.LBB67:
1945:../lib/fat.c  **** 
 1324              		.loc 1 1945 0
 1325 0908 0820A0E3 		mov	r2, #8
 1326 090c FEFFFFEB 		bl	memcpy
 1327              	.LVL146:
1950:../lib/fat.c  **** 
 1328              		.loc 1 1950 0
 1329 0910 243096E5 		ldr	r3, [r6, #36]
 1330 0914 FF2003E2 		and	r2, r3, #255
 1331              	.LVL147:
1952:../lib/fat.c  ****         num &= 0x0f;
 1332              		.loc 1 1952 0
 1333 0918 9F0052E3 		cmp	r2, #159
 1334              	.LBE67:
 1335              	.LBE65:
1953:../lib/fat.c  ****         buffer[7] = (num < 0x0a) ? ('0' + num) : ('a' + num);
 1336              		.loc 1 1953 0
 1337 091c 0F3003E2 		and	r3, r3, #15
 1338              	.LVL148:
 1339 0920 2222A0E1 		mov	r2, r2, lsr #4
 1340              	.LBB72:
 1341              	.LBB68:
1952:../lib/fat.c  ****         num &= 0x0f;
 1342              		.loc 1 1952 0
 1343 0924 30208292 		addls	r2, r2, #48
 1344 0928 61208282 		addhi	r2, r2, #97
1954:../lib/fat.c  **** #else
 1345              		.loc 1 1954 0
 1346 092c 090053E3 		cmp	r3, #9
 1347 0930 30308392 		addls	r3, r3, #48
 1348              	.LVL149:
 1349 0934 61308382 		addhi	r3, r3, #97
1952:../lib/fat.c  ****         num &= 0x0f;
 1350              		.loc 1 1952 0
 1351 0938 0A20CDE5 		strb	r2, [sp, #10]
1954:../lib/fat.c  **** #else
 1352              		.loc 1 1954 0
 1353 093c 0B30CDE5 		strb	r3, [sp, #11]
 1354              	.LVL150:
 1355              	.L170:
 1356              	.LBE68:
1959:../lib/fat.c  ****         buffer[0] = 0x05;
 1357              		.loc 1 1959 0
 1358 0940 0430DDE5 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
1963:../lib/fat.c  ****     buffer[0x0b] = dir_entry->attributes;
 1359              		.loc 1 1963 0
 1360 0944 04908DE2 		add	r9, sp, #4
1959:../lib/fat.c  ****         buffer[0] = 0x05;
 1361              		.loc 1 1959 0
 1362 0948 E50053E3 		cmp	r3, #229
1960:../lib/fat.c  **** 
 1363              		.loc 1 1960 0
 1364 094c 0530A003 		moveq	r3, #5
1963:../lib/fat.c  ****     buffer[0x0b] = dir_entry->attributes;
 1365              		.loc 1 1963 0
 1366 0950 1520A0E3 		mov	r2, #21
 1367 0954 0010A0E3 		mov	r1, #0
 1368 0958 0B0089E2 		add	r0, r9, #11
1960:../lib/fat.c  **** 
 1369              		.loc 1 1960 0
 1370 095c 0430CD05 		streqb	r3, [sp, #4]
1963:../lib/fat.c  ****     buffer[0x0b] = dir_entry->attributes;
 1371              		.loc 1 1963 0
 1372 0960 FEFFFFEB 		bl	memset
 1373              	.LVL151:
1964:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
 1374              		.loc 1 1964 0
 1375 0964 2030D6E5 		ldrb	r3, [r6, #32]	@ zero_extendqisi2
1970:../lib/fat.c  **** #endif
 1376              		.loc 1 1970 0
 1377 0968 140089E2 		add	r0, r9, #20
 1378 096c B612D6E1 		ldrh	r1, [r6, #38]
1964:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
 1379              		.loc 1 1964 0
 1380 0970 0F30CDE5 		strb	r3, [sp, #15]
1970:../lib/fat.c  **** #endif
 1381              		.loc 1 1970 0
 1382 0974 FEFFFFEB 		bl	write16
 1383              	.LVL152:
1972:../lib/fat.c  ****     write32(&buffer[0x1c], dir_entry->file_size);
 1384              		.loc 1 1972 0
 1385 0978 1A0089E2 		add	r0, r9, #26
 1386 097c B412D6E1 		ldrh	r1, [r6, #36]
 1387 0980 FEFFFFEB 		bl	write16
 1388              	.LVL153:
1973:../lib/fat.c  **** 
 1389              		.loc 1 1973 0
 1390 0984 1C0089E2 		add	r0, r9, #28
 1391 0988 281096E5 		ldr	r1, [r6, #40]
 1392 098c FEFFFFEB 		bl	write32
 1393              	.LVL154:
1977:../lib/fat.c  **** #else
 1394              		.loc 1 1977 0
 1395 0990 2030A0E3 		mov	r3, #32
 1396 0994 0400A0E1 		mov	r0, r4
 1397 0998 0510A0E1 		mov	r1, r5
 1398 099c 9307A1E0 		umlal	r0, r1, r3, r7
 1399 09a0 0920A0E1 		mov	r2, r9
 1400 09a4 0FE0A0E1 		mov	lr, pc
 1401 09a8 1AFF2FE1 		bx	sl
 1402              	.LVL155:
 1403 09ac 000050E3 		cmp	r0, #0
 1404 09b0 3D00000A 		beq	.L167
1985:../lib/fat.c  ****     
 1405              		.loc 1 1985 0
 1406 09b4 0900A0E1 		mov	r0, r9
 1407 09b8 92FDFFEB 		bl	fat_calc_83_checksum
 1408              	.LVL156:
 1409 09bc 0780A0E1 		mov	r8, r7
 1410              	.LVL157:
 1411 09c0 00008DE5 		str	r0, [sp, #0]
 1412              	.LVL158:
 1413              	.LBB69:
 1414              	.LBB70:
1998:../lib/fat.c  **** 
 1415              		.loc 1 1998 0
 1416 09c4 00B0A0E3 		mov	fp, #0
 1417 09c8 330000EA 		b	.L178
 1418              	.LVL159:
 1419              	.L186:
1990:../lib/fat.c  ****         
 1420              		.loc 1 1990 0
 1421 09cc 2020A0E3 		mov	r2, #32
 1422 09d0 0900A0E1 		mov	r0, r9
 1423 09d4 FF10A0E3 		mov	r1, #255
 1424 09d8 FEFFFFEB 		bl	memset
 1425              	.LVL160:
1993:../lib/fat.c  ****         uint8_t i = 1;
 1426              		.loc 1 1993 0
 1427 09dc 013048E2 		sub	r3, r8, #1
 1428 09e0 0D20A0E3 		mov	r2, #13
 1429 09e4 936222E0 		mla	r2, r3, r2, r6
1994:../lib/fat.c  ****         while(i < 0x1f)
 1430              		.loc 1 1994 0
 1431 09e8 0130A0E3 		mov	r3, #1
 1432              	.LVL161:
 1433              	.L183:
1997:../lib/fat.c  ****             buffer[i++] = 0;
 1434              		.loc 1 1997 0
 1435 09ec 0100D2E4 		ldrb	r0, [r2], #1	@ zero_extendqisi2
 1436 09f0 24C08DE2 		add	ip, sp, #36
 1437 09f4 03108CE0 		add	r1, ip, r3
 1438 09f8 200041E5 		strb	r0, [r1, #-32]
 1439              	.LVL162:
 1440 09fc 011083E2 		add	r1, r3, #1
1998:../lib/fat.c  **** 
 1441              		.loc 1 1998 0
 1442 0a00 023083E2 		add	r3, r3, #2
 1443              	.LVL163:
 1444 0a04 FF3003E2 		and	r3, r3, #255
 1445              	.LVL164:
 1446 0a08 FF1001E2 		and	r1, r1, #255
 1447 0a0c 01108CE0 		add	r1, ip, r1
2000:../lib/fat.c  ****             {
 1448              		.loc 1 2000 0
 1449 0a10 0B0053E3 		cmp	r3, #11
1998:../lib/fat.c  **** 
 1450              		.loc 1 1998 0
 1451 0a14 20B041E5 		strb	fp, [r1, #-32]
2003:../lib/fat.c  ****                     break;
 1452              		.loc 1 2003 0
 1453 0a18 0E30A003 		moveq	r3, #14
 1454              	.LVL165:
2000:../lib/fat.c  ****             {
 1455              		.loc 1 2000 0
 1456 0a1c 0200000A 		beq	.L179
2006:../lib/fat.c  ****                     break;
 1457              		.loc 1 2006 0
 1458 0a20 1A0053E3 		cmp	r3, #26
 1459 0a24 1C30A003 		moveq	r3, #28
 1460 0a28 FFFFFFEA 		b	.L179
 1461              	.L179:
 1462              	.LVL166:
2010:../lib/fat.c  ****                 break;
 1463              		.loc 1 2010 0
 1464 0a2c 011052E5 		ldrb	r1, [r2, #-1]	@ zero_extendqisi2
 1465 0a30 000051E3 		cmp	r1, #0
 1466 0a34 0100000A 		beq	.L182
1995:../lib/fat.c  ****         {
 1467              		.loc 1 1995 0
 1468 0a38 1E0053E3 		cmp	r3, #30
 1469 0a3c EAFFFF9A 		bls	.L183
 1470              	.L182:
2016:../lib/fat.c  ****             buffer[0x00] |= FAT_DIRENTRY_LFNLAST;
 1471              		.loc 1 2016 0
 1472 0a40 070058E1 		cmp	r8, r7
2017:../lib/fat.c  **** 
 1473              		.loc 1 2017 0
 1474 0a44 40308803 		orreq	r3, r8, #64
 1475              	.LVL167:
2023:../lib/fat.c  **** 
 1476              		.loc 1 2023 0
 1477 0a48 00C09DE5 		ldr	ip, [sp, #0]
2017:../lib/fat.c  **** 
 1478              		.loc 1 2017 0
 1479 0a4c 0430CD05 		streqb	r3, [sp, #4]
2020:../lib/fat.c  **** 
 1480              		.loc 1 2020 0
 1481 0a50 0F30A0E3 		mov	r3, #15
2015:../lib/fat.c  ****         if(lfn_entry == lfn_entry_count)
 1482              		.loc 1 2015 0
 1483 0a54 0480CD15 		strneb	r8, [sp, #4]
2020:../lib/fat.c  **** 
 1484              		.loc 1 2020 0
 1485 0a58 0F30CDE5 		strb	r3, [sp, #15]
2031:../lib/fat.c  ****     
 1486              		.loc 1 2031 0
 1487 0a5c 0400A0E1 		mov	r0, r4
 1488 0a60 0510A0E1 		mov	r1, r5
 1489 0a64 0920A0E1 		mov	r2, r9
 1490 0a68 2030A0E3 		mov	r3, #32
2023:../lib/fat.c  **** 
 1491              		.loc 1 2023 0
 1492 0a6c 11C0CDE5 		strb	ip, [sp, #17]
2026:../lib/fat.c  ****         buffer[0x1a] = 0;
 1493              		.loc 1 2026 0
 1494 0a70 10B0CDE5 		strb	fp, [sp, #16]
2027:../lib/fat.c  ****         buffer[0x1b] = 0;
 1495              		.loc 1 2027 0
 1496 0a74 1EB0CDE5 		strb	fp, [sp, #30]
2028:../lib/fat.c  **** 
 1497              		.loc 1 2028 0
 1498 0a78 1FB0CDE5 		strb	fp, [sp, #31]
2031:../lib/fat.c  ****     
 1499              		.loc 1 2031 0
 1500 0a7c 0FE0A0E1 		mov	lr, pc
 1501 0a80 1AFF2FE1 		bx	sl
 1502              	.LVL168:
2033:../lib/fat.c  ****     }
 1503              		.loc 1 2033 0
 1504 0a84 2020A0E3 		mov	r2, #32
 1505 0a88 0030A0E3 		mov	r3, #0
 1506 0a8c 024094E0 		adds	r4, r4, r2
 1507              	.LVL169:
 1508              	.LBE70:
1988:../lib/fat.c  ****     {
 1509              		.loc 1 1988 0
 1510 0a90 018048E2 		sub	r8, r8, #1
 1511              	.LVL170:
 1512              	.LBB71:
2033:../lib/fat.c  ****     }
 1513              		.loc 1 2033 0
 1514 0a94 0350A5E0 		adc	r5, r5, r3
 1515              	.LVL171:
 1516              	.LBE71:
1988:../lib/fat.c  ****     {
 1517              		.loc 1 1988 0
 1518 0a98 FF8008E2 		and	r8, r8, #255
 1519              	.LVL172:
 1520              	.L178:
 1521 0a9c 000058E3 		cmp	r8, #0
 1522 0aa0 C9FFFF1A 		bne	.L186
2037:../lib/fat.c  **** }
 1523              		.loc 1 2037 0
 1524 0aa4 0100A0E3 		mov	r0, #1
 1525 0aa8 FFFFFFEA 		b	.L167
 1526              	.LVL173:
 1527              	.L167:
 1528              	.LBE69:
 1529              	.LBE72:
 1530              	.LBE64:
2038:../lib/fat.c  **** #endif
 1531              		.loc 1 2038 0
 1532 0aac 24D08DE2 		add	sp, sp, #36
 1533 0ab0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1534 0ab4 1EFF2FE1 		bx	lr
 1535              		.cfi_endproc
 1536              	.LFE24:
 1538              		.global	__udivsi3
 1539              		.align	2
 1541              	fat_find_offset_for_dir_entry.part.4:
 1542              	.LFB39:
1743:../lib/fat.c  **** {
 1543              		.loc 1 1743 0
 1544              		.cfi_startproc
 1545              		@ Function supports interworking.
 1546              		@ args = 0, pretend = 0, frame = 16
 1547              		@ frame_needed = 0, uses_anonymous_args = 0
 1548              	.LVL174:
 1549 0ab8 FF4F2DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1550              	.LCFI11:
 1551              		.cfi_def_cfa_offset 52
 1552              		.cfi_offset 0, -52
 1553              		.cfi_offset 1, -48
 1554              		.cfi_offset 2, -44
 1555              		.cfi_offset 3, -40
 1556              		.cfi_offset 4, -36
 1557              		.cfi_offset 5, -32
 1558              		.cfi_offset 6, -28
 1559              		.cfi_offset 7, -24
 1560              		.cfi_offset 8, -20
 1561              		.cfi_offset 9, -16
 1562              		.cfi_offset 10, -12
 1563              		.cfi_offset 11, -8
 1564              		.cfi_offset 14, -4
1743:../lib/fat.c  **** {
 1565              		.loc 1 1743 0
 1566 0abc 0080A0E1 		mov	r8, r0
1750:../lib/fat.c  ****     uint8_t free_dir_entries_found = 0;
 1567              		.loc 1 1750 0
 1568 0ac0 0200A0E1 		mov	r0, r2
 1569              	.LVL175:
1743:../lib/fat.c  **** {
 1570              		.loc 1 1743 0
 1571 0ac4 0140A0E1 		mov	r4, r1
1750:../lib/fat.c  ****     uint8_t free_dir_entries_found = 0;
 1572              		.loc 1 1750 0
 1573 0ac8 FEFFFFEB 		bl	strlen
 1574              	.LVL176:
 1575 0acc 0D10A0E3 		mov	r1, #13
 1576 0ad0 0C0080E2 		add	r0, r0, #12
 1577 0ad4 FEFFFFEB 		bl	__udivsi3
 1578              	.LVL177:
1753:../lib/fat.c  ****     offset_t dir_entry_offset = 0;
 1579              		.loc 1 1753 0
 1580 0ad8 28A094E5 		ldr	sl, [r4, #40]
1750:../lib/fat.c  ****     uint8_t free_dir_entries_found = 0;
 1581              		.loc 1 1750 0
 1582 0adc 010080E2 		add	r0, r0, #1
1758:../lib/fat.c  **** #endif
 1583              		.loc 1 1758 0
 1584 0ae0 003098E5 		ldr	r3, [r8, #0]
1750:../lib/fat.c  ****     uint8_t free_dir_entries_found = 0;
 1585              		.loc 1 1750 0
 1586 0ae4 FF0000E2 		and	r0, r0, #255
1761:../lib/fat.c  ****     {
 1587              		.loc 1 1761 0
 1588 0ae8 00005AE3 		cmp	sl, #0
1750:../lib/fat.c  ****     uint8_t free_dir_entries_found = 0;
 1589              		.loc 1 1750 0
 1590 0aec 08008DE5 		str	r0, [sp, #8]
 1591              	.LVL178:
1758:../lib/fat.c  **** #endif
 1592              		.loc 1 1758 0
 1593 0af0 1030D3E5 		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1594              	.LVL179:
1761:../lib/fat.c  ****     {
 1595              		.loc 1 1761 0
 1596 0af4 0700001A 		bne	.L212
1764:../lib/fat.c  ****         {
 1597              		.loc 1 1764 0
 1598 0af8 0B0053E3 		cmp	r3, #11
1766:../lib/fat.c  ****         }
 1599              		.loc 1 1766 0
 1600 0afc 2CA09805 		ldreq	sl, [r8, #44]
 1601              	.LVL180:
1764:../lib/fat.c  ****         {
 1602              		.loc 1 1764 0
 1603 0b00 0400000A 		beq	.L212
 1604              	.L203:
1772:../lib/fat.c  ****             offset_to = fs->header.cluster_zero_offset;
 1605              		.loc 1 1772 0
 1606 0b04 245088E2 		add	r5, r8, #36
 1607 0b08 300095E8 		ldmia	r5, {r4-r5}
 1608              	.LVL181:
1773:../lib/fat.c  ****             dir_entry_offset = offset;
 1609              		.loc 1 1773 0
 1610 0b0c 1CC088E2 		add	ip, r8, #28
 1611 0b10 00189CE8 		ldmia	ip, {fp-ip}
 1612              	.LVL182:
 1613 0b14 030000EA 		b	.L202
 1614              	.LVL183:
 1615              	.L212:
1756:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 1616              		.loc 1 1756 0
 1617 0b18 00B0A0E3 		mov	fp, #0
 1618 0b1c 00C0A0E3 		mov	ip, #0
1754:../lib/fat.c  ****     offset_t offset = 0;
 1619              		.loc 1 1754 0
 1620 0b20 0B40A0E1 		mov	r4, fp
 1621              	.LVL184:
 1622 0b24 0C50A0E1 		mov	r5, ip
 1623              	.LVL185:
 1624              	.L202:
 1625 0b28 0090A0E3 		mov	r9, #0
 1626 0b2c 00908DE5 		str	r9, [sp, #0]
 1627 0b30 0460A0E1 		mov	r6, r4
 1628 0b34 0570A0E1 		mov	r7, r5
 1629              	.LVL186:
 1630              	.L226:
 1631              	.LBB77:
1780:../lib/fat.c  ****         {
 1632              		.loc 1 1780 0
 1633 0b38 0C0055E1 		cmp	r5, ip
 1634              		it eq
 1635 0b3c 0B005401 		cmpeq	r4, fp
 1636 0b40 2500001A 		bne	.L204
1782:../lib/fat.c  ****                 /* We iterated through the whole root directory and
 1637              		.loc 1 1782 0
 1638 0b44 00005AE3 		cmp	sl, #0
 1639 0b48 4900000A 		beq	.L205
1788:../lib/fat.c  ****             {
 1640              		.loc 1 1788 0
 1641 0b4c 052094E1 		orrs	r2, r4, r5
 1642 0b50 1500000A 		beq	.L206
 1643              	.LBB78:
1794:../lib/fat.c  ****                 if(!cluster_next)
 1644              		.loc 1 1794 0
 1645 0b54 0800A0E1 		mov	r0, r8
 1646 0b58 0A10A0E1 		mov	r1, sl
 1647 0b5c E8FDFFEB 		bl	fat_get_next_cluster
 1648              	.LVL187:
1795:../lib/fat.c  ****                 {
 1649              		.loc 1 1795 0
 1650 0b60 000050E3 		cmp	r0, #0
 1651 0b64 0F00001A 		bne	.L213
1797:../lib/fat.c  ****                     if(!cluster_next)
 1652              		.loc 1 1797 0
 1653 0b68 0A10A0E1 		mov	r1, sl
 1654 0b6c 0800A0E1 		mov	r0, r8
 1655              	.LVL188:
 1656 0b70 0120A0E3 		mov	r2, #1
 1657 0b74 7BFEFFEB 		bl	fat_append_clusters
 1658              	.LVL189:
1798:../lib/fat.c  ****                         return 0;
 1659              		.loc 1 1798 0
 1660 0b78 001050E2 		subs	r1, r0, #0
 1661 0b7c 3C00000A 		beq	.L205
1803:../lib/fat.c  **** 
 1662              		.loc 1 1803 0
 1663 0b80 BA31D8E1 		ldrh	r3, [r8, #26]
1802:../lib/fat.c  ****                                        (offset_t) (cluster_next - 2) * fs->header.cluster_size;
 1664              		.loc 1 1802 0
 1665 0b84 1C7088E2 		add	r7, r8, #28
 1666 0b88 C00097E8 		ldmia	r7, {r6-r7}
1803:../lib/fat.c  **** 
 1667              		.loc 1 1803 0
 1668 0b8c 022041E2 		sub	r2, r1, #2
 1669              	.LBB79:
 1670              	.LBB80:
 796:../lib/fat.c  ****         return 0;
 1671              		.loc 1 796 0
 1672 0b90 010051E3 		cmp	r1, #1
 1673              	.LBE80:
 1674              	.LBE79:
1802:../lib/fat.c  ****                                        (offset_t) (cluster_next - 2) * fs->header.cluster_size;
 1675              		.loc 1 1802 0
 1676 0b94 9362A7E0 		umlal	r6, r7, r3, r2
 1677              	.LVL190:
 1678              	.LBB82:
 1679              	.LBB81:
 796:../lib/fat.c  ****         return 0;
 1680              		.loc 1 796 0
 1681 0b98 3700009A 		bls	.L211
 1682 0b9c 0800A0E1 		mov	r0, r8
 1683              	.LVL191:
 1684 0ba0 05FFFFEB 		bl	fat_clear_cluster.part.3
 1685              	.LVL192:
 1686 0ba4 340000EA 		b	.L211
 1687              	.LVL193:
 1688              	.L213:
 1689              	.LBE81:
 1690              	.LBE82:
1795:../lib/fat.c  ****                 {
 1691              		.loc 1 1795 0
 1692 0ba8 00A0A0E1 		mov	sl, r0
 1693              	.LVL194:
 1694              	.L206:
 1695              	.LBE78:
1813:../lib/fat.c  ****             offset_to = offset + fs->header.cluster_size;
 1696              		.loc 1 1813 0
 1697 0bac 0800A0E1 		mov	r0, r8
 1698 0bb0 0A10A0E1 		mov	r1, sl
 1699 0bb4 F3FEFFEB 		bl	fat_cluster_offset
 1700              	.LVL195:
1814:../lib/fat.c  ****             dir_entry_offset = offset;
 1701              		.loc 1 1814 0
 1702 0bb8 BA31D8E1 		ldrh	r3, [r8, #26]
1817:../lib/fat.c  **** #endif
 1703              		.loc 1 1817 0
 1704 0bbc 0090A0E3 		mov	r9, #0
1814:../lib/fat.c  ****             dir_entry_offset = offset;
 1705              		.loc 1 1814 0
 1706 0bc0 03B090E0 		adds	fp, r0, r3
 1707              	.LVL196:
1817:../lib/fat.c  **** #endif
 1708              		.loc 1 1817 0
 1709 0bc4 00908DE5 		str	r9, [sp, #0]
1813:../lib/fat.c  ****             offset_to = offset + fs->header.cluster_size;
 1710              		.loc 1 1813 0
 1711 0bc8 0040A0E1 		mov	r4, r0
 1712              	.LVL197:
 1713 0bcc 0150A0E1 		mov	r5, r1
 1714              	.LVL198:
1814:../lib/fat.c  ****             dir_entry_offset = offset;
 1715              		.loc 1 1814 0
 1716 0bd0 00C0A1E2 		adc	ip, r1, #0
 1717              	.LVL199:
1815:../lib/fat.c  **** #if FAT_LFN_SUPPORT
 1718              		.loc 1 1815 0
 1719 0bd4 0060A0E1 		mov	r6, r0
 1720 0bd8 0170A0E1 		mov	r7, r1
 1721              	.LVL200:
 1722              	.L204:
1823:../lib/fat.c  ****             return 0;
 1723              		.loc 1 1823 0
 1724 0bdc 04C08DE5 		str	ip, [sp, #4]
 1725 0be0 0400A0E1 		mov	r0, r4
 1726 0be4 0510A0E1 		mov	r1, r5
 1727 0be8 0F208DE2 		add	r2, sp, #15
 1728 0bec 0130A0E3 		mov	r3, #1
 1729 0bf0 009098E5 		ldr	r9, [r8, #0]
 1730 0bf4 00C099E5 		ldr	ip, [r9, #0]
 1731 0bf8 0FE0A0E1 		mov	lr, pc
 1732 0bfc 1CFF2FE1 		bx	ip
 1733              	.LVL201:
 1734 0c00 000050E3 		cmp	r0, #0
 1735 0c04 04C09DE5 		ldr	ip, [sp, #4]
 1736 0c08 1900000A 		beq	.L205
1827:../lib/fat.c  ****         {
 1737              		.loc 1 1827 0
 1738 0c0c 0F30DDE5 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 1739 0c10 E50053E3 		cmp	r3, #229
 1740 0c14 00005313 		cmpne	r3, #0
 1741 0c18 0030A013 		movne	r3, #0
 1742 0c1c 0130A003 		moveq	r3, #1
 1743 0c20 0B00001A 		bne	.L208
1831:../lib/fat.c  ****             if(free_dir_entries_found >= free_dir_entries_needed)
 1744              		.loc 1 1831 0
 1745 0c24 00209DE5 		ldr	r2, [sp, #0]
1832:../lib/fat.c  **** #endif
 1746              		.loc 1 1832 0
 1747 0c28 08309DE5 		ldr	r3, [sp, #8]
1831:../lib/fat.c  ****             if(free_dir_entries_found >= free_dir_entries_needed)
 1748              		.loc 1 1831 0
 1749 0c2c 019082E2 		add	r9, r2, #1
 1750 0c30 FF9009E2 		and	r9, r9, #255
1832:../lib/fat.c  **** #endif
 1751              		.loc 1 1832 0
 1752 0c34 030059E1 		cmp	r9, r3
1831:../lib/fat.c  ****             if(free_dir_entries_found >= free_dir_entries_needed)
 1753              		.loc 1 1831 0
 1754 0c38 00908DE5 		str	r9, [sp, #0]
1832:../lib/fat.c  **** #endif
 1755              		.loc 1 1832 0
 1756 0c3c 0E00002A 		bcs	.L211
1836:../lib/fat.c  ****         }
 1757              		.loc 1 1836 0
 1758 0c40 2020A0E3 		mov	r2, #32
 1759 0c44 0030A0E3 		mov	r3, #0
 1760 0c48 024094E0 		adds	r4, r4, r2
 1761              	.LVL202:
 1762 0c4c 0350A5E0 		adc	r5, r5, r3
 1763              	.LVL203:
 1764 0c50 B8FFFFEA 		b	.L226
 1765              	.L208:
1840:../lib/fat.c  ****             dir_entry_offset = offset;
 1766              		.loc 1 1840 0
 1767 0c54 2060A0E3 		mov	r6, #32
 1768 0c58 046096E0 		adds	r6, r6, r4
 1769 0c5c 0070A0E3 		mov	r7, #0
 1770 0c60 0570A7E0 		adc	r7, r7, r5
 1771              	.LVL204:
 1772 0c64 0640A0E1 		mov	r4, r6
 1773 0c68 0750A0E1 		mov	r5, r7
1843:../lib/fat.c  **** #endif
 1774              		.loc 1 1843 0
 1775 0c6c 00308DE5 		str	r3, [sp, #0]
 1776              	.LVL205:
 1777 0c70 B0FFFFEA 		b	.L226
 1778              	.LVL206:
 1779              	.L205:
 1780 0c74 0060A0E3 		mov	r6, #0
 1781 0c78 0070A0E3 		mov	r7, #0
 1782              	.L211:
 1783              	.LBE77:
1849:../lib/fat.c  **** #endif
 1784              		.loc 1 1849 0
 1785 0c7c 0600A0E1 		mov	r0, r6
 1786 0c80 0710A0E1 		mov	r1, r7
 1787 0c84 10D08DE2 		add	sp, sp, #16
 1788 0c88 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1789 0c8c 1EFF2FE1 		bx	lr
 1790              		.cfi_endproc
 1791              	.LFE39:
 1793              		.align	2
 1794              		.global	fat_open
 1796              	fat_open:
 1797              	.LFB0:
 237:../lib/fat.c  ****     if(!partition ||
 1798              		.loc 1 237 0
 1799              		.cfi_startproc
 1800              		@ Function supports interworking.
 1801              		@ args = 0, pretend = 0, frame = 64
 1802              		@ frame_needed = 0, uses_anonymous_args = 0
 1803              	.LVL207:
 1804 0c90 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1805              	.LCFI12:
 1806              		.cfi_def_cfa_offset 36
 1807              		.cfi_offset 4, -36
 1808              		.cfi_offset 5, -32
 1809              		.cfi_offset 6, -28
 1810              		.cfi_offset 7, -24
 1811              		.cfi_offset 8, -20
 1812              		.cfi_offset 9, -16
 1813              		.cfi_offset 10, -12
 1814              		.cfi_offset 11, -8
 1815              		.cfi_offset 14, -4
 238:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
 1816              		.loc 1 238 0
 1817 0c94 004050E2 		subs	r4, r0, #0
 237:../lib/fat.c  ****     if(!partition ||
 1818              		.loc 1 237 0
 1819 0c98 40D04DE2 		sub	sp, sp, #64
 1820              	.LCFI13:
 1821              		.cfi_def_cfa_offset 100
 238:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
 1822              		.loc 1 238 0
 1823 0c9c 9300000A 		beq	.L257
 238:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
 1824              		.loc 1 238 0 is_stmt 0 discriminator 1
 1825 0ca0 080094E5 		ldr	r0, [r4, #8]
 1826              	.LVL208:
 1827 0ca4 000050E3 		cmp	r0, #0
 1828 0ca8 9100000A 		beq	.L254
 240:../lib/fat.c  ****        !partition->device_write_interval
 1829              		.loc 1 240 0 is_stmt 1
 1830 0cac 0C0094E5 		ldr	r0, [r4, #12]
 1831 0cb0 000050E3 		cmp	r0, #0
 1832 0cb4 8900001A 		bne	.L253
 1833 0cb8 8D0000EA 		b	.L254
 1834              	.LVL209:
 1835              	.L255:
 1836              	.LBB85:
 1837              	.LBB86:
 331:../lib/fat.c  ****     uint16_t reserved_sectors = read16(&buffer[0x03]);
 1838              		.loc 1 331 0
 1839 0cbc 18008DE2 		add	r0, sp, #24
 1840 0cc0 FEFFFFEB 		bl	read16
 1841              	.LVL210:
 1842 0cc4 0060A0E1 		mov	r6, r0
 1843              	.LVL211:
 332:../lib/fat.c  ****     uint8_t sectors_per_cluster = buffer[0x02];
 1844              		.loc 1 332 0
 1845 0cc8 1B008DE2 		add	r0, sp, #27
 1846              	.LVL212:
 1847 0ccc FEFFFFEB 		bl	read16
 1848              	.LVL213:
 333:../lib/fat.c  ****     uint8_t fat_copies = buffer[0x05];
 1849              		.loc 1 333 0
 1850 0cd0 1A30DDE5 		ldrb	r3, [sp, #26]	@ zero_extendqisi2
 332:../lib/fat.c  ****     uint8_t sectors_per_cluster = buffer[0x02];
 1851              		.loc 1 332 0
 1852 0cd4 00B0A0E1 		mov	fp, r0
 1853              	.LVL214:
 335:../lib/fat.c  ****     uint16_t sector_count_16 = read16(&buffer[0x08]);
 1854              		.loc 1 335 0
 1855 0cd8 1E008DE2 		add	r0, sp, #30
 1856              	.LVL215:
 333:../lib/fat.c  ****     uint8_t fat_copies = buffer[0x05];
 1857              		.loc 1 333 0
 1858 0cdc 0C308DE5 		str	r3, [sp, #12]
 1859              	.LVL216:
 334:../lib/fat.c  ****     uint16_t max_root_entries = read16(&buffer[0x06]);
 1860              		.loc 1 334 0
 1861 0ce0 1DA0DDE5 		ldrb	sl, [sp, #29]	@ zero_extendqisi2
 1862              	.LVL217:
 335:../lib/fat.c  ****     uint16_t sector_count_16 = read16(&buffer[0x08]);
 1863              		.loc 1 335 0
 1864 0ce4 FEFFFFEB 		bl	read16
 1865              	.LVL218:
 1866 0ce8 10008DE5 		str	r0, [sp, #16]
 1867              	.LVL219:
 336:../lib/fat.c  ****     uint16_t sectors_per_fat = read16(&buffer[0x0b]);
 1868              		.loc 1 336 0
 1869 0cec 20008DE2 		add	r0, sp, #32
 1870 0cf0 FEFFFFEB 		bl	read16
 1871              	.LVL220:
 1872 0cf4 0050A0E1 		mov	r5, r0
 1873              	.LVL221:
 337:../lib/fat.c  ****     uint32_t sector_count = read32(&buffer[0x15]);
 1874              		.loc 1 337 0
 1875 0cf8 23008DE2 		add	r0, sp, #35
 1876              	.LVL222:
 1877 0cfc FEFFFFEB 		bl	read16
 1878              	.LVL223:
 1879 0d00 0090A0E1 		mov	r9, r0
 1880              	.LVL224:
 338:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 1881              		.loc 1 338 0
 1882 0d04 2D008DE2 		add	r0, sp, #45
 1883              	.LVL225:
 1884 0d08 FEFFFFEB 		bl	read32
 1885              	.LVL226:
 1886 0d0c 0080A0E1 		mov	r8, r0
 1887              	.LVL227:
 340:../lib/fat.c  ****     uint32_t cluster_root_dir = read32(&buffer[0x21]);
 1888              		.loc 1 340 0
 1889 0d10 31008DE2 		add	r0, sp, #49
 1890              	.LVL228:
 1891 0d14 FEFFFFEB 		bl	read32
 1892              	.LVL229:
 1893 0d18 0070A0E1 		mov	r7, r0
 1894              	.LVL230:
 341:../lib/fat.c  **** #endif
 1895              		.loc 1 341 0
 1896 0d1c 39008DE2 		add	r0, sp, #57
 1897              	.LVL231:
 1898 0d20 FEFFFFEB 		bl	read32
 1899              	.LVL232:
 344:../lib/fat.c  ****     {
 1900              		.loc 1 344 0
 1901 0d24 000058E3 		cmp	r8, #0
 341:../lib/fat.c  **** #endif
 1902              		.loc 1 341 0
 1903 0d28 14008DE5 		str	r0, [sp, #20]
 1904              	.LVL233:
 344:../lib/fat.c  ****     {
 1905              		.loc 1 344 0
 1906 0d2c 0600001A 		bne	.L230
 346:../lib/fat.c  ****             /* illegal volume size */
 1907              		.loc 1 346 0
 1908 0d30 000055E3 		cmp	r5, #0
 350:../lib/fat.c  ****     }
 1909              		.loc 1 350 0
 1910 0d34 0580A011 		movne	r8, r5
 1911              	.LVL234:
 346:../lib/fat.c  ****             /* illegal volume size */
 1912              		.loc 1 346 0
 1913 0d38 0300001A 		bne	.L230
 1914              	.LVL235:
 1915              	.L235:
 1916              	.LBE86:
 1917              	.LBE85:
 274:../lib/fat.c  **** #endif
 1918              		.loc 1 274 0
 1919 0d3c BC319FE5 		ldr	r3, .L258
 1920              	.LBB91:
 1921              	.LBB87:
 348:../lib/fat.c  ****         else
 1922              		.loc 1 348 0
 1923 0d40 0000A0E3 		mov	r0, #0
 1924              	.LBE87:
 1925              	.LBE91:
 274:../lib/fat.c  **** #endif
 1926              		.loc 1 274 0
 1927 0d44 000083E5 		str	r0, [r3, #0]
 276:../lib/fat.c  ****     }
 1928              		.loc 1 276 0
 1929 0d48 690000EA 		b	.L254
 1930              	.LVL236:
 1931              	.L230:
 1932              	.LBB92:
 1933              	.LBB88:
 353:../lib/fat.c  ****         sectors_per_fat32 = sectors_per_fat;
 1934              		.loc 1 353 0
 1935 0d4c 000059E3 		cmp	r9, #0
 354:../lib/fat.c  ****     else if(sectors_per_fat32 == 0)
 1936              		.loc 1 354 0
 1937 0d50 0970A011 		movne	r7, r9
 1938              	.LVL237:
 353:../lib/fat.c  ****         sectors_per_fat32 = sectors_per_fat;
 1939              		.loc 1 353 0
 1940 0d54 0100001A 		bne	.L234
 1941              	.L233:
 355:../lib/fat.c  ****         /* this is neither FAT16 nor FAT32 */
 1942              		.loc 1 355 0
 1943 0d58 000057E3 		cmp	r7, #0
 1944 0d5c F6FFFF0A 		beq	.L235
 1945              	.L234:
 1946              	.LVL238:
 372:../lib/fat.c  ****     uint32_t data_cluster_count = data_sector_count / sectors_per_cluster;
 1947              		.loc 1 372 0
 1948 0d60 10309DE5 		ldr	r3, [sp, #16]
 1949 0d64 1F00E0E3 		mvn	r0, #31
 1950              	.LVL239:
 1951 0d68 930000E0 		mul	r0, r3, r0
 1952 0d6c 000066E0 		rsb	r0, r6, r0
 1953 0d70 0610A0E1 		mov	r1, r6
 1954 0d74 010080E2 		add	r0, r0, #1
 1955 0d78 FEFFFFEB 		bl	__divsi3
 1956              	.LVL240:
 368:../lib/fat.c  **** #else
 1957              		.loc 1 368 0
 1958 0d7c 9A0703E0 		mul	r3, sl, r7
 366:../lib/fat.c  **** #if FAT_FAT32_SUPPORT
 1959              		.loc 1 366 0
 1960 0d80 00006BE0 		rsb	r0, fp, r0
 368:../lib/fat.c  **** #else
 1961              		.loc 1 368 0
 1962 0d84 080080E0 		add	r0, r0, r8
 373:../lib/fat.c  ****     if(data_cluster_count < 4085)
 1963              		.loc 1 373 0
 1964 0d88 000063E0 		rsb	r0, r3, r0
 1965 0d8c 0C109DE5 		ldr	r1, [sp, #12]
 1966 0d90 FEFFFFEB 		bl	__udivsi3
 1967              	.LVL241:
 374:../lib/fat.c  ****         /* this is a FAT12, not supported */
 1968              		.loc 1 374 0
 1969 0d94 68219FE5 		ldr	r2, .L258+4
 1970 0d98 020050E1 		cmp	r0, r2
 373:../lib/fat.c  ****     if(data_cluster_count < 4085)
 1971              		.loc 1 373 0
 1972 0d9c 0030A0E1 		mov	r3, r0
 1973              	.LVL242:
 374:../lib/fat.c  ****         /* this is a FAT12, not supported */
 1974              		.loc 1 374 0
 1975 0da0 E5FFFF9A 		bls	.L235
 377:../lib/fat.c  ****         /* this is a FAT16 */
 1976              		.loc 1 377 0
 1977 0da4 0F2A82E2 		add	r2, r2, #61440
 1978 0da8 020050E1 		cmp	r0, r2
 385:../lib/fat.c  ****     memset(header, 0, sizeof(*header));
 1979              		.loc 1 385 0
 1980 0dac 4C519FE5 		ldr	r5, .L258
 1981              	.LVL243:
 379:../lib/fat.c  ****     else
 1982              		.loc 1 379 0
 1983 0db0 0620A093 		movls	r2, #6
 382:../lib/fat.c  **** 
 1984              		.loc 1 382 0
 1985 0db4 0B20A083 		movhi	r2, #11
 1986 0db8 1020C4E5 		strb	r2, [r4, #16]
 1987              	.LVL244:
 386:../lib/fat.c  ****     
 1988              		.loc 1 386 0
 1989 0dbc 0010A0E3 		mov	r1, #0
 1990 0dc0 2C20A0E3 		mov	r2, #44
 1991 0dc4 040085E2 		add	r0, r5, #4
 1992              	.LVL245:
 1993 0dc8 00308DE5 		str	r3, [sp, #0]
 1994 0dcc FEFFFFEB 		bl	memset
 1995              	.LVL246:
 388:../lib/fat.c  **** 
 1996              		.loc 1 388 0
 1997 0dd0 980681E0 		umull	r0, r1, r8, r6
 1998 0dd4 030085E9 		stmib	r5, {r0-r1}
 391:../lib/fat.c  ****                          /* jump to fat */
 1999              		.loc 1 391 0
 2000 0dd8 03009DE9 		ldmib	sp, {r0-r1}
 2001 0ddc 960BA1E0 		umlal	r0, r1, r6, fp
 390:../lib/fat.c  ****                          partition_offset +
 2002              		.loc 1 390 0
 2003 0de0 0C0085E5 		str	r0, [r5, #12]
 2004 0de4 101085E5 		str	r1, [r5, #16]
 394:../lib/fat.c  **** 
 2005              		.loc 1 394 0
 2006 0de8 1020D4E5 		ldrb	r2, [r4, #16]	@ zero_extendqisi2
 2007 0dec 00309DE5 		ldr	r3, [sp, #0]
 2008 0df0 060052E3 		cmp	r2, #6
 2009 0df4 0420A013 		movne	r2, #4
 2010 0df8 0220A003 		moveq	r2, #2
 2011 0dfc 023083E2 		add	r3, r3, #2
 2012 0e00 920303E0 		mul	r3, r2, r3
 397:../lib/fat.c  **** 
 2013              		.loc 1 397 0
 2014 0e04 0C209DE5 		ldr	r2, [sp, #12]
 394:../lib/fat.c  **** 
 2015              		.loc 1 394 0
 2016 0e08 143085E5 		str	r3, [r5, #20]
 397:../lib/fat.c  **** 
 2017              		.loc 1 397 0
 2018 0e0c 920603E0 		mul	r3, r2, r6
 396:../lib/fat.c  ****     header->cluster_size = (uint16_t) bytes_per_sector * sectors_per_cluster;
 2019              		.loc 1 396 0
 2020 0e10 B861C5E1 		strh	r6, [r5, #24]	@ movhi
 397:../lib/fat.c  **** 
 2021              		.loc 1 397 0
 2022 0e14 BA31C5E1 		strh	r3, [r5, #26]	@ movhi
 400:../lib/fat.c  **** #endif
 2023              		.loc 1 400 0
 2024 0e18 1030D4E5 		ldrb	r3, [r4, #16]	@ zero_extendqisi2
 2025 0e1c 060053E3 		cmp	r3, #6
 2026 0e20 0D00001A 		bne	.L239
 406:../lib/fat.c  **** 
 2027              		.loc 1 406 0
 2028 0e24 962983E0 		umull	r2, r3, r6, r9
 2029 0e28 FFC00AE2 		and	ip, sl, #255
 2030 0e2c 926C87E0 		umull	r6, r7, r2, ip
 2031              	.LVL247:
 2032 0e30 9C7327E0 		mla	r7, ip, r3, r7
 2033              	.LVL248:
 404:../lib/fat.c  ****                                   /* jump to root directory entries */
 2034              		.loc 1 404 0
 2035 0e34 060090E0 		adds	r0, r0, r6
 409:../lib/fat.c  ****                                       /* skip root directory entries */
 2036              		.loc 1 409 0
 2037 0e38 10209DE5 		ldr	r2, [sp, #16]
 404:../lib/fat.c  ****                                   /* jump to root directory entries */
 2038              		.loc 1 404 0
 2039 0e3c 0710A1E0 		adc	r1, r1, r7
 409:../lib/fat.c  ****                                       /* skip root directory entries */
 2040              		.loc 1 409 0
 2041 0e40 2030A0E3 		mov	r3, #32
 403:../lib/fat.c  ****                                   header->fat_offset +
 2042              		.loc 1 403 0
 2043 0e44 240085E5 		str	r0, [r5, #36]
 2044 0e48 281085E5 		str	r1, [r5, #40]
 409:../lib/fat.c  ****                                       /* skip root directory entries */
 2045              		.loc 1 409 0
 2046 0e4c 9302A1E0 		umlal	r0, r1, r3, r2
 408:../lib/fat.c  ****                                       header->root_dir_offset +
 2047              		.loc 1 408 0
 2048 0e50 1C0085E5 		str	r0, [r5, #28]
 2049 0e54 201085E5 		str	r1, [r5, #32]
 2050 0e58 080000EA 		b	.L246
 2051              	.LVL249:
 2052              	.L239:
 419:../lib/fat.c  **** 
 2053              		.loc 1 419 0
 2054 0e5c 962A83E0 		umull	r2, r3, r6, sl
 2055 0e60 928789E0 		umull	r8, r9, r2, r7
 2056              	.LVL250:
 2057 0e64 979329E0 		mla	r9, r7, r3, r9
 2058              	.LVL251:
 417:../lib/fat.c  ****                                       /* skip fats */
 2059              		.loc 1 417 0
 2060 0e68 080090E0 		adds	r0, r0, r8
 2061 0e6c 0910A1E0 		adc	r1, r1, r9
 421:../lib/fat.c  ****     }
 2062              		.loc 1 421 0
 2063 0e70 14309DE5 		ldr	r3, [sp, #20]
 416:../lib/fat.c  ****                                       header->fat_offset +
 2064              		.loc 1 416 0
 2065 0e74 1C0085E5 		str	r0, [r5, #28]
 2066 0e78 201085E5 		str	r1, [r5, #32]
 421:../lib/fat.c  ****     }
 2067              		.loc 1 421 0
 2068 0e7c 2C3085E5 		str	r3, [r5, #44]
 2069              	.LVL252:
 2070              	.L246:
 2071              	.LBE88:
 2072              	.LBE92:
 253:../lib/fat.c  ****     uint8_t i;
 2073              		.loc 1 253 0
 2074 0e80 78009FE5 		ldr	r0, .L258
 2075 0e84 1A0000EA 		b	.L254
 2076              	.LVL253:
 2077              	.L241:
 265:../lib/fat.c  **** 
 2078              		.loc 1 265 0
 2079 0e88 0510A0E1 		mov	r1, r5
 2080 0e8c 3420A0E3 		mov	r2, #52
 2081 0e90 0600A0E1 		mov	r0, r6
 2082 0e94 FEFFFFEB 		bl	memset
 2083              	.LVL254:
 2084              	.LBB93:
 2085              	.LBB89:
 326:../lib/fat.c  **** 
 2086              		.loc 1 326 0
 2087 0e98 143094E5 		ldr	r3, [r4, #20]
 2088 0e9c A32BA0E1 		mov	r2, r3, lsr #23
 2089 0ea0 8314A0E1 		mov	r1, r3, asl #9
 2090 0ea4 08208DE5 		str	r2, [sp, #8]
 2091 0ea8 04108DE5 		str	r1, [sp, #4]
 328:../lib/fat.c  ****         return 0;
 2092              		.loc 1 328 0
 2093 0eac 022CA0E3 		mov	r2, #512
 2094 0eb0 0B00A0E3 		mov	r0, #11
 2095 0eb4 0010A0E3 		mov	r1, #0
 2096 0eb8 9203A1E0 		umlal	r0, r1, r2, r3
 2097              	.LBE89:
 2098              	.LBE93:
 267:../lib/fat.c  **** 
 2099              		.loc 1 267 0
 2100 0ebc 004086E5 		str	r4, [r6, #0]
 2101              	.LVL255:
 2102              	.LBB94:
 2103              	.LBB90:
 328:../lib/fat.c  ****         return 0;
 2104              		.loc 1 328 0
 2105 0ec0 18208DE2 		add	r2, sp, #24
 2106 0ec4 2530A0E3 		mov	r3, #37
 2107 0ec8 00C094E5 		ldr	ip, [r4, #0]
 2108 0ecc 0FE0A0E1 		mov	lr, pc
 2109 0ed0 1CFF2FE1 		bx	ip
 2110              	.LVL256:
 2111 0ed4 000050E3 		cmp	r0, #0
 2112 0ed8 97FFFF0A 		beq	.L235
 2113 0edc 76FFFFEA 		b	.L255
 2114              	.LVL257:
 2115              	.L253:
 2116              	.LBE90:
 2117              	.LBE94:
 257:../lib/fat.c  ****             break;
 2118              		.loc 1 257 0
 2119 0ee0 18609FE5 		ldr	r6, .L258
 2120 0ee4 005096E5 		ldr	r5, [r6, #0]
 2121 0ee8 000055E3 		cmp	r5, #0
 2122 0eec E5FFFF0A 		beq	.L241
 2123              	.LVL258:
 2124              	.L257:
 246:../lib/fat.c  **** 
 2125              		.loc 1 246 0
 2126 0ef0 0000A0E3 		mov	r0, #0
 2127              	.L254:
 280:../lib/fat.c  **** 
 2128              		.loc 1 280 0
 2129 0ef4 40D08DE2 		add	sp, sp, #64
 2130 0ef8 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2131 0efc 1EFF2FE1 		bx	lr
 2132              	.L259:
 2133              		.align	2
 2134              	.L258:
 2135 0f00 00000000 		.word	.LANCHOR1
 2136 0f04 F40F0000 		.word	4084
 2137              		.cfi_endproc
 2138              	.LFE0:
 2140              		.align	2
 2141              		.global	fat_close
 2143              	fat_close:
 2144              	.LFB1:
 293:../lib/fat.c  ****     if(!fs)
 2145              		.loc 1 293 0
 2146              		.cfi_startproc
 2147              		@ Function supports interworking.
 2148              		@ args = 0, pretend = 0, frame = 0
 2149              		@ frame_needed = 0, uses_anonymous_args = 0
 2150              		@ link register save eliminated.
 2151              	.LVL259:
 294:../lib/fat.c  ****         return;
 2152              		.loc 1 294 0
 2153 0f08 000050E3 		cmp	r0, #0
 300:../lib/fat.c  **** #endif
 2154              		.loc 1 300 0
 2155 0f0c 0030A013 		movne	r3, #0
 2156 0f10 00308015 		strne	r3, [r0, #0]
 2157 0f14 1EFF2FE1 		bx	lr
 2158              		.cfi_endproc
 2159              	.LFE1:
 2161              		.align	2
 2162              		.global	fat_open_file
 2164              	fat_open_file:
 2165              	.LFB11:
 928:../lib/fat.c  ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT_ATTRIB_DIR))
 2166              		.loc 1 928 0
 2167              		.cfi_startproc
 2168              		@ Function supports interworking.
 2169              		@ args = 0, pretend = 0, frame = 0
 2170              		@ frame_needed = 0, uses_anonymous_args = 0
 2171              	.LVL260:
 929:../lib/fat.c  ****         return 0;
 2172              		.loc 1 929 0
 2173 0f18 000050E3 		cmp	r0, #0
 2174 0f1c 00005113 		cmpne	r1, #0
 928:../lib/fat.c  ****     if(!fs || !dir_entry || (dir_entry->attributes & FAT_ATTRIB_DIR))
 2175              		.loc 1 928 0
 2176 0f20 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 16
 2179              		.cfi_offset 4, -16
 2180              		.cfi_offset 5, -12
 2181              		.cfi_offset 6, -8
 2182              		.cfi_offset 14, -4
 929:../lib/fat.c  ****         return 0;
 2183              		.loc 1 929 0
 2184 0f24 0050A0E1 		mov	r5, r0
 2185 0f28 0160A0E1 		mov	r6, r1
 2186 0f2c 0000A013 		movne	r0, #0
 2187 0f30 0100A003 		moveq	r0, #1
 2188              	.LVL261:
 2189 0f34 0300000A 		beq	.L269
 929:../lib/fat.c  ****         return 0;
 2190              		.loc 1 929 0 is_stmt 0 discriminator 1
 2191 0f38 2030D1E5 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 2192 0f3c 103013E2 		ands	r3, r3, #16
 2193 0f40 0E00000A 		beq	.L267
 2194 0f44 120000EA 		b	.L270
 2195              	.L269:
 930:../lib/fat.c  **** 
 2196              		.loc 1 930 0 is_stmt 1
 2197 0f48 0000A0E3 		mov	r0, #0
 2198 0f4c 100000EA 		b	.L270
 2199              	.LVL262:
 2200              	.L268:
 950:../lib/fat.c  ****     fd->fs = fs;
 2201              		.loc 1 950 0
 2202 0f50 3420A0E3 		mov	r2, #52
 2203 0f54 380084E2 		add	r0, r4, #56
 2204 0f58 FEFFFFEB 		bl	memcpy
 2205              	.LVL263:
 952:../lib/fat.c  ****     fd->pos_cluster = dir_entry->cluster;
 2206              		.loc 1 952 0
 2207 0f5c 0030A0E3 		mov	r3, #0
 2208 0f60 0020A0E3 		mov	r2, #0
 2209 0f64 6C2084E5 		str	r2, [r4, #108]
 2210 0f68 703084E5 		str	r3, [r4, #112]
 953:../lib/fat.c  **** 
 2211              		.loc 1 953 0
 2212 0f6c 243096E5 		ldr	r3, [r6, #36]
 951:../lib/fat.c  ****     fd->pos = 0;
 2213              		.loc 1 951 0
 2214 0f70 345084E5 		str	r5, [r4, #52]
 953:../lib/fat.c  **** 
 2215              		.loc 1 953 0
 2216 0f74 743084E5 		str	r3, [r4, #116]
 937:../lib/fat.c  ****     uint8_t i;
 2217              		.loc 1 937 0
 2218 0f78 340084E2 		add	r0, r4, #52
 955:../lib/fat.c  **** }
 2219              		.loc 1 955 0
 2220 0f7c 040000EA 		b	.L270
 2221              	.LVL264:
 2222              	.L267:
 941:../lib/fat.c  ****             break;
 2223              		.loc 1 941 0
 2224 0f80 14409FE5 		ldr	r4, .L271
 2225 0f84 342094E5 		ldr	r2, [r4, #52]
 2226 0f88 000052E3 		cmp	r2, #0
 2227 0f8c EFFFFF0A 		beq	.L268
 930:../lib/fat.c  **** 
 2228              		.loc 1 930 0
 2229 0f90 0300A0E1 		mov	r0, r3
 2230              	.LVL265:
 2231              	.L270:
 956:../lib/fat.c  **** 
 2232              		.loc 1 956 0
 2233 0f94 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2234 0f98 1EFF2FE1 		bx	lr
 2235              	.L272:
 2236              		.align	2
 2237              	.L271:
 2238 0f9c 00000000 		.word	.LANCHOR1
 2239              		.cfi_endproc
 2240              	.LFE11:
 2242              		.align	2
 2243              		.global	fat_close_file
 2245              	fat_close_file:
 2246              	.LFB12:
 966:../lib/fat.c  ****     if(fd)
 2247              		.loc 1 966 0
 2248              		.cfi_startproc
 2249              		@ Function supports interworking.
 2250              		@ args = 0, pretend = 0, frame = 0
 2251              		@ frame_needed = 0, uses_anonymous_args = 0
 2252              		@ link register save eliminated.
 2253              	.LVL266:
 967:../lib/fat.c  ****     {
 2254              		.loc 1 967 0
 2255 0fa0 000050E3 		cmp	r0, #0
 977:../lib/fat.c  **** #endif
 2256              		.loc 1 977 0
 2257 0fa4 0030A013 		movne	r3, #0
 2258 0fa8 00308015 		strne	r3, [r0, #0]
 2259 0fac 1EFF2FE1 		bx	lr
 2260              		.cfi_endproc
 2261              	.LFE12:
 2263              		.align	2
 2264              		.global	fat_read_file
 2266              	fat_read_file:
 2267              	.LFB13:
 995:../lib/fat.c  ****     /* check arguments */
 2268              		.loc 1 995 0
 2269              		.cfi_startproc
 2270              		@ Function supports interworking.
 2271              		@ args = 0, pretend = 0, frame = 4
 2272              		@ frame_needed = 0, uses_anonymous_args = 0
 2273              	.LVL267:
 2274 0fb0 F14F2DE9 		stmfd	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2275              	.LCFI15:
 2276              		.cfi_def_cfa_offset 40
 2277              		.cfi_offset 0, -40
 2278              		.cfi_offset 4, -36
 2279              		.cfi_offset 5, -32
 2280              		.cfi_offset 6, -28
 2281              		.cfi_offset 7, -24
 2282              		.cfi_offset 8, -20
 2283              		.cfi_offset 9, -16
 2284              		.cfi_offset 10, -12
 2285              		.cfi_offset 11, -8
 2286              		.cfi_offset 14, -4
 997:../lib/fat.c  ****         return -1;
 2287              		.loc 1 997 0
 2288 0fb4 000050E3 		cmp	r0, #0
 2289 0fb8 00005113 		cmpne	r1, #0
 995:../lib/fat.c  ****     /* check arguments */
 2290              		.loc 1 995 0
 2291 0fbc 02B0A0E1 		mov	fp, r2
 997:../lib/fat.c  ****         return -1;
 2292              		.loc 1 997 0
 2293 0fc0 00108DE5 		str	r1, [sp, #0]
 2294 0fc4 00A0A0E1 		mov	sl, r0
 2295 0fc8 1900000A 		beq	.L306
 2296              	.L279:
 997:../lib/fat.c  ****         return -1;
 2297              		.loc 1 997 0 is_stmt 0 discriminator 1
 2298 0fcc 000052E3 		cmp	r2, #0
 2299 0fd0 1700000A 		beq	.L306
1001:../lib/fat.c  ****         buffer_len = fd->dir_entry.file_size - fd->pos;
 2300              		.loc 1 1001 0 is_stmt 1
 2301 0fd4 385080E2 		add	r5, r0, #56
 2302 0fd8 300095E8 		ldmia	r5, {r4-r5}
 2303 0fdc 2C3090E5 		ldr	r3, [r0, #44]
 2304 0fe0 028094E0 		adds	r8, r4, r2
 2305 0fe4 0090A5E2 		adc	r9, r5, #0
 2306 0fe8 0360A0E1 		mov	r6, r3
 2307 0fec 0070A0E3 		mov	r7, #0
 2308 0ff0 090057E1 		cmp	r7, r9
 2309              		it eq
 2310 0ff4 08005601 		cmpeq	r6, r8
 2311 0ff8 0300002A 		bcs	.L282
 2312              	.LVL268:
1003:../lib/fat.c  ****         return 0;
 2313              		.loc 1 1003 0
 2314 0ffc 04B053E0 		subs	fp, r3, r4
 2315 1000 0100001A 		bne	.L282
 2316              	.LVL269:
 2317              	.L285:
 2318              	.LBB95:
1004:../lib/fat.c  ****     
 2319              		.loc 1 1004 0
 2320 1004 0000A0E3 		mov	r0, #0
 2321              	.LVL270:
 2322 1008 4A0000EA 		b	.L280
 2323              	.LVL271:
 2324              	.L282:
 2325              	.LBE95:
1007:../lib/fat.c  ****     uintptr_t buffer_left = buffer_len;
 2326              		.loc 1 1007 0
 2327 100c 40609AE5 		ldr	r6, [sl, #64]
1006:../lib/fat.c  ****     cluster_t cluster_num = fd->pos_cluster;
 2328              		.loc 1 1006 0
 2329 1010 00309AE5 		ldr	r3, [sl, #0]
1012:../lib/fat.c  ****     {
 2330              		.loc 1 1012 0
 2331 1014 000056E3 		cmp	r6, #0
1006:../lib/fat.c  ****     cluster_t cluster_num = fd->pos_cluster;
 2332              		.loc 1 1006 0
 2333 1018 BA71D3E1 		ldrh	r7, [r3, #26]
 2334              	.LVL272:
1012:../lib/fat.c  ****     {
 2335              		.loc 1 1012 0
 2336 101c 1200001A 		bne	.L283
1014:../lib/fat.c  ****         
 2337              		.loc 1 1014 0
 2338 1020 28609AE5 		ldr	r6, [sl, #40]
 2339              	.LVL273:
1016:../lib/fat.c  ****         {
 2340              		.loc 1 1016 0
 2341 1024 000056E3 		cmp	r6, #0
 2342 1028 0300001A 		bne	.L284
1018:../lib/fat.c  ****                 return 0;
 2343              		.loc 1 1018 0
 2344 102c 053094E1 		orrs	r3, r4, r5
 2345              	.LVL274:
 2346 1030 F3FFFF0A 		beq	.L285
 2347              	.LVL275:
 2348              	.L306:
1021:../lib/fat.c  ****         }
 2349              		.loc 1 1021 0
 2350 1034 0000E0E3 		mvn	r0, #0
 2351 1038 3E0000EA 		b	.L280
 2352              	.LVL276:
 2353              	.L284:
1024:../lib/fat.c  ****         {
 2354              		.loc 1 1024 0
 2355 103c 053094E1 		orrs	r3, r4, r5
 2356              	.LVL277:
 2357              	.LBB96:
1026:../lib/fat.c  ****             while(pos >= cluster_size)
 2358              		.loc 1 1026 0
 2359 1040 0480A011 		movne	r8, r4
 2360              	.LBE96:
1024:../lib/fat.c  ****         {
 2361              		.loc 1 1024 0
 2362 1044 0600001A 		bne	.L286
 2363 1048 070000EA 		b	.L283
 2364              	.LVL278:
 2365              	.L287:
 2366              	.LBB97:
1030:../lib/fat.c  ****                 if(!cluster_num)
 2367              		.loc 1 1030 0
 2368 104c 0610A0E1 		mov	r1, r6
 2369 1050 00009AE5 		ldr	r0, [sl, #0]
 2370 1054 AAFCFFEB 		bl	fat_get_next_cluster
 2371              	.LVL279:
1031:../lib/fat.c  ****                     return -1;
 2372              		.loc 1 1031 0
 2373 1058 006050E2 		subs	r6, r0, #0
 2374              	.LVL280:
 994:../lib/fat.c  **** {
 2375              		.loc 1 994 0
 2376 105c 088067E0 		rsb	r8, r7, r8
 2377              	.LVL281:
1031:../lib/fat.c  ****                     return -1;
 2378              		.loc 1 1031 0
 2379 1060 F3FFFF0A 		beq	.L306
 2380              	.LVL282:
 2381              	.L286:
1027:../lib/fat.c  ****             {
 2382              		.loc 1 1027 0 discriminator 1
 2383 1064 070058E1 		cmp	r8, r7
 2384 1068 F7FFFF2A 		bcs	.L287
 2385              	.LVL283:
 2386              	.L283:
 2387              	.LBE97:
1009:../lib/fat.c  **** 
 2388              		.loc 1 1009 0
 2389 106c 013047E2 		sub	r3, r7, #1
 2390 1070 044003E0 		and	r4, r3, r4
 2391              	.LVL284:
 2392 1074 0448A0E1 		mov	r4, r4, asl #16
 2393 1078 2448A0E1 		mov	r4, r4, lsr #16
 2394 107c 0B50A0E1 		mov	r5, fp
 2395              	.LVL285:
 2396              	.L291:
 2397              	.LBB98:
1041:../lib/fat.c  ****         uint16_t copy_length = cluster_size - first_cluster_offset;
 2398              		.loc 1 1041 0
 2399 1080 00909AE5 		ldr	r9, [sl, #0]
 2400 1084 0610A0E1 		mov	r1, r6
 2401 1088 0900A0E1 		mov	r0, r9
 2402 108c BDFDFFEB 		bl	fat_cluster_offset
 2403              	.LVL286:
1042:../lib/fat.c  ****         if(copy_length > buffer_left)
 2404              		.loc 1 1042 0
 2405 1090 078064E0 		rsb	r8, r4, r7
 2406 1094 0888A0E1 		mov	r8, r8, asl #16
 2407 1098 2888A0E1 		mov	r8, r8, lsr #16
1041:../lib/fat.c  ****         uint16_t copy_length = cluster_size - first_cluster_offset;
 2408              		.loc 1 1041 0
 2409 109c 040090E0 		adds	r0, r0, r4
 2410 10a0 0010A1E2 		adc	r1, r1, #0
 2411              	.LVL287:
1043:../lib/fat.c  ****             copy_length = buffer_left;
 2412              		.loc 1 1043 0
 2413 10a4 050058E1 		cmp	r8, r5
1044:../lib/fat.c  **** 
 2414              		.loc 1 1044 0
 2415 10a8 0588A081 		movhi	r8, r5, asl #16
 2416              	.LVL288:
 2417 10ac 2888A081 		movhi	r8, r8, lsr #16
 2418              	.LVL289:
1047:../lib/fat.c  ****             return buffer_len - buffer_left;
 2419              		.loc 1 1047 0
 2420 10b0 009099E5 		ldr	r9, [r9, #0]
 2421 10b4 00209DE5 		ldr	r2, [sp, #0]
 2422 10b8 0830A0E1 		mov	r3, r8
 2423 10bc 00C099E5 		ldr	ip, [r9, #0]
 2424 10c0 0FE0A0E1 		mov	lr, pc
 2425 10c4 1CFF2FE1 		bx	ip
 2426              	.LVL290:
 2427 10c8 000050E3 		cmp	r0, #0
 2428 10cc 1200000A 		beq	.L307
 2429              	.L289:
1051:../lib/fat.c  ****         buffer_left -= copy_length;
 2430              		.loc 1 1051 0
 2431 10d0 00309DE5 		ldr	r3, [sp, #0]
 2432 10d4 083083E0 		add	r3, r3, r8
 2433 10d8 00308DE5 		str	r3, [sp, #0]
 2434              	.LVL291:
1053:../lib/fat.c  **** 
 2435              		.loc 1 1053 0
 2436 10dc 38308AE2 		add	r3, sl, #56
 2437 10e0 0C0093E8 		ldmia	r3, {r2-r3}
1052:../lib/fat.c  ****         fd->pos += copy_length;
 2438              		.loc 1 1052 0
 2439 10e4 055068E0 		rsb	r5, r8, r5
 2440              	.LVL292:
1053:../lib/fat.c  **** 
 2441              		.loc 1 1053 0
 2442 10e8 082092E0 		adds	r2, r2, r8
1055:../lib/fat.c  ****         {
 2443              		.loc 1 1055 0
 2444 10ec 088084E0 		add	r8, r4, r8
 2445              	.LVL293:
1053:../lib/fat.c  **** 
 2446              		.loc 1 1053 0
 2447 10f0 0030A3E2 		adc	r3, r3, #0
 2448              	.LVL294:
1055:../lib/fat.c  ****         {
 2449              		.loc 1 1055 0
 2450 10f4 070058E1 		cmp	r8, r7
1053:../lib/fat.c  **** 
 2451              		.loc 1 1053 0
 2452 10f8 38208AE5 		str	r2, [sl, #56]
 2453 10fc 3C308AE5 		str	r3, [sl, #60]
1055:../lib/fat.c  ****         {
 2454              		.loc 1 1055 0
 2455 1100 080000BA 		blt	.L290
1058:../lib/fat.c  ****             {
 2456              		.loc 1 1058 0
 2457 1104 0610A0E1 		mov	r1, r6
 2458 1108 00009AE5 		ldr	r0, [sl, #0]
 2459 110c 7CFCFFEB 		bl	fat_get_next_cluster
 2460              	.LVL295:
 2461 1110 006050E2 		subs	r6, r0, #0
 2462 1114 0200001A 		bne	.L292
1064:../lib/fat.c  ****                 return buffer_len - buffer_left;
 2463              		.loc 1 1064 0
 2464 1118 40608AE5 		str	r6, [sl, #64]
 2465              	.LVL296:
 2466              	.L307:
1065:../lib/fat.c  ****             }
 2467              		.loc 1 1065 0
 2468 111c 0B0065E0 		rsb	r0, r5, fp
 2469 1120 040000EA 		b	.L280
 2470              	.LVL297:
 2471              	.L292:
1060:../lib/fat.c  ****             }
 2472              		.loc 1 1060 0
 2473 1124 0040A0E3 		mov	r4, #0
 2474              	.LVL298:
 2475              	.L290:
 2476              	.LBE98:
1071:../lib/fat.c  **** 
 2477              		.loc 1 1071 0
 2478 1128 000055E3 		cmp	r5, #0
 2479              	.LBB99:
1069:../lib/fat.c  **** 
 2480              		.loc 1 1069 0
 2481 112c 40608AE5 		str	r6, [sl, #64]
 2482              	.LBE99:
1071:../lib/fat.c  **** 
 2483              		.loc 1 1071 0
 2484 1130 D2FFFF1A 		bne	.L291
1073:../lib/fat.c  **** }
 2485              		.loc 1 1073 0
 2486 1134 0B00A0E1 		mov	r0, fp
 2487              	.LVL299:
 2488              	.L280:
1074:../lib/fat.c  **** 
 2489              		.loc 1 1074 0
 2490 1138 F84FBDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2491 113c 1EFF2FE1 		bx	lr
 2492              		.cfi_endproc
 2493              	.LFE13:
 2495              		.align	2
 2496              		.global	fat_write_file
 2498              	fat_write_file:
 2499              	.LFB14:
1090:../lib/fat.c  ****     /* check arguments */
 2500              		.loc 1 1090 0
 2501              		.cfi_startproc
 2502              		@ Function supports interworking.
 2503              		@ args = 0, pretend = 0, frame = 4
 2504              		@ frame_needed = 0, uses_anonymous_args = 0
 2505              	.LVL300:
 2506 1140 F14F2DE9 		stmfd	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2507              	.LCFI16:
 2508              		.cfi_def_cfa_offset 40
 2509              		.cfi_offset 0, -40
 2510              		.cfi_offset 4, -36
 2511              		.cfi_offset 5, -32
 2512              		.cfi_offset 6, -28
 2513              		.cfi_offset 7, -24
 2514              		.cfi_offset 8, -20
 2515              		.cfi_offset 9, -16
 2516              		.cfi_offset 10, -12
 2517              		.cfi_offset 11, -8
 2518              		.cfi_offset 14, -4
1092:../lib/fat.c  ****         return -1;
 2519              		.loc 1 1092 0
 2520 1144 000050E3 		cmp	r0, #0
 2521 1148 00005113 		cmpne	r1, #0
1090:../lib/fat.c  ****     /* check arguments */
 2522              		.loc 1 1090 0
 2523 114c 00208DE5 		str	r2, [sp, #0]
1092:../lib/fat.c  ****         return -1;
 2524              		.loc 1 1092 0
 2525 1150 0190A0E1 		mov	r9, r1
 2526 1154 0080A0E1 		mov	r8, r0
 2527 1158 0100001A 		bne	.L309
 2528              	.LVL301:
 2529              	.L311:
 2530              	.LBB100:
 2531              	.LBB101:
1093:../lib/fat.c  ****     if(fd->pos > fd->dir_entry.file_size)
 2532              		.loc 1 1093 0
 2533 115c 0000E0E3 		mvn	r0, #0
 2534 1160 7F0000EA 		b	.L310
 2535              	.LVL302:
 2536              	.L309:
 2537              	.LBE101:
 2538              	.LBE100:
1092:../lib/fat.c  ****         return -1;
 2539              		.loc 1 1092 0 discriminator 1
 2540 1164 00109DE5 		ldr	r1, [sp, #0]
 2541              	.LVL303:
 2542 1168 000051E3 		cmp	r1, #0
 2543 116c FAFFFF0A 		beq	.L311
1094:../lib/fat.c  ****         return -1;
 2544              		.loc 1 1094 0
 2545 1170 2C3090E5 		ldr	r3, [r0, #44]
 2546 1174 385080E2 		add	r5, r0, #56
 2547 1178 300095E8 		ldmia	r5, {r4-r5}
 2548 117c 0360A0E1 		mov	r6, r3
 2549 1180 0070A0E3 		mov	r7, #0
 2550 1184 050057E1 		cmp	r7, r5
 2551              		it eq
 2552 1188 04005601 		cmpeq	r6, r4
 2553 118c F2FFFF3A 		bcc	.L311
1097:../lib/fat.c  ****     cluster_t cluster_num = fd->pos_cluster;
 2554              		.loc 1 1097 0
 2555 1190 000090E5 		ldr	r0, [r0, #0]
 2556              	.LVL304:
 2557 1194 BA71D0E1 		ldrh	r7, [r0, #26]
 2558              	.LVL305:
1098:../lib/fat.c  ****     uintptr_t buffer_left = buffer_len;
 2559              		.loc 1 1098 0
 2560 1198 40A098E5 		ldr	sl, [r8, #64]
 2561              	.LVL306:
1100:../lib/fat.c  **** 
 2562              		.loc 1 1100 0
 2563 119c 01B047E2 		sub	fp, r7, #1
 2564 11a0 04B00BE0 		and	fp, fp, r4
 2565 11a4 0BB8A0E1 		mov	fp, fp, asl #16
1103:../lib/fat.c  ****     {
 2566              		.loc 1 1103 0
 2567 11a8 00005AE3 		cmp	sl, #0
1100:../lib/fat.c  **** 
 2568              		.loc 1 1100 0
 2569 11ac 2BB8A0E1 		mov	fp, fp, lsr #16
 2570              	.LVL307:
1103:../lib/fat.c  ****     {
 2571              		.loc 1 1103 0
 2572 11b0 2400001A 		bne	.L312
1105:../lib/fat.c  ****         
 2573              		.loc 1 1105 0
 2574 11b4 28A098E5 		ldr	sl, [r8, #40]
 2575              	.LVL308:
1107:../lib/fat.c  ****         {
 2576              		.loc 1 1107 0
 2577 11b8 00005AE3 		cmp	sl, #0
 2578 11bc 0A00001A 		bne	.L313
1109:../lib/fat.c  ****             {
 2579              		.loc 1 1109 0
 2580 11c0 053094E1 		orrs	r3, r4, r5
 2581 11c4 E4FFFF1A 		bne	.L311
1112:../lib/fat.c  ****                 if(!cluster_num)
 2582              		.loc 1 1112 0
 2583 11c8 0A10A0E1 		mov	r1, sl
 2584              	.LVL309:
 2585 11cc 0120A0E3 		mov	r2, #1
 2586              	.LVL310:
 2587 11d0 E4FCFFEB 		bl	fat_append_clusters
 2588              	.LVL311:
1113:../lib/fat.c  ****                     return 0;
 2589              		.loc 1 1113 0
 2590 11d4 000050E3 		cmp	r0, #0
1112:../lib/fat.c  ****                 if(!cluster_num)
 2591              		.loc 1 1112 0
 2592 11d8 00A0A0E1 		mov	sl, r0
 2593              	.LVL312:
 2594 11dc 280088E5 		str	r0, [r8, #40]
1113:../lib/fat.c  ****                     return 0;
 2595              		.loc 1 1113 0
 2596 11e0 0100001A 		bne	.L313
 2597              	.LVL313:
 2598              	.L316:
 2599              	.LBB104:
 2600              	.LBB102:
1114:../lib/fat.c  ****             }
 2601              		.loc 1 1114 0
 2602 11e4 0000A0E3 		mov	r0, #0
 2603 11e8 5D0000EA 		b	.L310
 2604              	.L313:
 2605              	.LBE102:
 2606              	.LBE104:
1122:../lib/fat.c  ****         {
 2607              		.loc 1 1122 0
 2608 11ec 383088E2 		add	r3, r8, #56
 2609 11f0 0C0093E8 		ldmia	r3, {r2-r3}
 2610 11f4 031092E1 		orrs	r1, r2, r3
 2611              	.LBB105:
1124:../lib/fat.c  ****             cluster_t cluster_num_next;
 2612              		.loc 1 1124 0
 2613 11f8 0240A011 		movne	r4, r2
 2614              	.LBE105:
1122:../lib/fat.c  ****         {
 2615              		.loc 1 1122 0
 2616 11fc 0F00001A 		bne	.L342
 2617 1200 100000EA 		b	.L312
 2618              	.LVL314:
 2619              	.L317:
 2620              	.LBB106:
1129:../lib/fat.c  ****                 if(!cluster_num_next)
 2621              		.loc 1 1129 0
 2622 1204 000098E5 		ldr	r0, [r8, #0]
 2623 1208 0A10A0E1 		mov	r1, sl
 2624 120c 3CFCFFEB 		bl	fat_get_next_cluster
 2625              	.LVL315:
1130:../lib/fat.c  ****                 {
 2626              		.loc 1 1130 0
 2627 1210 000050E3 		cmp	r0, #0
1128:../lib/fat.c  ****                 cluster_num_next = fat_get_next_cluster(fd->fs, cluster_num);
 2628              		.loc 1 1128 0
 2629 1214 044067E0 		rsb	r4, r7, r4
 2630              	.LVL316:
1130:../lib/fat.c  ****                 {
 2631              		.loc 1 1130 0
 2632 1218 0700001A 		bne	.L324
1132:../lib/fat.c  ****                         return -1; /* current file position points beyond end of file */
 2633              		.loc 1 1132 0
 2634 121c 000054E3 		cmp	r4, #0
 2635 1220 CDFFFF1A 		bne	.L311
1136:../lib/fat.c  ****                     if(!cluster_num_next)
 2636              		.loc 1 1136 0
 2637 1224 000098E5 		ldr	r0, [r8, #0]
 2638 1228 0A10A0E1 		mov	r1, sl
 2639 122c 0120A0E3 		mov	r2, #1
 2640 1230 CCFCFFEB 		bl	fat_append_clusters
 2641              	.LVL317:
1137:../lib/fat.c  ****                         return 0;
 2642              		.loc 1 1137 0
 2643 1234 000050E3 		cmp	r0, #0
 2644 1238 E9FFFF0A 		beq	.L316
 2645              	.LVL318:
 2646              	.L324:
1130:../lib/fat.c  ****                 {
 2647              		.loc 1 1130 0
 2648 123c 00A0A0E1 		mov	sl, r0
 2649              	.LVL319:
 2650              	.L342:
1126:../lib/fat.c  ****             {
 2651              		.loc 1 1126 0 discriminator 1
 2652 1240 070054E1 		cmp	r4, r7
 2653 1244 EEFFFF2A 		bcs	.L317
 2654              	.LVL320:
 2655              	.L312:
1137:../lib/fat.c  ****                         return 0;
 2656              		.loc 1 1137 0
 2657 1248 00609DE5 		ldr	r6, [sp, #0]
 2658              	.LVL321:
 2659              	.L322:
 2660              	.LBE106:
 2661              	.LBB107:
1150:../lib/fat.c  ****         uint16_t write_length = cluster_size - first_cluster_offset;
 2662              		.loc 1 1150 0
 2663 124c 005098E5 		ldr	r5, [r8, #0]
 2664 1250 0A10A0E1 		mov	r1, sl
 2665 1254 0500A0E1 		mov	r0, r5
 2666 1258 4AFDFFEB 		bl	fat_cluster_offset
 2667              	.LVL322:
1151:../lib/fat.c  ****         if(write_length > buffer_left)
 2668              		.loc 1 1151 0
 2669 125c 07406BE0 		rsb	r4, fp, r7
 2670 1260 0448A0E1 		mov	r4, r4, asl #16
 2671 1264 2448A0E1 		mov	r4, r4, lsr #16
1150:../lib/fat.c  ****         uint16_t write_length = cluster_size - first_cluster_offset;
 2672              		.loc 1 1150 0
 2673 1268 0B0090E0 		adds	r0, r0, fp
 2674 126c 0010A1E2 		adc	r1, r1, #0
 2675              	.LVL323:
1152:../lib/fat.c  ****             write_length = buffer_left;
 2676              		.loc 1 1152 0
 2677 1270 060054E1 		cmp	r4, r6
1153:../lib/fat.c  **** 
 2678              		.loc 1 1153 0
 2679 1274 0648A081 		movhi	r4, r6, asl #16
 2680              	.LVL324:
 2681 1278 2448A081 		movhi	r4, r4, lsr #16
 2682              	.LVL325:
1156:../lib/fat.c  ****             break;
 2683              		.loc 1 1156 0
 2684 127c 005095E5 		ldr	r5, [r5, #0]
 2685 1280 0920A0E1 		mov	r2, r9
 2686 1284 0430A0E1 		mov	r3, r4
 2687 1288 08C095E5 		ldr	ip, [r5, #8]
 2688 128c 0FE0A0E1 		mov	lr, pc
 2689 1290 1CFF2FE1 		bx	ip
 2690              	.LVL326:
 2691 1294 000050E3 		cmp	r0, #0
 2692 1298 1E00000A 		beq	.L319
1162:../lib/fat.c  **** 
 2693              		.loc 1 1162 0
 2694 129c 383088E2 		add	r3, r8, #56
 2695 12a0 0C0093E8 		ldmia	r3, {r2-r3}
1160:../lib/fat.c  ****         buffer_left -= write_length;
 2696              		.loc 1 1160 0
 2697 12a4 049089E0 		add	r9, r9, r4
 2698              	.LVL327:
1162:../lib/fat.c  **** 
 2699              		.loc 1 1162 0
 2700 12a8 042092E0 		adds	r2, r2, r4
1161:../lib/fat.c  ****         fd->pos += write_length;
 2701              		.loc 1 1161 0
 2702 12ac 066064E0 		rsb	r6, r4, r6
 2703              	.LVL328:
1164:../lib/fat.c  ****         {
 2704              		.loc 1 1164 0
 2705 12b0 04408BE0 		add	r4, fp, r4
 2706              	.LVL329:
1162:../lib/fat.c  **** 
 2707              		.loc 1 1162 0
 2708 12b4 0030A3E2 		adc	r3, r3, #0
1164:../lib/fat.c  ****         {
 2709              		.loc 1 1164 0
 2710 12b8 070054E1 		cmp	r4, r7
1162:../lib/fat.c  **** 
 2711              		.loc 1 1162 0
 2712 12bc 382088E5 		str	r2, [r8, #56]
 2713 12c0 3C3088E5 		str	r3, [r8, #60]
1164:../lib/fat.c  ****         {
 2714              		.loc 1 1164 0
 2715 12c4 100000BA 		blt	.L320
 2716              	.LBB103:
1167:../lib/fat.c  ****             if(!cluster_num_next && buffer_left > 0)
 2717              		.loc 1 1167 0
 2718 12c8 000098E5 		ldr	r0, [r8, #0]
 2719 12cc 0A10A0E1 		mov	r1, sl
 2720 12d0 0BFCFFEB 		bl	fat_get_next_cluster
 2721              	.LVL330:
1168:../lib/fat.c  ****                 /* we reached the last cluster, append a new one */
 2722              		.loc 1 1168 0
 2723 12d4 013070E2 		rsbs	r3, r0, #1
 2724 12d8 0030A033 		movcc	r3, #0
 2725 12dc 000056E3 		cmp	r6, #0
 2726 12e0 0030A003 		moveq	r3, #0
 2727 12e4 000053E3 		cmp	r3, #0
1170:../lib/fat.c  ****             if(!cluster_num_next)
 2728              		.loc 1 1170 0
 2729 12e8 00009815 		ldrne	r0, [r8, #0]
 2730              	.LVL331:
 2731 12ec 0A10A011 		movne	r1, sl
 2732 12f0 0120A013 		movne	r2, #1
 2733 12f4 9BFCFF1B 		blne	fat_append_clusters
 2734              	.LVL332:
 2735              	.L321:
1171:../lib/fat.c  ****             {
 2736              		.loc 1 1171 0
 2737 12f8 000050E3 		cmp	r0, #0
1173:../lib/fat.c  ****                 break;
 2738              		.loc 1 1173 0
 2739 12fc 40008805 		streq	r0, [r8, #64]
1174:../lib/fat.c  ****             }
 2740              		.loc 1 1174 0
 2741 1300 0400000A 		beq	.L319
 2742              	.L325:
1171:../lib/fat.c  ****             {
 2743              		.loc 1 1171 0
 2744 1304 00A0A0E1 		mov	sl, r0
 2745              	.LVL333:
1178:../lib/fat.c  ****         }
 2746              		.loc 1 1178 0
 2747 1308 00B0A0E3 		mov	fp, #0
 2748              	.LVL334:
 2749              	.L320:
 2750              	.LBE103:
 2751              	.LBE107:
1183:../lib/fat.c  **** 
 2752              		.loc 1 1183 0
 2753 130c 000056E3 		cmp	r6, #0
 2754              	.LBB108:
1181:../lib/fat.c  **** 
 2755              		.loc 1 1181 0
 2756 1310 40A088E5 		str	sl, [r8, #64]
 2757              	.LBE108:
1183:../lib/fat.c  **** 
 2758              		.loc 1 1183 0
 2759 1314 CCFFFF1A 		bne	.L322
 2760              	.LVL335:
 2761              	.L319:
1186:../lib/fat.c  ****     {
 2762              		.loc 1 1186 0
 2763 1318 2C7098E5 		ldr	r7, [r8, #44]
 2764              	.LVL336:
 2765 131c 383088E2 		add	r3, r8, #56
 2766 1320 0C0093E8 		ldmia	r3, {r2-r3}
 2767 1324 0740A0E1 		mov	r4, r7
 2768 1328 0050A0E3 		mov	r5, #0
 2769 132c 030055E1 		cmp	r5, r3
 2770              		it eq
 2771 1330 02005401 		cmpeq	r4, r2
 2772 1334 0800002A 		bcs	.L323
 2773              	.LVL337:
 2774              	.LBB109:
1193:../lib/fat.c  **** 
 2775              		.loc 1 1193 0
 2776 1338 2C2088E5 		str	r2, [r8, #44]
1197:../lib/fat.c  ****         {
 2777              		.loc 1 1197 0
 2778 133c 000098E5 		ldr	r0, [r8, #0]
 2779 1340 041088E2 		add	r1, r8, #4
 2780 1344 36FDFFEB 		bl	fat_write_dir_entry
 2781              	.LVL338:
 2782 1348 050050E1 		cmp	r0, r5
1203:../lib/fat.c  ****             fd->pos = size_old;
 2783              		.loc 1 1203 0
 2784 134c 38609805 		ldreq	r6, [r8, #56]
 2785              	.LVL339:
1204:../lib/fat.c  ****         }
 2786              		.loc 1 1204 0
 2787 1350 38408805 		streq	r4, [r8, #56]
 2788 1354 3C508805 		streq	r5, [r8, #60]
1203:../lib/fat.c  ****             fd->pos = size_old;
 2789              		.loc 1 1203 0
 2790 1358 06606700 		rsbeq	r6, r7, r6
 2791              	.LVL340:
 2792              	.L323:
 2793              	.LBE109:
1209:../lib/fat.c  **** }
 2794              		.loc 1 1209 0
 2795 135c 00309DE5 		ldr	r3, [sp, #0]
 2796 1360 030066E0 		rsb	r0, r6, r3
 2797              	.LVL341:
 2798              	.L310:
1210:../lib/fat.c  **** #endif
 2799              		.loc 1 1210 0
 2800 1364 F84FBDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 2801 1368 1EFF2FE1 		bx	lr
 2802              		.cfi_endproc
 2803              	.LFE14:
 2805              		.align	2
 2806              		.global	fat_resize_file
 2808              	fat_resize_file:
 2809              	.LFB16:
1305:../lib/fat.c  ****     if(!fd)
 2810              		.loc 1 1305 0
 2811              		.cfi_startproc
 2812              		@ Function supports interworking.
 2813              		@ args = 0, pretend = 0, frame = 8
 2814              		@ frame_needed = 0, uses_anonymous_args = 0
 2815              	.LVL342:
 2816 136c F3472DE9 		stmfd	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 2817              	.LCFI17:
 2818              		.cfi_def_cfa_offset 40
 2819              		.cfi_offset 0, -40
 2820              		.cfi_offset 1, -36
 2821              		.cfi_offset 4, -32
 2822              		.cfi_offset 5, -28
 2823              		.cfi_offset 6, -24
 2824              		.cfi_offset 7, -20
 2825              		.cfi_offset 8, -16
 2826              		.cfi_offset 9, -12
 2827              		.cfi_offset 10, -8
 2828              		.cfi_offset 14, -4
1306:../lib/fat.c  ****         return 0;
 2829              		.loc 1 1306 0
 2830 1370 006050E2 		subs	r6, r0, #0
1305:../lib/fat.c  ****     if(!fd)
 2831              		.loc 1 1305 0
 2832 1374 0180A0E1 		mov	r8, r1
1306:../lib/fat.c  ****         return 0;
 2833              		.loc 1 1306 0
 2834 1378 0100001A 		bne	.L344
 2835              	.LVL343:
 2836              	.L352:
 2837              	.LBB116:
1307:../lib/fat.c  **** 
 2838              		.loc 1 1307 0
 2839 137c 0000A0E3 		mov	r0, #0
 2840 1380 550000EA 		b	.L345
 2841              	.LVL344:
 2842              	.L344:
 2843              	.LBE116:
1310:../lib/fat.c  ****     uint32_t size_new = size;
 2844              		.loc 1 1310 0
 2845 1384 003096E5 		ldr	r3, [r6, #0]
1309:../lib/fat.c  ****     uint16_t cluster_size = fd->fs->header.cluster_size;
 2846              		.loc 1 1309 0
 2847 1388 287096E5 		ldr	r7, [r6, #40]
 2848              	.LVL345:
1310:../lib/fat.c  ****     uint32_t size_new = size;
 2849              		.loc 1 1310 0
 2850 138c BA41D3E1 		ldrh	r4, [r3, #26]
 2851              	.LVL346:
1315:../lib/fat.c  ****             /* the file stays empty */
 2852              		.loc 1 1315 0
 2853 1390 073091E1 		orrs	r3, r1, r7
 2854              	.LVL347:
 2855 1394 0150A011 		movne	r5, r1
 2856 1398 0700001A 		bne	.L347
 2857 139c 440000EA 		b	.L348
 2858              	.LVL348:
 2859              	.L350:
 2860              	.LBB117:
1323:../lib/fat.c  ****             if(cluster_num_next)
 2861              		.loc 1 1323 0
 2862 13a0 000096E5 		ldr	r0, [r6, #0]
 2863 13a4 0710A0E1 		mov	r1, r7
 2864 13a8 D5FBFFEB 		bl	fat_get_next_cluster
 2865              	.LVL349:
1324:../lib/fat.c  ****             {
 2866              		.loc 1 1324 0
 2867 13ac 000050E3 		cmp	r0, #0
 2868 13b0 0500000A 		beq	.L349
 2869              	.LVL350:
1304:../lib/fat.c  **** {
 2870              		.loc 1 1304 0
 2871 13b4 055064E0 		rsb	r5, r4, r5
 2872              	.LVL351:
1326:../lib/fat.c  ****                 size_new -= cluster_size;
 2873              		.loc 1 1326 0
 2874 13b8 0070A0E1 		mov	r7, r0
 2875              	.LVL352:
 2876              	.L347:
 2877              	.LBE117:
1320:../lib/fat.c  ****         {
 2878              		.loc 1 1320 0 discriminator 1
 2879 13bc 040055E1 		cmp	r5, r4
 2880 13c0 F6FFFF8A 		bhi	.L350
1335:../lib/fat.c  ****         {
 2881              		.loc 1 1335 0
 2882 13c4 000057E3 		cmp	r7, #0
 2883 13c8 0C00001A 		bne	.L353
 2884              	.L349:
 2885              	.LVL353:
 2886              	.LBB118:
1340:../lib/fat.c  ****             cluster_t cluster_new_chain = fat_append_clusters(fd->fs, cluster_num, cluster_count);
 2887              		.loc 1 1340 0
 2888 13cc 040085E0 		add	r0, r5, r4
 2889 13d0 0410A0E1 		mov	r1, r4
 2890 13d4 010040E2 		sub	r0, r0, #1
 2891 13d8 FEFFFFEB 		bl	__udivsi3
 2892              	.LVL354:
1341:../lib/fat.c  ****             if(!cluster_new_chain)
 2893              		.loc 1 1341 0
 2894 13dc 0710A0E1 		mov	r1, r7
1340:../lib/fat.c  ****             cluster_t cluster_new_chain = fat_append_clusters(fd->fs, cluster_num, cluster_count);
 2895              		.loc 1 1340 0
 2896 13e0 0020A0E1 		mov	r2, r0
1341:../lib/fat.c  ****             if(!cluster_new_chain)
 2897              		.loc 1 1341 0
 2898 13e4 000096E5 		ldr	r0, [r6, #0]
 2899 13e8 5EFCFFEB 		bl	fat_append_clusters
 2900              	.LVL355:
1342:../lib/fat.c  ****                 return 0;
 2901              		.loc 1 1342 0
 2902 13ec 000050E3 		cmp	r0, #0
 2903 13f0 E1FFFF0A 		beq	.L352
1345:../lib/fat.c  ****             {
 2904              		.loc 1 1345 0
 2905 13f4 000057E3 		cmp	r7, #0
 2906              	.LVL356:
1348:../lib/fat.c  ****             }
 2907              		.loc 1 1348 0
 2908 13f8 28008605 		streq	r0, [r6, #40]
 2909 13fc 0070A001 		moveq	r7, r0
 2910              	.LVL357:
 2911              	.L353:
 2912              	.LBE118:
1354:../lib/fat.c  ****             fd->dir_entry.cluster = 0;
 2913              		.loc 1 1354 0
 2914 1400 000058E3 		cmp	r8, #0
1355:../lib/fat.c  ****         if(!fat_write_dir_entry(fd->fs, &fd->dir_entry))
 2915              		.loc 1 1355 0
 2916 1404 28808605 		streq	r8, [r6, #40]
1353:../lib/fat.c  ****         if(size == 0)
 2917              		.loc 1 1353 0
 2918 1408 2C8086E5 		str	r8, [r6, #44]
1356:../lib/fat.c  ****             return 0;
 2919              		.loc 1 1356 0
 2920 140c 000096E5 		ldr	r0, [r6, #0]
 2921 1410 041086E2 		add	r1, r6, #4
 2922 1414 02FDFFEB 		bl	fat_write_dir_entry
 2923              	.LVL358:
 2924 1418 000050E3 		cmp	r0, #0
 2925 141c D6FFFF0A 		beq	.L352
1359:../lib/fat.c  ****         {
 2926              		.loc 1 1359 0
 2927 1420 000058E3 		cmp	r8, #0
1362:../lib/fat.c  ****         }
 2928              		.loc 1 1362 0
 2929 1424 00009605 		ldreq	r0, [r6, #0]
 2930 1428 0710A001 		moveq	r1, r7
1359:../lib/fat.c  ****         {
 2931              		.loc 1 1359 0
 2932 142c 1F00000A 		beq	.L378
 2933              	.L355:
1364:../lib/fat.c  ****         {
 2934              		.loc 1 1364 0
 2935 1430 040055E1 		cmp	r5, r4
 2936 1434 1E00008A 		bhi	.L348
1367:../lib/fat.c  ****         }
 2937              		.loc 1 1367 0
 2938 1438 00A096E5 		ldr	sl, [r6, #0]
 2939              	.LVL359:
 2940              	.LBB119:
 2941              	.LBB120:
 753:../lib/fat.c  ****         return 0;
 2942              		.loc 1 753 0
 2943 143c 00005AE3 		cmp	sl, #0
 2944 1440 01005713 		cmpne	r7, #1
 2945 1444 1A00009A 		bls	.L348
 757:../lib/fat.c  **** 
 2946              		.loc 1 757 0
 2947 1448 0710A0E1 		mov	r1, r7
 2948 144c 0A00A0E1 		mov	r0, sl
 2949 1450 ABFBFFEB 		bl	fat_get_next_cluster
 2950              	.LVL360:
 761:../lib/fat.c  ****     {
 2951              		.loc 1 761 0
 2952 1454 00C09AE5 		ldr	ip, [sl, #0]
 2953 1458 1030DCE5 		ldrb	r3, [ip, #16]	@ zero_extendqisi2
 2954 145c 0B0053E3 		cmp	r3, #11
 2955              	.LBB121:
 763:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 2956              		.loc 1 763 0
 2957 1460 0F32E003 		mvneq	r3, #-268435456
 2958              	.LBE121:
 2959              	.LBB122:
 770:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 2960              		.loc 1 770 0
 2961 1464 0030E013 		mvnne	r3, #0
 2962              	.LBE122:
 2963              	.LBB123:
 763:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 2964              		.loc 1 763 0
 2965 1468 08208DE2 		add	r2, sp, #8
 2966              	.LBE123:
 757:../lib/fat.c  **** 
 2967              		.loc 1 757 0
 2968 146c 0090A0E1 		mov	r9, r0
 2969              	.LVL361:
 2970 1470 0C108AE2 		add	r1, sl, #12
 2971 1474 030091E8 		ldmia	r1, {r0-r1}
 2972              	.LVL362:
 2973              	.LBB124:
 763:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 2974              		.loc 1 763 0
 2975 1478 04302205 		streq	r3, [r2, #-4]!
 2976              	.LVL363:
 2977              	.LBE124:
 2978              	.LBB125:
 770:../lib/fat.c  ****         if(!fs->partition->device_write(fs->header.fat_offset + (offset_t) cluster_num * sizeof(fat
 2979              		.loc 1 770 0
 2980 147c B6306211 		strneh	r3, [r2, #-6]!	@ movhi
 2981              	.LVL364:
 2982              	.LBE125:
 2983              	.LBB126:
 764:../lib/fat.c  ****             return 0;
 2984              		.loc 1 764 0
 2985 1480 0430A003 		moveq	r3, #4
 2986              	.LBE126:
 2987              	.LBB127:
 771:../lib/fat.c  ****             return 0;
 2988              		.loc 1 771 0
 2989 1484 0230A013 		movne	r3, #2
 2990 1488 9307A1E0 		umlal	r0, r1, r3, r7
 2991 148c 08C09CE5 		ldr	ip, [ip, #8]
 2992 1490 0FE0A0E1 		mov	lr, pc
 2993 1494 1CFF2FE1 		bx	ip
 2994              	.LVL365:
 2995 1498 000050E3 		cmp	r0, #0
 2996 149c 0400000A 		beq	.L348
 2997              	.LBE127:
 776:../lib/fat.c  ****         return fat_free_clusters(fs, cluster_num_next);
 2998              		.loc 1 776 0
 2999 14a0 000059E3 		cmp	r9, #0
 3000 14a4 0200000A 		beq	.L348
 777:../lib/fat.c  ****     else
 3001              		.loc 1 777 0
 3002 14a8 0A00A0E1 		mov	r0, sl
 3003 14ac 0910A0E1 		mov	r1, r9
 3004              	.LVL366:
 3005              	.L378:
 3006 14b0 C8FBFFEB 		bl	fat_free_clusters
 3007              	.LVL367:
 3008              	.L348:
 3009              	.LBE120:
 3010              	.LBE119:
1373:../lib/fat.c  ****     {
 3011              		.loc 1 1373 0
 3012 14b4 385086E2 		add	r5, r6, #56
 3013 14b8 300095E8 		ldmia	r5, {r4-r5}
 3014              	.LVL368:
 3015 14bc 0820A0E1 		mov	r2, r8
 3016 14c0 0030A0E3 		mov	r3, #0
 3017 14c4 050053E1 		cmp	r3, r5
 3018              		it eq
 3019 14c8 04005201 		cmpeq	r2, r4
 3020              	.LVL369:
1375:../lib/fat.c  ****         fd->pos_cluster = 0;
 3021              		.loc 1 1375 0
 3022 14cc 38208635 		strcc	r2, [r6, #56]
 3023 14d0 3C308635 		strcc	r3, [r6, #60]
1376:../lib/fat.c  ****     }
 3024              		.loc 1 1376 0
 3025 14d4 40308635 		strcc	r3, [r6, #64]
 3026              	.L361:
1379:../lib/fat.c  **** }
 3027              		.loc 1 1379 0
 3028 14d8 0100A0E3 		mov	r0, #1
 3029              	.LVL370:
 3030              	.L345:
1380:../lib/fat.c  **** #endif
 3031              		.loc 1 1380 0
 3032 14dc FC47BDE8 		ldmfd	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 3033 14e0 1EFF2FE1 		bx	lr
 3034              		.cfi_endproc
 3035              	.LFE16:
 3037              		.align	2
 3038              		.global	fat_seek_file
 3040              	fat_seek_file:
 3041              	.LFB15:
1250:../lib/fat.c  ****     if(!fd || !offset)
 3042              		.loc 1 1250 0
 3043              		.cfi_startproc
 3044              		@ Function supports interworking.
 3045              		@ args = 0, pretend = 0, frame = 0
 3046              		@ frame_needed = 0, uses_anonymous_args = 0
 3047              	.LVL371:
1251:../lib/fat.c  ****         return 0;
 3048              		.loc 1 1251 0
 3049 14e4 000050E3 		cmp	r0, #0
 3050 14e8 00005113 		cmpne	r1, #0
1250:../lib/fat.c  ****     if(!fd || !offset)
 3051              		.loc 1 1250 0
 3052 14ec 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 3053              	.LCFI18:
 3054              		.cfi_def_cfa_offset 16
 3055              		.cfi_offset 4, -16
 3056              		.cfi_offset 5, -12
 3057              		.cfi_offset 6, -8
 3058              		.cfi_offset 14, -4
1250:../lib/fat.c  ****     if(!fd || !offset)
 3059              		.loc 1 1250 0
 3060 14f0 FF2002E2 		and	r2, r2, #255
 3061              	.LVL372:
1251:../lib/fat.c  ****         return 0;
 3062              		.loc 1 1251 0
 3063 14f4 0040A0E1 		mov	r4, r0
 3064 14f8 0160A0E1 		mov	r6, r1
 3065 14fc 0000A013 		movne	r0, #0
 3066 1500 0100A003 		moveq	r0, #1
 3067              	.LVL373:
 3068 1504 0100001A 		bne	.L380
 3069              	.LVL374:
 3070              	.L387:
1252:../lib/fat.c  **** 
 3071              		.loc 1 1252 0
 3072 1508 0000A0E3 		mov	r0, #0
 3073 150c 1D0000EA 		b	.L381
 3074              	.LVL375:
 3075              	.L380:
1255:../lib/fat.c  ****     {
 3076              		.loc 1 1255 0
 3077 1510 010052E3 		cmp	r2, #1
1254:../lib/fat.c  ****     switch(whence)
 3078              		.loc 1 1254 0
 3079 1514 385094E5 		ldr	r5, [r4, #56]
 3080              	.LVL376:
1255:../lib/fat.c  ****     {
 3081              		.loc 1 1255 0
 3082 1518 0500000A 		beq	.L383
 3083 151c 0200003A 		bcc	.L382
 3084 1520 020052E3 		cmp	r2, #2
 3085 1524 1700001A 		bne	.L381
 3086 1528 030000EA 		b	.L384
 3087              	.L382:
1258:../lib/fat.c  ****             break;
 3088              		.loc 1 1258 0
 3089 152c 005091E5 		ldr	r5, [r1, #0]
 3090              	.LVL377:
1259:../lib/fat.c  ****         case FAT_SEEK_CUR:
 3091              		.loc 1 1259 0
 3092 1530 040000EA 		b	.L385
 3093              	.L383:
1261:../lib/fat.c  ****             break;
 3094              		.loc 1 1261 0
 3095 1534 003091E5 		ldr	r3, [r1, #0]
 3096 1538 010000EA 		b	.L394
 3097              	.L384:
1264:../lib/fat.c  ****             break;
 3098              		.loc 1 1264 0
 3099 153c 005091E5 		ldr	r5, [r1, #0]
 3100              	.LVL378:
 3101 1540 2C3094E5 		ldr	r3, [r4, #44]
 3102              	.L394:
 3103 1544 035085E0 		add	r5, r5, r3
 3104              	.LVL379:
 3105              	.L385:
1270:../lib/fat.c  **** #if FAT_WRITE_SUPPORT
 3106              		.loc 1 1270 0
 3107 1548 2C3094E5 		ldr	r3, [r4, #44]
 3108 154c 030055E1 		cmp	r5, r3
 3109 1550 0600008A 		bhi	.L386
 3110              	.LVL380:
 3111              	.L388:
1277:../lib/fat.c  ****     fd->pos_cluster = 0;
 3112              		.loc 1 1277 0
 3113 1554 0030A0E3 		mov	r3, #0
 3114 1558 385084E5 		str	r5, [r4, #56]
 3115 155c 3C3084E5 		str	r3, [r4, #60]
1278:../lib/fat.c  **** 
 3116              		.loc 1 1278 0
 3117 1560 403084E5 		str	r3, [r4, #64]
1281:../lib/fat.c  **** }
 3118              		.loc 1 1281 0
 3119 1564 0100A0E3 		mov	r0, #1
1280:../lib/fat.c  ****     return 1;
 3120              		.loc 1 1280 0
 3121 1568 005086E5 		str	r5, [r6, #0]
1281:../lib/fat.c  **** }
 3122              		.loc 1 1281 0
 3123 156c 050000EA 		b	.L381
 3124              	.LVL381:
 3125              	.L386:
1272:../lib/fat.c  **** #endif
 3126              		.loc 1 1272 0
 3127 1570 0400A0E1 		mov	r0, r4
 3128 1574 0510A0E1 		mov	r1, r5
 3129              	.LVL382:
 3130 1578 FEFFFFEB 		bl	fat_resize_file
 3131              	.LVL383:
 3132 157c 000050E3 		cmp	r0, #0
 3133 1580 F3FFFF1A 		bne	.L388
 3134 1584 DFFFFFEA 		b	.L387
 3135              	.LVL384:
 3136              	.L381:
1282:../lib/fat.c  **** 
 3137              		.loc 1 1282 0
 3138 1588 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 3139 158c 1EFF2FE1 		bx	lr
 3140              		.cfi_endproc
 3141              	.LFE15:
 3143              		.align	2
 3144              		.global	fat_open_dir
 3146              	fat_open_dir:
 3147              	.LFB17:
1393:../lib/fat.c  ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT_ATTRIB_DIR))
 3148              		.loc 1 1393 0
 3149              		.cfi_startproc
 3150              		@ Function supports interworking.
 3151              		@ args = 0, pretend = 0, frame = 0
 3152              		@ frame_needed = 0, uses_anonymous_args = 0
 3153              	.LVL385:
1394:../lib/fat.c  ****         return 0;
 3154              		.loc 1 1394 0
 3155 1590 000050E3 		cmp	r0, #0
 3156 1594 00005113 		cmpne	r1, #0
1393:../lib/fat.c  ****     if(!fs || !dir_entry || !(dir_entry->attributes & FAT_ATTRIB_DIR))
 3157              		.loc 1 1393 0
 3158 1598 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 3159              	.LCFI19:
 3160              		.cfi_def_cfa_offset 16
 3161              		.cfi_offset 4, -16
 3162              		.cfi_offset 5, -12
 3163              		.cfi_offset 6, -8
 3164              		.cfi_offset 14, -4
1394:../lib/fat.c  ****         return 0;
 3165              		.loc 1 1394 0
 3166 159c 0150A0E1 		mov	r5, r1
 3167 15a0 0060A0E1 		mov	r6, r0
 3168 15a4 0040A013 		movne	r4, #0
 3169 15a8 0140A003 		moveq	r4, #1
 3170 15ac 0A00000A 		beq	.L398
1394:../lib/fat.c  ****         return 0;
 3171              		.loc 1 1394 0 is_stmt 0 discriminator 1
 3172 15b0 2030D1E5 		ldrb	r3, [r1, #32]	@ zero_extendqisi2
 3173 15b4 103013E2 		ands	r3, r3, #16
 3174 15b8 0700000A 		beq	.L398
 3175              	.LVL386:
1406:../lib/fat.c  ****             break;
 3176              		.loc 1 1406 0 is_stmt 1 discriminator 1
 3177 15bc 5C309FE5 		ldr	r3, .L403
 3178 15c0 782093E5 		ldr	r2, [r3, #120]
 3179 15c4 000052E3 		cmp	r2, #0
 3180 15c8 0500000A 		beq	.L400
 3181              	.LVL387:
1406:../lib/fat.c  ****             break;
 3182              		.loc 1 1406 0 is_stmt 0
 3183 15cc B82093E5 		ldr	r2, [r3, #184]
 3184 15d0 000052E3 		cmp	r2, #0
 3185 15d4 0400000A 		beq	.L401
 3186 15d8 0D0000EA 		b	.L402
 3187              	.LVL388:
 3188              	.L398:
1395:../lib/fat.c  **** 
 3189              		.loc 1 1395 0 is_stmt 1
 3190 15dc 0040A0E3 		mov	r4, #0
 3191 15e0 0B0000EA 		b	.L402
 3192              	.LVL389:
 3193              	.L400:
1402:../lib/fat.c  ****     uint8_t i;
 3194              		.loc 1 1402 0
 3195 15e4 784083E2 		add	r4, r3, #120
 3196 15e8 000000EA 		b	.L397
 3197              	.LVL390:
 3198              	.L401:
1409:../lib/fat.c  ****     }
 3199              		.loc 1 1409 0
 3200 15ec B84083E2 		add	r4, r3, #184
 3201              	.LVL391:
 3202              	.L397:
1415:../lib/fat.c  ****     dd->fs = fs;
 3203              		.loc 1 1415 0
 3204 15f0 040084E2 		add	r0, r4, #4
 3205              	.LVL392:
 3206 15f4 0510A0E1 		mov	r1, r5
 3207              	.LVL393:
 3208 15f8 3420A0E3 		mov	r2, #52
 3209 15fc FEFFFFEB 		bl	memcpy
 3210              	.LVL394:
1417:../lib/fat.c  ****     dd->entry_offset = 0;
 3211              		.loc 1 1417 0
 3212 1600 243095E5 		ldr	r3, [r5, #36]
 3213 1604 383084E5 		str	r3, [r4, #56]
1418:../lib/fat.c  **** 
 3214              		.loc 1 1418 0
 3215 1608 0030A0E3 		mov	r3, #0
1416:../lib/fat.c  ****     dd->entry_cluster = dir_entry->cluster;
 3216              		.loc 1 1416 0
 3217 160c 006084E5 		str	r6, [r4, #0]
1418:../lib/fat.c  **** 
 3218              		.loc 1 1418 0
 3219 1610 BC33C4E1 		strh	r3, [r4, #60]	@ movhi
 3220              	.L402:
1421:../lib/fat.c  **** 
 3221              		.loc 1 1421 0
 3222 1614 0400A0E1 		mov	r0, r4
 3223 1618 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 3224 161c 1EFF2FE1 		bx	lr
 3225              	.L404:
 3226              		.align	2
 3227              	.L403:
 3228 1620 00000000 		.word	.LANCHOR1
 3229              		.cfi_endproc
 3230              	.LFE17:
 3232              		.align	2
 3233              		.global	fat_close_dir
 3235              	fat_close_dir:
 3236              	.LFB18:
1435:../lib/fat.c  ****     if(dd)
 3237              		.loc 1 1435 0
 3238              		.cfi_startproc
 3239              		@ Function supports interworking.
 3240              		@ args = 0, pretend = 0, frame = 0
 3241              		@ frame_needed = 0, uses_anonymous_args = 0
 3242              		@ link register save eliminated.
 3243              	.LVL395:
1436:../lib/fat.c  **** #if USE_DYNAMIC_MEMORY
 3244              		.loc 1 1436 0
 3245 1624 000050E3 		cmp	r0, #0
1440:../lib/fat.c  **** #endif
 3246              		.loc 1 1440 0
 3247 1628 0030A013 		movne	r3, #0
 3248 162c 00308015 		strne	r3, [r0, #0]
 3249 1630 1EFF2FE1 		bx	lr
 3250              		.cfi_endproc
 3251              	.LFE18:
 3253              		.align	2
 3254              		.global	fat_reset_dir
 3256              	fat_reset_dir:
 3257              	.LFB20:
1567:../lib/fat.c  ****     if(!dd)
 3258              		.loc 1 1567 0
 3259              		.cfi_startproc
 3260              		@ Function supports interworking.
 3261              		@ args = 0, pretend = 0, frame = 0
 3262              		@ frame_needed = 0, uses_anonymous_args = 0
 3263              		@ link register save eliminated.
 3264              	.LVL396:
1568:../lib/fat.c  ****         return 0;
 3265              		.loc 1 1568 0
 3266 1634 000050E3 		cmp	r0, #0
 3267 1638 1EFF2F01 		bxeq	lr
1571:../lib/fat.c  ****     dd->entry_offset = 0;
 3268              		.loc 1 1571 0
 3269 163c 283090E5 		ldr	r3, [r0, #40]
 3270 1640 383080E5 		str	r3, [r0, #56]
1572:../lib/fat.c  ****     return 1;
 3271              		.loc 1 1572 0
 3272 1644 0030A0E3 		mov	r3, #0
 3273 1648 BC33C0E1 		strh	r3, [r0, #60]	@ movhi
1573:../lib/fat.c  **** }
 3274              		.loc 1 1573 0
 3275 164c 0100A0E3 		mov	r0, #1
 3276              	.LVL397:
1574:../lib/fat.c  **** 
 3277              		.loc 1 1574 0
 3278 1650 1EFF2FE1 		bx	lr
 3279              		.cfi_endproc
 3280              	.LFE20:
 3282              		.align	2
 3283              		.global	fat_read_dir
 3285              	fat_read_dir:
 3286              	.LFB19:
1454:../lib/fat.c  ****     if(!dd || !dir_entry)
 3287              		.loc 1 1454 0
 3288              		.cfi_startproc
 3289              		@ Function supports interworking.
 3290              		@ args = 0, pretend = 0, frame = 48
 3291              		@ frame_needed = 0, uses_anonymous_args = 0
 3292              	.LVL398:
 3293 1654 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3294              	.LCFI20:
 3295              		.cfi_def_cfa_offset 36
 3296              		.cfi_offset 4, -36
 3297              		.cfi_offset 5, -32
 3298              		.cfi_offset 6, -28
 3299              		.cfi_offset 7, -24
 3300              		.cfi_offset 8, -20
 3301              		.cfi_offset 9, -16
 3302              		.cfi_offset 10, -12
 3303              		.cfi_offset 11, -8
 3304              		.cfi_offset 14, -4
1455:../lib/fat.c  ****         return 0;
 3305              		.loc 1 1455 0
 3306 1658 000050E3 		cmp	r0, #0
 3307 165c 00005113 		cmpne	r1, #0
1454:../lib/fat.c  ****     if(!dd || !dir_entry)
 3308              		.loc 1 1454 0
 3309 1660 3CD04DE2 		sub	sp, sp, #60
 3310              	.LCFI21:
 3311              		.cfi_def_cfa_offset 96
1455:../lib/fat.c  ****         return 0;
 3312              		.loc 1 1455 0
 3313 1664 0150A0E1 		mov	r5, r1
 3314 1668 0070A0E1 		mov	r7, r0
 3315 166c 00A0A013 		movne	sl, #0
 3316 1670 01A0A003 		moveq	sl, #1
 3317 1674 5400000A 		beq	.L426
 3318              	.LVL399:
 3319              	.LBB131:
 3320              	.LBB132:
1459:../lib/fat.c  ****     const struct fat_header_struct* header = &fs->header;
 3321              		.loc 1 1459 0
 3322 1678 006090E5 		ldr	r6, [r0, #0]
 3323              	.LVL400:
1463:../lib/fat.c  ****     struct fat_read_dir_callback_arg arg;
 3324              		.loc 1 1463 0
 3325 167c BC43D0E1 		ldrh	r4, [r0, #60]
1461:../lib/fat.c  ****     cluster_t cluster_num = dd->entry_cluster;
 3326              		.loc 1 1461 0
 3327 1680 BA91D6E1 		ldrh	r9, [r6, #26]
 3328              	.LVL401:
1466:../lib/fat.c  ****     {
 3329              		.loc 1 1466 0
 3330 1684 090054E1 		cmp	r4, r9
1462:../lib/fat.c  ****     uint16_t cluster_offset = dd->entry_offset;
 3331              		.loc 1 1462 0
 3332 1688 388090E5 		ldr	r8, [r0, #56]
 3333              	.LVL402:
1466:../lib/fat.c  ****     {
 3334              		.loc 1 1466 0
 3335 168c 0200003A 		bcc	.L415
 3336              	.LVL403:
 3337              	.L423:
1473:../lib/fat.c  ****         return 0;
 3338              		.loc 1 1473 0
 3339 1690 0700A0E1 		mov	r0, r7
 3340 1694 FEFFFFEB 		bl	fat_reset_dir
 3341              	.LVL404:
 3342 1698 4B0000EA 		b	.L426
 3343              	.LVL405:
 3344              	.L415:
1478:../lib/fat.c  ****     memset(dir_entry, 0, sizeof(*dir_entry));
 3345              		.loc 1 1478 0
 3346 169c 0A10A0E1 		mov	r1, sl
 3347              	.LVL406:
 3348 16a0 0C20A0E3 		mov	r2, #12
 3349 16a4 10008DE2 		add	r0, sp, #16
 3350              	.LVL407:
 3351 16a8 FEFFFFEB 		bl	memset
 3352              	.LVL408:
1479:../lib/fat.c  ****     arg.dir_entry = dir_entry;
 3353              		.loc 1 1479 0
 3354 16ac 0500A0E1 		mov	r0, r5
 3355 16b0 0A10A0E1 		mov	r1, sl
 3356 16b4 3420A0E3 		mov	r2, #52
 3357 16b8 FEFFFFEB 		bl	memset
 3358              	.LVL409:
1483:../lib/fat.c  ****     {
 3359              		.loc 1 1483 0
 3360 16bc 000058E3 		cmp	r8, #0
1480:../lib/fat.c  **** 
 3361              		.loc 1 1480 0
 3362 16c0 10508DE5 		str	r5, [sp, #16]
1483:../lib/fat.c  ****     {
 3363              		.loc 1 1483 0
 3364 16c4 3700001A 		bne	.L419
1486:../lib/fat.c  ****             cluster_num = header->root_dir_cluster;
 3365              		.loc 1 1486 0
 3366 16c8 003096E5 		ldr	r3, [r6, #0]
 3367 16cc 1030D3E5 		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 3368 16d0 0B0053E3 		cmp	r3, #11
1490:../lib/fat.c  ****     }
 3369              		.loc 1 1490 0
 3370 16d4 BC91D611 		ldrneh	r9, [r6, #28]
 3371              	.LVL410:
 3372 16d8 B432D611 		ldrneh	r3, [r6, #36]
 3373 16dc 09906310 		rsbne	r9, r3, r9
 3374 16e0 0998A011 		movne	r9, r9, asl #16
1487:../lib/fat.c  ****         else
 3375              		.loc 1 1487 0
 3376 16e4 2C809605 		ldreq	r8, [r6, #44]
 3377              	.LVL411:
1490:../lib/fat.c  ****     }
 3378              		.loc 1 1490 0
 3379 16e8 2998A011 		movne	r9, r9, lsr #16
 3380              	.LVL412:
 3381 16ec 2D0000EA 		b	.L419
 3382              	.LVL413:
 3383              	.L425:
 3384              	.LBB133:
1498:../lib/fat.c  ****         offset_t pos = cluster_offset;
 3385              		.loc 1 1498 0
 3386 16f0 09306AE0 		rsb	r3, sl, r9
1499:../lib/fat.c  ****         if(cluster_num == 0)
 3387              		.loc 1 1499 0
 3388 16f4 0050A0E3 		mov	r5, #0
1498:../lib/fat.c  ****         offset_t pos = cluster_offset;
 3389              		.loc 1 1498 0
 3390 16f8 0338A0E1 		mov	r3, r3, asl #16
1500:../lib/fat.c  ****             pos += header->root_dir_offset;
 3391              		.loc 1 1500 0
 3392 16fc 050058E1 		cmp	r8, r5
1498:../lib/fat.c  ****         offset_t pos = cluster_offset;
 3393              		.loc 1 1498 0
 3394 1700 2338A0E1 		mov	r3, r3, lsr #16
 3395              	.LVL414:
1500:../lib/fat.c  ****             pos += header->root_dir_offset;
 3396              		.loc 1 1500 0
 3397 1704 0400001A 		bne	.L420
1501:../lib/fat.c  ****         else
 3398              		.loc 1 1501 0
 3399 1708 241086E2 		add	r1, r6, #36
 3400 170c 030091E8 		ldmia	r1, {r0-r1}
 3401 1710 0A0090E0 		adds	r0, r0, sl
 3402 1714 0510A1E0 		adc	r1, r1, r5
 3403              	.LVL415:
 3404 1718 060000EA 		b	.L421
 3405              	.LVL416:
 3406              	.L420:
1503:../lib/fat.c  **** 
 3407              		.loc 1 1503 0
 3408 171c 0600A0E1 		mov	r0, r6
 3409 1720 0810A0E1 		mov	r1, r8
 3410 1724 0C308DE5 		str	r3, [sp, #12]
 3411 1728 16FCFFEB 		bl	fat_cluster_offset
 3412              	.LVL417:
 3413 172c 0C309DE5 		ldr	r3, [sp, #12]
 3414 1730 0A0090E0 		adds	r0, r0, sl
 3415 1734 0510A1E0 		adc	r1, r1, r5
 3416              	.LVL418:
 3417              	.L421:
1506:../lib/fat.c  ****                                                 buffer,
 3418              		.loc 1 1506 0
 3419 1738 00C096E5 		ldr	ip, [r6, #0]
1505:../lib/fat.c  ****         if(!fs->partition->device_read_interval(pos,
 3420              		.loc 1 1505 0
 3421 173c 0040A0E3 		mov	r4, #0
1506:../lib/fat.c  ****                                                 buffer,
 3422              		.loc 1 1506 0
 3423 1740 08088DE8 		stmia	sp, {r3, fp}
 3424 1744 10308DE2 		add	r3, sp, #16
 3425              	.LVL419:
 3426 1748 08308DE5 		str	r3, [sp, #8]
1505:../lib/fat.c  ****         if(!fs->partition->device_read_interval(pos,
 3427              		.loc 1 1505 0
 3428 174c 14408DE5 		str	r4, [sp, #20]
1506:../lib/fat.c  ****                                                 buffer,
 3429              		.loc 1 1506 0
 3430 1750 1C208DE2 		add	r2, sp, #28
 3431 1754 2030A0E3 		mov	r3, #32
 3432 1758 04C09CE5 		ldr	ip, [ip, #4]
 3433 175c 0FE0A0E1 		mov	lr, pc
 3434 1760 1CFF2FE1 		bx	ip
 3435              	.LVL420:
 3436 1764 000050E3 		cmp	r0, #0
 3437 1768 1800000A 		beq	.L414
1515:../lib/fat.c  **** 
 3438              		.loc 1 1515 0
 3439 176c 14309DE5 		ldr	r3, [sp, #20]
 3440 1770 03A08AE0 		add	sl, sl, r3
 3441              	.LVL421:
 3442 1774 0AA8A0E1 		mov	sl, sl, asl #16
 3443 1778 2AA8A0E1 		mov	sl, sl, lsr #16
 3444              	.LVL422:
1517:../lib/fat.c  ****         {
 3445              		.loc 1 1517 0
 3446 177c 09005AE1 		cmp	sl, r9
 3447 1780 0A00003A 		bcc	.L422
1522:../lib/fat.c  ****             {
 3448              		.loc 1 1522 0
 3449 1784 0810A0E1 		mov	r1, r8
 3450 1788 0600A0E1 		mov	r0, r6
 3451 178c DCFAFFEB 		bl	fat_get_next_cluster
 3452              	.LVL423:
 3453 1790 008050E2 		subs	r8, r0, #0
 3454 1794 0400001A 		bne	.L430
1529:../lib/fat.c  ****             {
 3455              		.loc 1 1529 0
 3456 1798 1930DDE5 		ldrb	r3, [sp, #25]	@ zero_extendqisi2
 3457 179c 040053E1 		cmp	r3, r4
 3458 17a0 0500001A 		bne	.L424
 3459 17a4 B9FFFFEA 		b	.L423
 3460              	.LVL424:
 3461              	.L419:
1506:../lib/fat.c  ****                                                 buffer,
 3462              		.loc 1 1506 0
 3463 17a8 2CB09FE5 		ldr	fp, .L434
 3464              	.LVL425:
 3465              	.L430:
 3466              	.LBE133:
 3467              	.LBE132:
 3468              	.LBE131:
1454:../lib/fat.c  ****     if(!dd || !dir_entry)
 3469              		.loc 1 1454 0
 3470 17ac 04A0A0E1 		mov	sl, r4
 3471              	.LVL426:
 3472              	.L422:
 3473              	.LBB135:
 3474              	.LBB134:
1495:../lib/fat.c  ****     {
 3475              		.loc 1 1495 0
 3476 17b0 1930DDE5 		ldrb	r3, [sp, #25]	@ zero_extendqisi2
 3477 17b4 000053E3 		cmp	r3, #0
 3478 17b8 CCFFFF0A 		beq	.L425
 3479              	.LVL427:
 3480              	.L424:
1549:../lib/fat.c  ****     dd->entry_offset = cluster_offset;
 3481              		.loc 1 1549 0
 3482 17bc 388087E5 		str	r8, [r7, #56]
1550:../lib/fat.c  **** 
 3483              		.loc 1 1550 0
 3484 17c0 BCA3C7E1 		strh	sl, [r7, #60]	@ movhi
1552:../lib/fat.c  **** }
 3485              		.loc 1 1552 0
 3486 17c4 1900DDE5 		ldrb	r0, [sp, #25]	@ zero_extendqisi2
 3487 17c8 000000EA 		b	.L414
 3488              	.LVL428:
 3489              	.L426:
 3490              	.LBE134:
 3491              	.LBE135:
1456:../lib/fat.c  **** 
 3492              		.loc 1 1456 0
 3493 17cc 0000A0E3 		mov	r0, #0
 3494              	.L414:
1553:../lib/fat.c  **** 
 3495              		.loc 1 1553 0
 3496 17d0 3CD08DE2 		add	sp, sp, #60
 3497 17d4 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3498 17d8 1EFF2FE1 		bx	lr
 3499              	.L435:
 3500              		.align	2
 3501              	.L434:
 3502 17dc 00000000 		.word	fat_dir_entry_read_callback
 3503              		.cfi_endproc
 3504              	.LFE19:
 3506              		.align	2
 3507              		.global	fat_get_dir_entry_of_path
 3509              	fat_get_dir_entry_of_path:
 3510              	.LFB10:
 852:../lib/fat.c  ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 3511              		.loc 1 852 0
 3512              		.cfi_startproc
 3513              		@ Function supports interworking.
 3514              		@ args = 0, pretend = 0, frame = 0
 3515              		@ frame_needed = 0, uses_anonymous_args = 0
 3516              	.LVL429:
 853:../lib/fat.c  ****         return 0;
 3517              		.loc 1 853 0
 3518 17e0 000050E3 		cmp	r0, #0
 3519 17e4 00005113 		cmpne	r1, #0
 852:../lib/fat.c  ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 3520              		.loc 1 852 0
 3521 17e8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 3522              	.LCFI22:
 3523              		.cfi_def_cfa_offset 32
 3524              		.cfi_offset 4, -32
 3525              		.cfi_offset 5, -28
 3526              		.cfi_offset 6, -24
 3527              		.cfi_offset 7, -20
 3528              		.cfi_offset 8, -16
 3529              		.cfi_offset 9, -12
 3530              		.cfi_offset 10, -8
 3531              		.cfi_offset 14, -4
 852:../lib/fat.c  ****     if(!fs || !path || path[0] == '\0' || !dir_entry)
 3532              		.loc 1 852 0
 3533 17ec 0250A0E1 		mov	r5, r2
 853:../lib/fat.c  ****         return 0;
 3534              		.loc 1 853 0
 3535 17f0 0140A0E1 		mov	r4, r1
 3536 17f4 0080A0E1 		mov	r8, r0
 3537 17f8 4100000A 		beq	.L437
 853:../lib/fat.c  ****         return 0;
 3538              		.loc 1 853 0 is_stmt 0 discriminator 1
 3539 17fc 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 3540 1800 000053E3 		cmp	r3, #0
 3541 1804 3E00000A 		beq	.L437
 3542 1808 000052E3 		cmp	r2, #0
 3543 180c 3C00000A 		beq	.L437
 856:../lib/fat.c  ****         ++path;
 3544              		.loc 1 856 0 is_stmt 1
 3545 1810 2F0053E3 		cmp	r3, #47
 857:../lib/fat.c  **** 
 3546              		.loc 1 857 0
 3547 1814 01408102 		addeq	r4, r1, #1
 3548              	.LVL430:
 860:../lib/fat.c  ****     dir_entry->attributes = FAT_ATTRIB_DIR;
 3549              		.loc 1 860 0
 3550 1818 0200A0E1 		mov	r0, r2
 3551              	.LVL431:
 3552 181c 0010A0E3 		mov	r1, #0
 3553 1820 3420A0E3 		mov	r2, #52
 3554              	.LVL432:
 3555 1824 FEFFFFEB 		bl	memset
 3556              	.LVL433:
 861:../lib/fat.c  **** 
 3557              		.loc 1 861 0
 3558 1828 1030A0E3 		mov	r3, #16
 3559 182c 2030C5E5 		strb	r3, [r5, #32]
 3560              	.L447:
 3561              	.LBB136:
 865:../lib/fat.c  ****             return 1;
 3562              		.loc 1 865 0
 3563 1830 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 3564 1834 000053E3 		cmp	r3, #0
 3565 1838 0100001A 		bne	.L439
 3566              	.L444:
 866:../lib/fat.c  **** 
 3567              		.loc 1 866 0
 3568 183c 0100A0E3 		mov	r0, #1
 3569 1840 300000EA 		b	.L440
 3570              	.L439:
 868:../lib/fat.c  ****         if(!dd)
 3571              		.loc 1 868 0
 3572 1844 0800A0E1 		mov	r0, r8
 3573 1848 0510A0E1 		mov	r1, r5
 3574 184c FEFFFFEB 		bl	fat_open_dir
 3575              	.LVL434:
 869:../lib/fat.c  ****             break;
 3576              		.loc 1 869 0
 3577 1850 007050E2 		subs	r7, r0, #0
 3578 1854 2A00000A 		beq	.L437
 873:../lib/fat.c  ****         uint8_t length_to_sep;
 3579              		.loc 1 873 0
 3580 1858 0400A0E1 		mov	r0, r4
 3581              	.LVL435:
 3582 185c 2F10A0E3 		mov	r1, #47
 3583 1860 FEFFFFEB 		bl	strchr
 3584              	.LVL436:
 875:../lib/fat.c  ****         {
 3585              		.loc 1 875 0
 3586 1864 000050E3 		cmp	r0, #0
 877:../lib/fat.c  ****             ++sub_path;
 3587              		.loc 1 877 0
 3588 1868 00606410 		rsbne	r6, r4, r0
 3589 186c FF600612 		andne	r6, r6, #255
 3590              	.LVL437:
 878:../lib/fat.c  ****         }
 3591              		.loc 1 878 0
 3592 1870 01A08012 		addne	sl, r0, #1
 3593              	.LVL438:
 3594 1874 1700001A 		bne	.L463
 3595              	.LVL439:
 3596              	.L441:
 882:../lib/fat.c  ****             sub_path = path + length_to_sep;
 3597              		.loc 1 882 0
 3598 1878 0400A0E1 		mov	r0, r4
 3599              	.LVL440:
 3600 187c FEFFFFEB 		bl	strlen
 3601              	.LVL441:
 3602 1880 FF6000E2 		and	r6, r0, #255
 3603              	.LVL442:
 883:../lib/fat.c  ****         }
 3604              		.loc 1 883 0
 3605 1884 06A084E0 		add	sl, r4, r6
 3606              	.LVL443:
 3607 1888 120000EA 		b	.L463
 3608              	.LVL444:
 3609              	.L446:
 890:../lib/fat.c  ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 3610              		.loc 1 890 0
 3611 188c 0500A0E1 		mov	r0, r5
 3612 1890 FEFFFFEB 		bl	strlen
 3613              	.LVL445:
 3614 1894 060050E1 		cmp	r0, r6
 3615 1898 0E00001A 		bne	.L463
 891:../lib/fat.c  ****                 continue;
 3616              		.loc 1 891 0 discriminator 1
 3617 189c 0400A0E1 		mov	r0, r4
 3618 18a0 0510A0E1 		mov	r1, r5
 3619 18a4 0620A0E1 		mov	r2, r6
 3620 18a8 FEFFFFEB 		bl	strncmp
 3621              	.LVL446:
 890:../lib/fat.c  ****                 strncmp(path, dir_entry->long_name, length_to_sep) != 0))
 3622              		.loc 1 890 0 discriminator 1
 3623 18ac 009050E2 		subs	r9, r0, #0
 3624 18b0 0800001A 		bne	.L463
 894:../lib/fat.c  ****             dd = 0;
 3625              		.loc 1 894 0
 3626 18b4 0700A0E1 		mov	r0, r7
 3627 18b8 FEFFFFEB 		bl	fat_close_dir
 3628              	.LVL447:
 897:../lib/fat.c  ****                 /* we iterated through the whole path and have found the file */
 3629              		.loc 1 897 0
 3630 18bc 0630D4E7 		ldrb	r3, [r4, r6]	@ zero_extendqisi2
 3631 18c0 000053E3 		cmp	r3, #0
 3632 18c4 DCFFFF0A 		beq	.L444
 901:../lib/fat.c  ****             {
 3633              		.loc 1 901 0
 3634 18c8 2030D5E5 		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 3635 18cc 100013E3 		tst	r3, #16
 3636 18d0 0600001A 		bne	.L448
 3637 18d4 0A0000EA 		b	.L437
 3638              	.LVL448:
 3639              	.L463:
 887:../lib/fat.c  ****         {
 3640              		.loc 1 887 0 discriminator 1
 3641 18d8 0700A0E1 		mov	r0, r7
 3642 18dc 0510A0E1 		mov	r1, r5
 3643 18e0 FEFFFFEB 		bl	fat_read_dir
 3644              	.LVL449:
 3645 18e4 000050E3 		cmp	r0, #0
 3646 18e8 E7FFFF1A 		bne	.L446
 3647 18ec 010000EA 		b	.L445
 3648              	.LVL450:
 3649              	.L448:
 904:../lib/fat.c  ****                 break;
 3650              		.loc 1 904 0
 3651 18f0 0A40A0E1 		mov	r4, sl
 3652              	.LVL451:
 895:../lib/fat.c  **** 
 3653              		.loc 1 895 0
 3654 18f4 0970A0E1 		mov	r7, r9
 3655              	.LVL452:
 3656              	.L445:
 912:../lib/fat.c  ****     }
 3657              		.loc 1 912 0
 3658 18f8 0700A0E1 		mov	r0, r7
 3659 18fc FEFFFFEB 		bl	fat_close_dir
 3660              	.LVL453:
 3661              	.LBE136:
 913:../lib/fat.c  ****     
 3662              		.loc 1 913 0
 3663 1900 CAFFFFEA 		b	.L447
 3664              	.LVL454:
 3665              	.L437:
 3666              	.LBB137:
 854:../lib/fat.c  **** 
 3667              		.loc 1 854 0
 3668 1904 0000A0E3 		mov	r0, #0
 3669              	.L440:
 3670              	.LBE137:
 916:../lib/fat.c  **** 
 3671              		.loc 1 916 0
 3672 1908 F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 3673 190c 1EFF2FE1 		bx	lr
 3674              		.cfi_endproc
 3675              	.LFE10:
 3677              		.align	2
 3678              		.global	fat_create_file
 3680              	fat_create_file:
 3681              	.LFB25:
2069:../lib/fat.c  ****     if(!parent || !file || !file[0] || !dir_entry)
 3682              		.loc 1 2069 0
 3683              		.cfi_startproc
 3684              		@ Function supports interworking.
 3685              		@ args = 0, pretend = 0, frame = 0
 3686              		@ frame_needed = 0, uses_anonymous_args = 0
 3687              	.LVL455:
2070:../lib/fat.c  ****         return 0;
 3688              		.loc 1 2070 0
 3689 1910 000050E3 		cmp	r0, #0
 3690 1914 00005113 		cmpne	r1, #0
2069:../lib/fat.c  ****     if(!parent || !file || !file[0] || !dir_entry)
 3691              		.loc 1 2069 0
 3692 1918 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 3693              	.LCFI23:
 3694              		.cfi_def_cfa_offset 20
 3695              		.cfi_offset 4, -20
 3696              		.cfi_offset 5, -16
 3697              		.cfi_offset 6, -12
 3698              		.cfi_offset 7, -8
 3699              		.cfi_offset 14, -4
2069:../lib/fat.c  ****     if(!parent || !file || !file[0] || !dir_entry)
 3700              		.loc 1 2069 0
 3701 191c 0260A0E1 		mov	r6, r2
2070:../lib/fat.c  ****         return 0;
 3702              		.loc 1 2070 0
 3703 1920 0150A0E1 		mov	r5, r1
 3704 1924 0040A0E1 		mov	r4, r0
 3705 1928 0100001A 		bne	.L465
 3706              	.LVL456:
 3707              	.L467:
 3708              	.LBB140:
 3709              	.LBB141:
2071:../lib/fat.c  **** 
 3710              		.loc 1 2071 0
 3711 192c 0000A0E3 		mov	r0, #0
 3712 1930 2C0000EA 		b	.L466
 3713              	.LVL457:
 3714              	.L465:
 3715              	.LBE141:
 3716              	.LBE140:
2070:../lib/fat.c  ****         return 0;
 3717              		.loc 1 2070 0 discriminator 1
 3718 1934 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 3719 1938 000053E3 		cmp	r3, #0
 3720 193c FAFFFF0A 		beq	.L467
 3721 1940 000052E3 		cmp	r2, #0
 3722 1944 F8FFFF0A 		beq	.L467
 3723              	.LVL458:
 3724              	.L478:
2076:../lib/fat.c  ****             break;
 3725              		.loc 1 2076 0
 3726 1948 0610A0E1 		mov	r1, r6
 3727 194c 0400A0E1 		mov	r0, r4
 3728 1950 FEFFFFEB 		bl	fat_read_dir
 3729              	.LVL459:
 3730 1954 001050E2 		subs	r1, r0, #0
 3731 1958 0800000A 		beq	.L468
2079:../lib/fat.c  ****         {
 3732              		.loc 1 2079 0
 3733 195c 0500A0E1 		mov	r0, r5
 3734 1960 0610A0E1 		mov	r1, r6
 3735 1964 FEFFFFEB 		bl	strcmp
 3736              	.LVL460:
 3737 1968 000050E3 		cmp	r0, #0
 3738 196c F5FFFF1A 		bne	.L478
2081:../lib/fat.c  ****             return 2;
 3739              		.loc 1 2081 0
 3740 1970 0400A0E1 		mov	r0, r4
 3741 1974 FEFFFFEB 		bl	fat_reset_dir
 3742              	.LVL461:
2082:../lib/fat.c  ****         }
 3743              		.loc 1 2082 0
 3744 1978 0200A0E3 		mov	r0, #2
 3745 197c 190000EA 		b	.L466
 3746              	.L468:
2086:../lib/fat.c  **** 
 3747              		.loc 1 2086 0
 3748 1980 007094E5 		ldr	r7, [r4, #0]
 3749              	.LVL462:
2089:../lib/fat.c  ****     strncpy(dir_entry->long_name, file, sizeof(dir_entry->long_name) - 1);
 3750              		.loc 1 2089 0
 3751 1984 3420A0E3 		mov	r2, #52
 3752 1988 0600A0E1 		mov	r0, r6
 3753 198c FEFFFFEB 		bl	memset
 3754              	.LVL463:
2090:../lib/fat.c  **** 
 3755              		.loc 1 2090 0
 3756 1990 0510A0E1 		mov	r1, r5
 3757 1994 0600A0E1 		mov	r0, r6
 3758 1998 1F20A0E3 		mov	r2, #31
 3759 199c FEFFFFEB 		bl	strncpy
 3760              	.LVL464:
 3761              	.LBB143:
 3762              	.LBB142:
1745:../lib/fat.c  ****         return 0;
 3763              		.loc 1 1745 0
 3764 19a0 000057E3 		cmp	r7, #0
1746:../lib/fat.c  **** 
 3765              		.loc 1 1746 0
 3766 19a4 0000A003 		moveq	r0, #0
 3767 19a8 0010A003 		moveq	r1, #0
1745:../lib/fat.c  ****         return 0;
 3768              		.loc 1 1745 0
 3769 19ac 0400000A 		beq	.L470
 3770 19b0 0700A0E1 		mov	r0, r7
 3771 19b4 0410A0E1 		mov	r1, r4
 3772 19b8 0620A0E1 		mov	r2, r6
 3773 19bc 3DFCFFEB 		bl	fat_find_offset_for_dir_entry.part.4
 3774              	.LVL465:
 3775 19c0 FFFFFFEA 		b	.L470
 3776              	.L470:
 3777              	.LBE142:
 3778              	.LBE143:
2093:../lib/fat.c  ****         return 0;
 3779              		.loc 1 2093 0
 3780 19c4 013090E1 		orrs	r3, r0, r1
 3781 19c8 2C0086E5 		str	r0, [r6, #44]
 3782 19cc 301086E5 		str	r1, [r6, #48]
 3783 19d0 D5FFFF0A 		beq	.L467
2097:../lib/fat.c  ****         return 0;
 3784              		.loc 1 2097 0
 3785 19d4 0700A0E1 		mov	r0, r7
 3786 19d8 0610A0E1 		mov	r1, r6
 3787 19dc 90FBFFEB 		bl	fat_write_dir_entry
 3788              	.LVL466:
2071:../lib/fat.c  **** 
 3789              		.loc 1 2071 0
 3790 19e0 000090E2 		adds	r0, r0, #0
 3791 19e4 0100A013 		movne	r0, #1
 3792              	.LVL467:
 3793              	.L466:
2101:../lib/fat.c  **** #endif
 3794              		.loc 1 2101 0
 3795 19e8 F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 3796 19ec 1EFF2FE1 		bx	lr
 3797              		.cfi_endproc
 3798              	.LFE25:
 3800              		.align	2
 3801              		.global	fat_delete_file
 3803              	fat_delete_file:
 3804              	.LFB26:
2120:../lib/fat.c  ****     if(!fs || !dir_entry)
 3805              		.loc 1 2120 0
 3806              		.cfi_startproc
 3807              		@ Function supports interworking.
 3808              		@ args = 0, pretend = 0, frame = 12
 3809              		@ frame_needed = 0, uses_anonymous_args = 0
 3810              	.LVL468:
2121:../lib/fat.c  ****         return 0;
 3811              		.loc 1 2121 0
 3812 19f0 000050E3 		cmp	r0, #0
 3813 19f4 00005113 		cmpne	r1, #0
2120:../lib/fat.c  ****     if(!fs || !dir_entry)
 3814              		.loc 1 2120 0
 3815 19f8 F7472DE9 		stmfd	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, lr}
 3816              	.LCFI24:
 3817              		.cfi_def_cfa_offset 44
 3818              		.cfi_offset 0, -44
 3819              		.cfi_offset 1, -40
 3820              		.cfi_offset 2, -36
 3821              		.cfi_offset 4, -32
 3822              		.cfi_offset 5, -28
 3823              		.cfi_offset 6, -24
 3824              		.cfi_offset 7, -20
 3825              		.cfi_offset 8, -16
 3826              		.cfi_offset 9, -12
 3827              		.cfi_offset 10, -8
 3828              		.cfi_offset 14, -4
2121:../lib/fat.c  ****         return 0;
 3829              		.loc 1 2121 0
 3830 19fc 01A0A0E1 		mov	sl, r1
 3831 1a00 0080A0E1 		mov	r8, r0
 3832 1a04 2C00000A 		beq	.L490
 3833              	.LVL469:
 3834              	.LBB146:
 3835              	.LBB147:
2125:../lib/fat.c  ****     if(!dir_entry_offset)
 3836              		.loc 1 2125 0
 3837 1a08 2C5081E2 		add	r5, r1, #44
 3838 1a0c 300095E8 		ldmia	r5, {r4-r5}
 3839              	.LVL470:
2126:../lib/fat.c  ****         return 0;
 3840              		.loc 1 2126 0
 3841 1a10 053094E1 		orrs	r3, r4, r5
 3842 1a14 2800000A 		beq	.L490
 3843              	.L501:
2138:../lib/fat.c  ****         
 3844              		.loc 1 2138 0
 3845 1a18 1A90E0E3 		mvn	r9, #26
2148:../lib/fat.c  ****     }
 3846              		.loc 1 2148 0
 3847 1a1c 2060A0E3 		mov	r6, #32
 3848 1a20 0070A0E3 		mov	r7, #0
 3849              	.LVL471:
 3850              	.L502:
2134:../lib/fat.c  ****             return 0;
 3851              		.loc 1 2134 0
 3852 1a24 00C098E5 		ldr	ip, [r8, #0]
 3853 1a28 0400A0E1 		mov	r0, r4
 3854 1a2c 0510A0E1 		mov	r1, r5
 3855 1a30 0D20A0E1 		mov	r2, sp
 3856 1a34 0C30A0E3 		mov	r3, #12
 3857 1a38 00C09CE5 		ldr	ip, [ip, #0]
 3858 1a3c 0FE0A0E1 		mov	lr, pc
 3859 1a40 1CFF2FE1 		bx	ip
 3860              	.LVL472:
 3861 1a44 000050E3 		cmp	r0, #0
 3862 1a48 1B00000A 		beq	.L490
2138:../lib/fat.c  ****         
 3863              		.loc 1 2138 0
 3864 1a4c 0090CDE5 		strb	r9, [sp, #0]
2141:../lib/fat.c  ****             return 0;
 3865              		.loc 1 2141 0
 3866 1a50 00C098E5 		ldr	ip, [r8, #0]
 3867 1a54 0400A0E1 		mov	r0, r4
 3868 1a58 0510A0E1 		mov	r1, r5
 3869 1a5c 0D20A0E1 		mov	r2, sp
 3870 1a60 0C30A0E3 		mov	r3, #12
 3871 1a64 08C09CE5 		ldr	ip, [ip, #8]
 3872 1a68 0FE0A0E1 		mov	lr, pc
 3873 1a6c 1CFF2FE1 		bx	ip
 3874              	.LVL473:
 3875 1a70 000050E3 		cmp	r0, #0
 3876 1a74 1000000A 		beq	.L490
2145:../lib/fat.c  ****             break;
 3877              		.loc 1 2145 0
 3878 1a78 0B30DDE5 		ldrb	r3, [sp, #11]	@ zero_extendqisi2
 3879 1a7c 0F0053E3 		cmp	r3, #15
 3880 1a80 0200001A 		bne	.L488
2148:../lib/fat.c  ****     }
 3881              		.loc 1 2148 0
 3882 1a84 064094E0 		adds	r4, r4, r6
 3883              	.LVL474:
 3884 1a88 0750A5E0 		adc	r5, r5, r7
 3885              	.LVL475:
 3886 1a8c E4FFFFEA 		b	.L502
 3887              	.L488:
2160:../lib/fat.c  **** }
 3888              		.loc 1 2160 0
 3889 1a90 24109AE5 		ldr	r1, [sl, #36]
 3890 1a94 000051E3 		cmp	r1, #0
 3891 1a98 0100A003 		moveq	r0, #1
 3892 1a9c 0400000A 		beq	.L489
 3893 1aa0 0800A0E1 		mov	r0, r8
 3894 1aa4 4BFAFFEB 		bl	fat_free_clusters
 3895              	.LVL476:
 3896 1aa8 000090E2 		adds	r0, r0, #0
 3897 1aac 0100A013 		movne	r0, #1
 3898 1ab0 FFFFFFEA 		b	.L489
 3899              	.L489:
 3900 1ab4 FF0000E2 		and	r0, r0, #255
 3901 1ab8 000000EA 		b	.L484
 3902              	.LVL477:
 3903              	.L490:
 3904              	.LBE147:
 3905              	.LBE146:
2122:../lib/fat.c  **** 
 3906              		.loc 1 2122 0
 3907 1abc 0000A0E3 		mov	r0, #0
 3908              	.L484:
2161:../lib/fat.c  **** #endif
 3909              		.loc 1 2161 0
 3910 1ac0 FE47BDE8 		ldmfd	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 3911 1ac4 1EFF2FE1 		bx	lr
 3912              		.cfi_endproc
 3913              	.LFE26:
 3915              		.align	2
 3916              		.global	fat_move_file
 3918              	fat_move_file:
 3919              	.LFB27:
2190:../lib/fat.c  ****     if(!fs || !dir_entry || !parent_new || (file_new && !file_new[0]))
 3920              		.loc 1 2190 0
 3921              		.cfi_startproc
 3922              		@ Function supports interworking.
 3923              		@ args = 0, pretend = 0, frame = 52
 3924              		@ frame_needed = 0, uses_anonymous_args = 0
 3925              	.LVL478:
 3926 1ac8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 3927              	.LCFI25:
 3928              		.cfi_def_cfa_offset 16
 3929              		.cfi_offset 4, -16
 3930              		.cfi_offset 5, -12
 3931              		.cfi_offset 6, -8
 3932              		.cfi_offset 14, -4
2191:../lib/fat.c  ****         return 0;
 3933              		.loc 1 2191 0
 3934 1acc 000050E3 		cmp	r0, #0
 3935 1ad0 00005113 		cmpne	r1, #0
2190:../lib/fat.c  ****     if(!fs || !dir_entry || !parent_new || (file_new && !file_new[0]))
 3936              		.loc 1 2190 0
 3937 1ad4 34D04DE2 		sub	sp, sp, #52
 3938              	.LCFI26:
 3939              		.cfi_def_cfa_offset 68
2191:../lib/fat.c  ****         return 0;
 3940              		.loc 1 2191 0
 3941 1ad8 0140A0E1 		mov	r4, r1
 3942 1adc 0050A0E1 		mov	r5, r0
 3943 1ae0 0100001A 		bne	.L504
 3944              	.LVL479:
 3945              	.L506:
2192:../lib/fat.c  ****     if(fs != parent_new->fs)
 3946              		.loc 1 2192 0
 3947 1ae4 0000A0E3 		mov	r0, #0
 3948 1ae8 320000EA 		b	.L505
 3949              	.LVL480:
 3950              	.L504:
2191:../lib/fat.c  ****         return 0;
 3951              		.loc 1 2191 0 discriminator 1
 3952 1aec 000052E3 		cmp	r2, #0
 3953 1af0 FBFFFF0A 		beq	.L506
 3954 1af4 000053E3 		cmp	r3, #0
 3955 1af8 0200000A 		beq	.L507
 3956 1afc 0010D3E5 		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 3957              	.LVL481:
 3958 1b00 000051E3 		cmp	r1, #0
 3959 1b04 F6FFFF0A 		beq	.L506
 3960              	.L507:
2193:../lib/fat.c  ****         return 0;
 3961              		.loc 1 2193 0
 3962 1b08 001092E5 		ldr	r1, [r2, #0]
 3963 1b0c 010055E1 		cmp	r5, r1
 3964 1b10 F3FFFF1A 		bne	.L506
 3965              	.LVL482:
2202:../lib/fat.c  ****         return 0;
 3966              		.loc 1 2202 0
 3967 1b14 000053E3 		cmp	r3, #0
 3968 1b18 0200A0E1 		mov	r0, r2
 3969              	.LVL483:
 3970 1b1c 0310A011 		movne	r1, r3
 3971 1b20 0410A001 		moveq	r1, r4
 3972 1b24 0D20A0E1 		mov	r2, sp
 3973              	.LVL484:
 3974 1b28 FEFFFFEB 		bl	fat_create_file
 3975              	.LVL485:
 3976 1b2c 000050E3 		cmp	r0, #0
 3977 1b30 EBFFFF0A 		beq	.L506
2206:../lib/fat.c  **** #if FAT_DATETIME_SUPPORT
 3978              		.loc 1 2206 0
 3979 1b34 2030D4E5 		ldrb	r3, [r4, #32]	@ zero_extendqisi2
 3980 1b38 2030CDE5 		strb	r3, [sp, #32]
2211:../lib/fat.c  ****     dir_entry_new.file_size = dir_entry->file_size;
 3981              		.loc 1 2211 0
 3982 1b3c 243094E5 		ldr	r3, [r4, #36]
 3983 1b40 24308DE5 		str	r3, [sp, #36]
2212:../lib/fat.c  **** 
 3984              		.loc 1 2212 0
 3985 1b44 283094E5 		ldr	r3, [r4, #40]
2215:../lib/fat.c  ****     {
 3986              		.loc 1 2215 0
 3987 1b48 0500A0E1 		mov	r0, r5
 3988 1b4c 0D10A0E1 		mov	r1, sp
2212:../lib/fat.c  **** 
 3989              		.loc 1 2212 0
 3990 1b50 28308DE5 		str	r3, [sp, #40]
2215:../lib/fat.c  ****     {
 3991              		.loc 1 2215 0
 3992 1b54 32FBFFEB 		bl	fat_write_dir_entry
 3993              	.LVL486:
 3994 1b58 006050E2 		subs	r6, r0, #0
 3995 1b5c 0300001A 		bne	.L509
2217:../lib/fat.c  ****         return 0;
 3996              		.loc 1 2217 0
 3997 1b60 0500A0E1 		mov	r0, r5
 3998 1b64 0D10A0E1 		mov	r1, sp
 3999 1b68 FEFFFFEB 		bl	fat_delete_file
 4000              	.LVL487:
 4001 1b6c DCFFFFEA 		b	.L506
 4002              	.L509:
2222:../lib/fat.c  ****     if(!fat_delete_file(fs, dir_entry))
 4003              		.loc 1 2222 0
 4004 1b70 0030A0E3 		mov	r3, #0
 4005 1b74 243084E5 		str	r3, [r4, #36]
2223:../lib/fat.c  ****         return 0;
 4006              		.loc 1 2223 0
 4007 1b78 0500A0E1 		mov	r0, r5
 4008 1b7c 0410A0E1 		mov	r1, r4
 4009 1b80 FEFFFFEB 		bl	fat_delete_file
 4010              	.LVL488:
 4011 1b84 000050E3 		cmp	r0, #0
 4012 1b88 D5FFFF0A 		beq	.L506
2226:../lib/fat.c  ****     return 1;
 4013              		.loc 1 2226 0
 4014 1b8c 04C0A0E1 		mov	ip, r4
 4015 1b90 0D40A0E1 		mov	r4, sp
 4016              	.LVL489:
 4017 1b94 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 4018 1b98 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 4019              	.LVL490:
 4020 1b9c 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 4021 1ba0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 4022              	.LVL491:
 4023 1ba4 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 4024 1ba8 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 4025              	.LVL492:
 4026 1bac 003094E5 		ldr	r3, [r4, #0]
 4027 1bb0 00308CE5 		str	r3, [ip, #0]
2227:../lib/fat.c  **** }
 4028              		.loc 1 2227 0
 4029 1bb4 0100A0E3 		mov	r0, #1
 4030              	.LVL493:
 4031              	.L505:
2228:../lib/fat.c  **** #endif
 4032              		.loc 1 2228 0
 4033 1bb8 34D08DE2 		add	sp, sp, #52
 4034 1bbc 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 4035 1bc0 1EFF2FE1 		bx	lr
 4036              		.cfi_endproc
 4037              	.LFE27:
 4039              		.align	2
 4040              		.global	fat_create_dir
 4042              	fat_create_dir:
 4043              	.LFB28:
2251:../lib/fat.c  ****     if(!parent || !dir || !dir[0] || !dir_entry)
 4044              		.loc 1 2251 0
 4045              		.cfi_startproc
 4046              		@ Function supports interworking.
 4047              		@ args = 0, pretend = 0, frame = 0
 4048              		@ frame_needed = 0, uses_anonymous_args = 0
 4049              	.LVL494:
2252:../lib/fat.c  ****         return 0;
 4050              		.loc 1 2252 0
 4051 1bc4 000050E3 		cmp	r0, #0
 4052 1bc8 00005113 		cmpne	r1, #0
2251:../lib/fat.c  ****     if(!parent || !dir || !dir[0] || !dir_entry)
 4053              		.loc 1 2251 0
 4054 1bcc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4055              	.LCFI27:
 4056              		.cfi_def_cfa_offset 36
 4057              		.cfi_offset 4, -36
 4058              		.cfi_offset 5, -32
 4059              		.cfi_offset 6, -28
 4060              		.cfi_offset 7, -24
 4061              		.cfi_offset 8, -20
 4062              		.cfi_offset 9, -16
 4063              		.cfi_offset 10, -12
 4064              		.cfi_offset 11, -8
 4065              		.cfi_offset 14, -4
2251:../lib/fat.c  ****     if(!parent || !dir || !dir[0] || !dir_entry)
 4066              		.loc 1 2251 0
 4067 1bd0 0260A0E1 		mov	r6, r2
2252:../lib/fat.c  ****         return 0;
 4068              		.loc 1 2252 0
 4069 1bd4 01B0A0E1 		mov	fp, r1
 4070 1bd8 0090A0E1 		mov	r9, r0
 4071 1bdc 5100000A 		beq	.L548
 4072              	.L526:
2252:../lib/fat.c  ****         return 0;
 4073              		.loc 1 2252 0 is_stmt 0 discriminator 1
 4074 1be0 0020D1E5 		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 4075              	.LVL495:
 4076 1be4 000052E3 		cmp	r2, #0
 4077 1be8 4E00000A 		beq	.L548
 4078 1bec 000056E3 		cmp	r6, #0
 4079 1bf0 0800001A 		bne	.L542
 4080 1bf4 4B0000EA 		b	.L548
 4081              	.LVL496:
 4082              	.L530:
2258:../lib/fat.c  ****         {
 4083              		.loc 1 2258 0 is_stmt 1
 4084 1bf8 0B00A0E1 		mov	r0, fp
 4085 1bfc 0610A0E1 		mov	r1, r6
 4086 1c00 FEFFFFEB 		bl	strcmp
 4087              	.LVL497:
 4088 1c04 004050E2 		subs	r4, r0, #0
 4089 1c08 0200001A 		bne	.L542
2260:../lib/fat.c  ****             return 0;
 4090              		.loc 1 2260 0
 4091 1c0c 0900A0E1 		mov	r0, r9
 4092 1c10 FEFFFFEB 		bl	fat_reset_dir
 4093              	.LVL498:
 4094 1c14 430000EA 		b	.L548
 4095              	.L542:
2256:../lib/fat.c  ****     {
 4096              		.loc 1 2256 0
 4097 1c18 0610A0E1 		mov	r1, r6
 4098 1c1c 0900A0E1 		mov	r0, r9
 4099 1c20 FEFFFFEB 		bl	fat_read_dir
 4100              	.LVL499:
 4101 1c24 001050E2 		subs	r1, r0, #0
 4102 1c28 F2FFFF1A 		bne	.L530
2265:../lib/fat.c  **** 
 4103              		.loc 1 2265 0
 4104 1c2c 008099E5 		ldr	r8, [r9, #0]
 4105              	.LVL500:
2268:../lib/fat.c  ****     if(!dir_cluster)
 4106              		.loc 1 2268 0
 4107 1c30 0120A0E3 		mov	r2, #1
 4108 1c34 0800A0E1 		mov	r0, r8
 4109 1c38 4AFAFFEB 		bl	fat_append_clusters
 4110              	.LVL501:
2269:../lib/fat.c  ****         return 0;
 4111              		.loc 1 2269 0
 4112 1c3c 00A050E2 		subs	sl, r0, #0
 4113 1c40 3800000A 		beq	.L548
 4114              	.LVL502:
 4115              	.LBB152:
 4116              	.LBB153:
 796:../lib/fat.c  ****         return 0;
 4117              		.loc 1 796 0
 4118 1c44 01005AE3 		cmp	sl, #1
 4119 1c48 0800A081 		movhi	r0, r8
 4120              	.LVL503:
 4121 1c4c 0A10A081 		movhi	r1, sl
 4122 1c50 D9FAFF8B 		blhi	fat_clear_cluster.part.3
 4123              	.LVL504:
 4124              	.L531:
 4125              	.LBE153:
 4126              	.LBE152:
2275:../lib/fat.c  ****     dir_entry->attributes = FAT_ATTRIB_DIR;
 4127              		.loc 1 2275 0
 4128 1c54 0010A0E3 		mov	r1, #0
 4129 1c58 3420A0E3 		mov	r2, #52
 4130 1c5c 0600A0E1 		mov	r0, r6
 4131 1c60 FEFFFFEB 		bl	memset
 4132              	.LVL505:
2276:../lib/fat.c  **** 
 4133              		.loc 1 2276 0
 4134 1c64 1020A0E3 		mov	r2, #16
 4135 1c68 2020C6E5 		strb	r2, [r6, #32]
2280:../lib/fat.c  ****     dir_entry->long_name[0] = '.';
 4136              		.loc 1 2280 0
 4137 1c6c BA21D8E1 		ldrh	r2, [r8, #26]
2279:../lib/fat.c  ****                               (offset_t) (dir_cluster - 2) * fs->header.cluster_size;
 4138              		.loc 1 2279 0
 4139 1c70 1C1088E2 		add	r1, r8, #28
 4140 1c74 030091E8 		ldmia	r1, {r0-r1}
2280:../lib/fat.c  ****     dir_entry->long_name[0] = '.';
 4141              		.loc 1 2280 0
 4142 1c78 02C04AE2 		sub	ip, sl, #2
2279:../lib/fat.c  ****                               (offset_t) (dir_cluster - 2) * fs->header.cluster_size;
 4143              		.loc 1 2279 0
 4144 1c7c 920CA1E0 		umlal	r0, r1, r2, ip
2281:../lib/fat.c  ****     dir_entry->cluster = dir_cluster;
 4145              		.loc 1 2281 0
 4146 1c80 2E70A0E3 		mov	r7, #46
2279:../lib/fat.c  ****                               (offset_t) (dir_cluster - 2) * fs->header.cluster_size;
 4147              		.loc 1 2279 0
 4148 1c84 2C0086E5 		str	r0, [r6, #44]
 4149 1c88 301086E5 		str	r1, [r6, #48]
2281:../lib/fat.c  ****     dir_entry->cluster = dir_cluster;
 4150              		.loc 1 2281 0
 4151 1c8c 0070C6E5 		strb	r7, [r6, #0]
2282:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
 4152              		.loc 1 2282 0
 4153 1c90 24A086E5 		str	sl, [r6, #36]
2283:../lib/fat.c  ****     {
 4154              		.loc 1 2283 0
 4155 1c94 0800A0E1 		mov	r0, r8
 4156 1c98 0610A0E1 		mov	r1, r6
 4157 1c9c E0FAFFEB 		bl	fat_write_dir_entry
 4158              	.LVL506:
 4159 1ca0 004050E2 		subs	r4, r0, #0
 4160 1ca4 2600000A 		beq	.L549
 4161              	.L532:
2290:../lib/fat.c  ****     dir_entry->long_name[1] = '.';
 4162              		.loc 1 2290 0
 4163 1ca8 2C5086E2 		add	r5, r6, #44
 4164 1cac 300095E8 		ldmia	r5, {r4-r5}
 4165 1cb0 2020A0E3 		mov	r2, #32
 4166 1cb4 024094E0 		adds	r4, r4, r2
 4167 1cb8 0030A0E3 		mov	r3, #0
2292:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
 4168              		.loc 1 2292 0
 4169 1cbc 282099E5 		ldr	r2, [r9, #40]
2290:../lib/fat.c  ****     dir_entry->long_name[1] = '.';
 4170              		.loc 1 2290 0
 4171 1cc0 0350A5E0 		adc	r5, r5, r3
 4172 1cc4 2C4086E5 		str	r4, [r6, #44]
 4173 1cc8 305086E5 		str	r5, [r6, #48]
2291:../lib/fat.c  ****     dir_entry->cluster = parent->dir_entry.cluster;
 4174              		.loc 1 2291 0
 4175 1ccc 0170C6E5 		strb	r7, [r6, #1]
2292:../lib/fat.c  ****     if(!fat_write_dir_entry(fs, dir_entry))
 4176              		.loc 1 2292 0
 4177 1cd0 242086E5 		str	r2, [r6, #36]
2293:../lib/fat.c  ****     {
 4178              		.loc 1 2293 0
 4179 1cd4 0800A0E1 		mov	r0, r8
 4180 1cd8 0610A0E1 		mov	r1, r6
 4181 1cdc D0FAFFEB 		bl	fat_write_dir_entry
 4182              	.LVL507:
 4183 1ce0 004050E2 		subs	r4, r0, #0
 4184 1ce4 1600000A 		beq	.L549
 4185              	.L533:
2300:../lib/fat.c  ****     dir_entry->cluster = dir_cluster;
 4186              		.loc 1 2300 0
 4187 1ce8 0B10A0E1 		mov	r1, fp
 4188 1cec 1F20A0E3 		mov	r2, #31
 4189 1cf0 0600A0E1 		mov	r0, r6
 4190 1cf4 FEFFFFEB 		bl	strncpy
 4191              	.LVL508:
2301:../lib/fat.c  **** 
 4192              		.loc 1 2301 0
 4193 1cf8 24A086E5 		str	sl, [r6, #36]
 4194              	.LVL509:
 4195 1cfc 0800A0E1 		mov	r0, r8
 4196 1d00 0910A0E1 		mov	r1, r9
 4197 1d04 0620A0E1 		mov	r2, r6
 4198 1d08 6AFBFFEB 		bl	fat_find_offset_for_dir_entry.part.4
 4199              	.LVL510:
2304:../lib/fat.c  ****     {
 4200              		.loc 1 2304 0
 4201 1d0c 013090E1 		orrs	r3, r0, r1
 4202 1d10 2C0086E5 		str	r0, [r6, #44]
 4203 1d14 301086E5 		str	r1, [r6, #48]
2306:../lib/fat.c  ****         return 0;
 4204              		.loc 1 2306 0
 4205 1d18 0800A0E1 		mov	r0, r8
2304:../lib/fat.c  ****     {
 4206              		.loc 1 2304 0
 4207 1d1c 0300001A 		bne	.L534
 4208              	.LVL511:
 4209              	.L547:
2306:../lib/fat.c  ****         return 0;
 4210              		.loc 1 2306 0
 4211 1d20 0A10A0E1 		mov	r1, sl
 4212 1d24 ABF9FFEB 		bl	fat_free_clusters
 4213              	.LVL512:
 4214              	.L548:
2307:../lib/fat.c  ****     }
 4215              		.loc 1 2307 0
 4216 1d28 0000A0E3 		mov	r0, #0
 4217 1d2c 060000EA 		b	.L527
 4218              	.LVL513:
 4219              	.L534:
2311:../lib/fat.c  ****     {
 4220              		.loc 1 2311 0
 4221 1d30 0610A0E1 		mov	r1, r6
 4222 1d34 BAFAFFEB 		bl	fat_write_dir_entry
 4223              	.LVL514:
 4224 1d38 004050E2 		subs	r4, r0, #0
2317:../lib/fat.c  **** }
 4225              		.loc 1 2317 0
 4226 1d3c 0100A013 		movne	r0, #1
2311:../lib/fat.c  ****     {
 4227              		.loc 1 2311 0
 4228 1d40 0100001A 		bne	.L527
 4229              	.LVL515:
 4230              	.L549:
2313:../lib/fat.c  ****         return 0;
 4231              		.loc 1 2313 0
 4232 1d44 0800A0E1 		mov	r0, r8
 4233 1d48 F4FFFFEA 		b	.L547
 4234              	.LVL516:
 4235              	.L527:
2318:../lib/fat.c  **** #endif
 4236              		.loc 1 2318 0
 4237 1d4c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4238 1d50 1EFF2FE1 		bx	lr
 4239              		.cfi_endproc
 4240              	.LFE28:
 4242              		.align	2
 4243              		.global	fat_get_fs_size
 4245              	fat_get_fs_size:
 4246              	.LFB29:
2451:../lib/fat.c  ****     if(!fs)
 4247              		.loc 1 2451 0
 4248              		.cfi_startproc
 4249              		@ Function supports interworking.
 4250              		@ args = 0, pretend = 0, frame = 0
 4251              		@ frame_needed = 0, uses_anonymous_args = 0
 4252              		@ link register save eliminated.
 4253              	.LVL517:
2452:../lib/fat.c  ****         return 0;
 4254              		.loc 1 2452 0
 4255 1d54 000050E3 		cmp	r0, #0
 4256 1d58 0900000A 		beq	.L553
2456:../lib/fat.c  ****         return (offset_t) (fs->header.fat_size / 4 - 2) * fs->header.cluster_size;
 4257              		.loc 1 2456 0
 4258 1d5c 003090E5 		ldr	r3, [r0, #0]
 4259 1d60 1030D3E5 		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 4260 1d64 0B0053E3 		cmp	r3, #11
 4261 1d68 143090E5 		ldr	r3, [r0, #20]
 4262 1d6c BA11D0E1 		ldrh	r1, [r0, #26]
2457:../lib/fat.c  ****     else
 4263              		.loc 1 2457 0
 4264 1d70 2331A001 		moveq	r3, r3, lsr #2
2460:../lib/fat.c  **** }
 4265              		.loc 1 2460 0
 4266 1d74 A330A011 		movne	r3, r3, lsr #1
 4267 1d78 020043E2 		sub	r0, r3, #2
 4268              	.LVL518:
 4269 1d7c 902183E0 		umull	r2, r3, r0, r1
 4270 1d80 010000EA 		b	.L551
 4271              	.LVL519:
 4272              	.L553:
2453:../lib/fat.c  **** 
 4273              		.loc 1 2453 0
 4274 1d84 0020A0E3 		mov	r2, #0
 4275 1d88 0030A0E3 		mov	r3, #0
 4276              	.LVL520:
 4277              	.L551:
2461:../lib/fat.c  **** 
 4278              		.loc 1 2461 0
 4279 1d8c 0200A0E1 		mov	r0, r2
 4280 1d90 0310A0E1 		mov	r1, r3
 4281 1d94 1EFF2FE1 		bx	lr
 4282              		.cfi_endproc
 4283              	.LFE29:
 4285              		.align	2
 4286              		.global	fat_get_fs_free
 4288              	fat_get_fs_free:
 4289              	.LFB30:
2474:../lib/fat.c  ****     if(!fs)
 4290              		.loc 1 2474 0
 4291              		.cfi_startproc
 4292              		@ Function supports interworking.
 4293              		@ args = 0, pretend = 0, frame = 40
 4294              		@ frame_needed = 0, uses_anonymous_args = 0
 4295              	.LVL521:
 4296 1d98 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 4297              	.LCFI28:
 4298              		.cfi_def_cfa_offset 32
 4299              		.cfi_offset 4, -32
 4300              		.cfi_offset 5, -28
 4301              		.cfi_offset 6, -24
 4302              		.cfi_offset 7, -20
 4303              		.cfi_offset 8, -16
 4304              		.cfi_offset 9, -12
 4305              		.cfi_offset 10, -8
 4306              		.cfi_offset 14, -4
2475:../lib/fat.c  ****         return 0;
 4307              		.loc 1 2475 0
 4308 1d9c 007050E2 		subs	r7, r0, #0
2474:../lib/fat.c  ****     if(!fs)
 4309              		.loc 1 2474 0
 4310 1da0 34D04DE2 		sub	sp, sp, #52
 4311              	.LCFI29:
 4312              		.cfi_def_cfa_offset 84
2475:../lib/fat.c  ****         return 0;
 4313              		.loc 1 2475 0
 4314 1da4 0200001A 		bne	.L556
 4315              	.LVL522:
 4316              	.L561:
 4317              	.LBB154:
2476:../lib/fat.c  **** 
 4318              		.loc 1 2476 0
 4319 1da8 0020A0E3 		mov	r2, #0
 4320 1dac 0030A0E3 		mov	r3, #0
 4321 1db0 260000EA 		b	.L557
 4322              	.LVL523:
 4323              	.L556:
 4324              	.LBE154:
2480:../lib/fat.c  ****     count_arg.buffer_size = sizeof(fat);
 4325              		.loc 1 2480 0
 4326 1db4 0030A0E3 		mov	r3, #0
 4327 1db8 0C308DE5 		str	r3, [sp, #12]
2481:../lib/fat.c  **** 
 4328              		.loc 1 2481 0
 4329 1dbc 2030A0E3 		mov	r3, #32
 4330 1dc0 10308DE5 		str	r3, [sp, #16]
2483:../lib/fat.c  ****     uint32_t fat_size = fs->header.fat_size;
 4331              		.loc 1 2483 0
 4332 1dc4 0C5087E2 		add	r5, r7, #12
 4333 1dc8 300095E8 		ldmia	r5, {r4-r5}
 4334              	.LVL524:
2484:../lib/fat.c  ****     while(fat_size > 0)
 4335              		.loc 1 2484 0
 4336 1dcc 146097E5 		ldr	r6, [r7, #20]
 4337              	.LVL525:
 4338              	.LBB155:
2491:../lib/fat.c  ****                                                 fat,
 4339              		.loc 1 2491 0
 4340 1dd0 8CA09FE5 		ldr	sl, .L568
 4341 1dd4 8C909FE5 		ldr	r9, .L568+4
 4342              	.LBE155:
2485:../lib/fat.c  ****     {
 4343              		.loc 1 2485 0
 4344 1dd8 170000EA 		b	.L558
 4345              	.LVL526:
 4346              	.L562:
 4347              	.LBB156:
2491:../lib/fat.c  ****                                                 fat,
 4348              		.loc 1 2491 0
 4349 1ddc 003097E5 		ldr	r3, [r7, #0]
 4350 1de0 04C093E5 		ldr	ip, [r3, #4]
 4351 1de4 1030D3E5 		ldrb	r3, [r3, #16]	@ zero_extendqisi2
2487:../lib/fat.c  ****         if(fat_size < length)
 4352              		.loc 1 2487 0
 4353 1de8 030076E3 		cmn	r6, #3
 4354 1dec 0680A091 		movls	r8, r6
 4355 1df0 0180E083 		mvnhi	r8, #1
 4356              	.LVL527:
2491:../lib/fat.c  ****                                                 fat,
 4357              		.loc 1 2491 0
 4358 1df4 060053E3 		cmp	r3, #6
 4359 1df8 0A30A011 		movne	r3, sl
 4360 1dfc 0930A001 		moveq	r3, r9
 4361 1e00 04308DE5 		str	r3, [sp, #4]
 4362 1e04 0C308DE2 		add	r3, sp, #12
 4363 1e08 08308DE5 		str	r3, [sp, #8]
 4364 1e0c 00808DE5 		str	r8, [sp, #0]
 4365 1e10 0400A0E1 		mov	r0, r4
 4366 1e14 0510A0E1 		mov	r1, r5
 4367 1e18 14208DE2 		add	r2, sp, #20
 4368 1e1c 2030A0E3 		mov	r3, #32
 4369 1e20 0FE0A0E1 		mov	lr, pc
 4370 1e24 1CFF2FE1 		bx	ip
 4371              	.LVL528:
 4372 1e28 000050E3 		cmp	r0, #0
 4373 1e2c DDFFFF0A 		beq	.L561
2507:../lib/fat.c  ****         fat_size -= length;
 4374              		.loc 1 2507 0
 4375 1e30 084094E0 		adds	r4, r4, r8
 4376              	.LVL529:
 4377 1e34 0050A5E2 		adc	r5, r5, #0
 4378              	.LVL530:
2508:../lib/fat.c  ****     }
 4379              		.loc 1 2508 0
 4380 1e38 066068E0 		rsb	r6, r8, r6
 4381              	.LVL531:
 4382              	.L558:
 4383              	.LBE156:
2485:../lib/fat.c  ****     {
 4384              		.loc 1 2485 0 discriminator 1
 4385 1e3c 000056E3 		cmp	r6, #0
 4386 1e40 E5FFFF1A 		bne	.L562
2511:../lib/fat.c  **** }
 4387              		.loc 1 2511 0
 4388 1e44 BA11D7E1 		ldrh	r1, [r7, #26]
 4389 1e48 0C009DE5 		ldr	r0, [sp, #12]
 4390 1e4c 902183E0 		umull	r2, r3, r0, r1
 4391              	.LVL532:
 4392              	.L557:
2512:../lib/fat.c  **** 
 4393              		.loc 1 2512 0
 4394 1e50 0200A0E1 		mov	r0, r2
 4395 1e54 0310A0E1 		mov	r1, r3
 4396 1e58 34D08DE2 		add	sp, sp, #52
 4397 1e5c F047BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 4398 1e60 1EFF2FE1 		bx	lr
 4399              	.L569:
 4400              		.align	2
 4401              	.L568:
 4402 1e64 00000000 		.word	fat_get_fs_free_32_callback
 4403 1e68 00000000 		.word	fat_get_fs_free_16_callback
 4404              		.cfi_endproc
 4405              	.LFE30:
 4407              		.align	2
 4408              		.global	find_file_in_dir
 4410              	find_file_in_dir:
 4411              	.LFB33:
2552:../lib/fat.c  **** #endif
2553:../lib/fat.c  **** 
2554:../lib/fat.c  **** uint8_t find_file_in_dir(struct fat_fs_struct* fs, struct fat_dir_struct* dd, const char* name, str
2555:../lib/fat.c  **** {
 4412              		.loc 1 2555 0
 4413              		.cfi_startproc
 4414              		@ Function supports interworking.
 4415              		@ args = 0, pretend = 0, frame = 0
 4416              		@ frame_needed = 0, uses_anonymous_args = 0
 4417              	.LVL533:
 4418 1e6c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 4419              	.LCFI30:
 4420              		.cfi_def_cfa_offset 16
 4421              		.cfi_offset 4, -16
 4422              		.cfi_offset 5, -12
 4423              		.cfi_offset 6, -8
 4424              		.cfi_offset 14, -4
 4425              		.loc 1 2555 0
 4426 1e70 0150A0E1 		mov	r5, r1
 4427 1e74 0260A0E1 		mov	r6, r2
 4428 1e78 0340A0E1 		mov	r4, r3
2556:../lib/fat.c  ****     while(fat_read_dir(dd, dir_entry))
 4429              		.loc 1 2556 0
 4430 1e7c 080000EA 		b	.L571
 4431              	.LVL534:
 4432              	.L573:
2557:../lib/fat.c  ****     {
2558:../lib/fat.c  ****         if(strcmp(dir_entry->long_name, name) == 0)
 4433              		.loc 1 2558 0
 4434 1e80 0400A0E1 		mov	r0, r4
 4435 1e84 0610A0E1 		mov	r1, r6
 4436 1e88 FEFFFFEB 		bl	strcmp
 4437              	.LVL535:
 4438 1e8c 000050E3 		cmp	r0, #0
 4439 1e90 0300001A 		bne	.L571
2559:../lib/fat.c  ****         {
2560:../lib/fat.c  ****             fat_reset_dir(dd);
 4440              		.loc 1 2560 0
 4441 1e94 0500A0E1 		mov	r0, r5
 4442 1e98 FEFFFFEB 		bl	fat_reset_dir
 4443              	.LVL536:
2561:../lib/fat.c  ****             return 1;
 4444              		.loc 1 2561 0
 4445 1e9c 0100A0E3 		mov	r0, #1
 4446 1ea0 040000EA 		b	.L572
 4447              	.L571:
2556:../lib/fat.c  ****     {
 4448              		.loc 1 2556 0 discriminator 1
 4449 1ea4 0500A0E1 		mov	r0, r5
 4450 1ea8 0410A0E1 		mov	r1, r4
 4451 1eac FEFFFFEB 		bl	fat_read_dir
 4452              	.LVL537:
 4453 1eb0 000050E3 		cmp	r0, #0
 4454 1eb4 F1FFFF1A 		bne	.L573
 4455              	.L572:
2562:../lib/fat.c  ****         }
2563:../lib/fat.c  ****     }
2564:../lib/fat.c  **** 
2565:../lib/fat.c  ****     return 0;
2566:../lib/fat.c  **** }
 4456              		.loc 1 2566 0
 4457 1eb8 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 4458 1ebc 1EFF2FE1 		bx	lr
 4459              		.cfi_endproc
 4460              	.LFE33:
 4462              		.align	2
 4463              		.global	open_file_in_dir
 4465              	open_file_in_dir:
 4466              	.LFB34:
2567:../lib/fat.c  **** 
2568:../lib/fat.c  **** struct fat_file_struct* open_file_in_dir(struct fat_fs_struct* fs, struct fat_dir_struct* dd, const
2569:../lib/fat.c  **** {
 4467              		.loc 1 2569 0
 4468              		.cfi_startproc
 4469              		@ Function supports interworking.
 4470              		@ args = 0, pretend = 0, frame = 52
 4471              		@ frame_needed = 0, uses_anonymous_args = 0
 4472              	.LVL538:
 4473 1ec0 10402DE9 		stmfd	sp!, {r4, lr}
 4474              	.LCFI31:
 4475              		.cfi_def_cfa_offset 8
 4476              		.cfi_offset 4, -8
 4477              		.cfi_offset 14, -4
 4478 1ec4 34D04DE2 		sub	sp, sp, #52
 4479              	.LCFI32:
 4480              		.cfi_def_cfa_offset 60
2570:../lib/fat.c  ****     struct fat_dir_entry_struct file_entry;
2571:../lib/fat.c  ****     if(!find_file_in_dir(fs, dd, name, &file_entry))
 4481              		.loc 1 2571 0
 4482 1ec8 0D30A0E1 		mov	r3, sp
2569:../lib/fat.c  ****     struct fat_dir_entry_struct file_entry;
 4483              		.loc 1 2569 0
 4484 1ecc 0040A0E1 		mov	r4, r0
 4485              		.loc 1 2571 0
 4486 1ed0 FEFFFFEB 		bl	find_file_in_dir
 4487              	.LVL539:
 4488 1ed4 000050E3 		cmp	r0, #0
2572:../lib/fat.c  ****         return 0;
2573:../lib/fat.c  **** 
2574:../lib/fat.c  ****     return fat_open_file(fs, &file_entry);
 4489              		.loc 1 2574 0
 4490 1ed8 0400A011 		movne	r0, r4
 4491 1edc 0D10A011 		movne	r1, sp
 4492 1ee0 FEFFFF1B 		blne	fat_open_file
 4493              	.LVL540:
 4494              	.L576:
2575:../lib/fat.c  **** }
 4495              		.loc 1 2575 0
 4496 1ee4 34D08DE2 		add	sp, sp, #52
 4497 1ee8 1040BDE8 		ldmfd	sp!, {r4, lr}
 4498 1eec 1EFF2FE1 		bx	lr
 4499              		.cfi_endproc
 4500              	.LFE34:
 4502              		.section	.rodata
 4503              		.set	.LANCHOR0,. + 0
 4504              	.LC0:
 4505 0000 01       		.byte	1
 4506 0001 03       		.byte	3
 4507 0002 05       		.byte	5
 4508 0003 07       		.byte	7
 4509 0004 09       		.byte	9
 4510 0005 0E       		.byte	14
 4511 0006 10       		.byte	16
 4512 0007 12       		.byte	18
 4513 0008 14       		.byte	20
 4514 0009 16       		.byte	22
 4515 000a 18       		.byte	24
 4516 000b 1C       		.byte	28
 4517 000c 1E       		.byte	30
 4518              		.bss
 4519              		.align	2
 4520              		.set	.LANCHOR1,. + 0
 4523              	fat_fs_handles:
 4524 0000 00000000 		.space	52
 4524      00000000 
 4524      00000000 
 4524      00000000 
 4524      00000000 
 4527              	fat_file_handles:
 4528 0034 00000000 		.space	68
 4528      00000000 
 4528      00000000 
 4528      00000000 
 4528      00000000 
 4531              	fat_dir_handles:
 4532 0078 00000000 		.space	128
 4532      00000000 
 4532      00000000 
 4532      00000000 
 4532      00000000 
 4533              		.text
 4534              	.Letext0:
 4535              		.file 2 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/stdint.h"
 4536              		.file 3 "../lib/sd_raw_config.h"
 4537              		.file 4 "../lib/partition.h"
 4538              		.file 5 "../lib/fat_config.h"
 4539              		.file 6 "../lib/fat.h"
 4540              		.file 7 "/opt/local/lib/gcc/arm-elf/4.7.3/include/stddef.h"
 4541              		.file 8 "../lib/byteordering.h"
 4542              		.file 9 "/opt/local/lib/gcc/arm-elf/4.7.3/../../../../arm-elf/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 fat.c
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:5      .text:0000000000000000 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:7      .text:0000000000000000 fat_clear_cluster_callback
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:26     .text:0000000000000008 fat_calc_83_checksum
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:70     .text:000000000000003c fat_get_fs_free_32_callback
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:131    .text:0000000000000084 fat_get_fs_free_16_callback
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:192    .text:00000000000000cc fat_dir_entry_read_callback
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:470    .text:0000000000000300 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:474    .text:0000000000000304 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:476    .text:0000000000000304 fat_get_next_cluster
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:588    .text:00000000000003d4 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:592    .text:00000000000003d8 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:594    .text:00000000000003d8 fat_free_clusters
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:796    .text:0000000000000564 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:800    .text:0000000000000568 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:802    .text:0000000000000568 fat_append_clusters
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1083   .text:0000000000000788 fat_cluster_offset
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1124   .text:00000000000007bc fat_clear_cluster.part.3
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1179   .text:0000000000000820 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1184   .text:0000000000000824 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1186   .text:0000000000000824 fat_write_dir_entry
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1541   .text:0000000000000ab8 fat_find_offset_for_dir_entry.part.4
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:1796   .text:0000000000000c90 fat_open
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2135   .text:0000000000000f00 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2140   .text:0000000000000f08 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2143   .text:0000000000000f08 fat_close
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2164   .text:0000000000000f18 fat_open_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2238   .text:0000000000000f9c $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2242   .text:0000000000000fa0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2245   .text:0000000000000fa0 fat_close_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2266   .text:0000000000000fb0 fat_read_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2498   .text:0000000000001140 fat_write_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:2808   .text:000000000000136c fat_resize_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3040   .text:00000000000014e4 fat_seek_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3146   .text:0000000000001590 fat_open_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3228   .text:0000000000001620 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3232   .text:0000000000001624 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3235   .text:0000000000001624 fat_close_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3256   .text:0000000000001634 fat_reset_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3285   .text:0000000000001654 fat_read_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3502   .text:00000000000017dc $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3506   .text:00000000000017e0 $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3509   .text:00000000000017e0 fat_get_dir_entry_of_path
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3680   .text:0000000000001910 fat_create_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3803   .text:00000000000019f0 fat_delete_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:3918   .text:0000000000001ac8 fat_move_file
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4042   .text:0000000000001bc4 fat_create_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4245   .text:0000000000001d54 fat_get_fs_size
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4288   .text:0000000000001d98 fat_get_fs_free
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4402   .text:0000000000001e64 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4407   .text:0000000000001e6c $a
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4410   .text:0000000000001e6c find_file_in_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4465   .text:0000000000001ec0 open_file_in_dir
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4519   .bss:0000000000000000 $d
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4523   .bss:0000000000000000 fat_fs_handles
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4527   .bss:0000000000000034 fat_file_handles
/var/folders/Jn/Jn5nG78rFb8fju5EIf+vh++++TM/-Tmp-//ccBuQm8R.s:4531   .bss:0000000000000078 fat_dir_handles
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
read32
read16
memset
memcpy
__divsi3
strlen
strrchr
write16
write32
__udivsi3
strchr
strncmp
strcmp
strncpy
